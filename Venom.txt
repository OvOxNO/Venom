‘********************************************************* 
‘‘***************** ‘coVdEeNcOoMde ‘******************     
‘********************************************************* 
'============================================================================ = 
' BEGIN MODULE: modMain (Standard Module) 
'============================================================================ = 
' Main application control module with cross-platform optimizations ' Version: 3.0 Mac-Optimized 
Option Explicit 
' Module constants 
Private Const APP_NAME As String = "Cross-Platform VBA Code Manager" Private Const APP_VERSION As String = "3.0" 
' Module variables 
Private m_isInitialized As Boolean 
Private m_startupDate As Date 
Private m_initializationInProgress As Boolean ' Flag to prevent  reentrant initialization 
'===== INITIALIZATION ===== 
' Initialize the application - establish neural control 
Public Sub InitializeApplication() 
' CRITICAL: Prevent stack overflow recursion and reentrant calls If m_isInitialized Or m_initializationInProgress Then 
Debug.Print "Initialization already in progress or complete - skipping" 
Exit Sub 
End If 
On Error GoTo ErrorHandler 
' Set flag that we're in the process of initializing to prevent reentrant  calls 
m_initializationInProgress = True 
' Record startup time - beginning of incubation period 
m_startupDate = Now 
Debug.Print "Starting application initialization: " & APP_NAME & " v" &  APP_VERSION 
' MAC OPTIMIZATION: Initialize essential modules only 
#If Mac Then 
' Simplified initialization for Mac - only the essentials 
modPlatform.InitializePlatform 
' Log startup - create record of patient zero 
Debug.Print "Infection initialized: " & APP_NAME & " v" & APP_VERSION  & " has begun systemic takeover"
Debug.Print "Host Platform: " & gPlatformName & " - biological  compatibility confirmed" 
' Set initialization flag last - only after all dependencies are  loaded 
m_isInitialized = True 
' Allow UI to refresh before continuing 
DoEvents 
' Initialize other modules in the background 
DelayedInitialization 
#Else 
' Full initialization for Windows - all systems 
modPlatform.InitializePlatform 
modRegExp.InitializeRegExpEngine 
modVisualStyle.InitializeDarkMode 
CodeManager.InitializeCodeManager 
' Log startup 
Debug.Print "Infection initialized: " & APP_NAME & " v" & APP_VERSION  & " has begun systemic takeover" 
Debug.Print "Host Platform: " & gPlatformName & " - biological  compatibility confirmed" 
Debug.Print "Host Version: " & GetOfficeVersion() & " - tissue  samples collected" 
' Set initialization flag last - only after all dependencies are  loaded 
m_isInitialized = True 
#End If 
' Clear initialization in progress flag 
m_initializationInProgress = False 
Exit Sub 
ErrorHandler: 
' Reset flags to allow retrying 
m_initializationInProgress = False 
m_isInitialized = False 
' Capture error info before it might be changed 
Dim errNum As Long, errDesc As String 
errNum = Err.Number 
errDesc = Err.description 
Debug.Print "Initialization error: " & errNum & " - " & errDesc 
' Try to call the error handler module's function using a safer approach On Error Resume Next 
Application.Run "ErrorHandler.HandleError", "modMain",  
"InitializeApplication", errNum, errDesc, True
If Err.Number <> 0 Then 
' Fallback if module function call fails 
MsgBox "Initialization failed: " & errDesc, vbCritical, "Error" End If 
On Error GoTo 0 
End Sub 
' MAC OPTIMIZATION: Delayed initialization for Mac 
Private Sub DelayedInitialization() 
On Error Resume Next 
Debug.Print "Starting delayed initialization for Mac..." 
' Initialize remaining modules after main app is responsive modRegExp.InitializeRegExpEngine 
' Allow UI to refresh 
DoEvents 
modVisualStyle.VS_Initialize 
' Allow UI to refresh 
DoEvents 
CodeManager.InitializeCodeManager 
' Get version info now that app is responsive 
Debug.Print "Host Version: " & GetOfficeVersion() & " - tissue samples  collected" 
Debug.Print "Delayed initialization complete" 
On Error GoTo 0 
End Sub 
' Get Office version with build number - analyze host tissue composition Public Function GetOfficeVersion() As String 
On Error Resume Next 
Dim version As String 
Dim build As String 
' Get version info safely 
version = "" 
build = "" 
' Try to get Application version 
If HasProperty(Application, "Version") Then 
version = Application.version 
End If 
' MAC OPTIMIZATION: Skip build number on Mac for performance #If Not Mac Then 
' Try to get build number if possible
If HasProperty(Application, "Build") Then 
build = Application.build 
End If 
#End If 
' Format the result 
If version <> "" And build <> "" Then 
GetOfficeVersion = version & " (Build: " & build & ") - genetic  sequence identified" 
ElseIf version <> "" Then 
GetOfficeVersion = version & " - partial genetic sequence" Else 
GetOfficeVersion = "Unknown - host organism resisting biopsy" End If 
If Err.Number <> 0 Then 
GetOfficeVersion = "Unknown - host organism resisting biopsy" End If 
On Error GoTo 0 
End Function 
' Helper function to safely check if an object has a property Private Function HasProperty(obj As Object, propName As String) As Boolean On Error Resume Next 
Dim temp As Variant 
temp = CallByName(obj, propName, VbGet) 
HasProperty = (Err.Number = 0) 
On Error GoTo 0 
End Function 
' Example command handler: 
Public Sub ReorganizeCodeStructure() 
On Error GoTo ErrorHandler 
' Ensure application is initialized first 
If Not m_isInitialized Then InitializeApplication 
Dim codeText As String 
codeText = GetDocumentText() 
' MAC OPTIMIZATION: Check size before processing 
If Len(codeText) > 100000 And gIsMac Then 
MsgBox "Document is very large. Code reorganization may take longer  on Mac.", vbInformation, "Large Document" 
End If 
Dim organizedCode As String 
organizedCode = OrganizeCode(codeText) 
SetDocumentText organizedCode 
Exit Sub
ErrorHandler: 
On Error Resume Next 
Application.Run "ErrorHandler.HandleError", "modMain",  "ReorganizeCodeStructure", Err.Number, Err.description, True On Error GoTo 0 
End Sub 
' Example command handler: 
Public Sub ShowCodeNavigator() 
On Error GoTo ErrorHandler 
' Ensure application is initialized first 
If Not m_isInitialized Then InitializeApplication 
Dim codeText As String 
codeText = GetDocumentText() 
' MAC OPTIMIZATION: Check size before processing 
If Len(codeText) > 100000 And gIsMac Then 
MsgBox "Document is very large. Code navigation may be slower on  Mac.", vbInformation, "Large Document" 
End If 
' Call navigation dialog with appropriate module 
Application.Run "modCodeNavigator.ShowNavigationDialog", codeText Exit Sub 
ErrorHandler: 
On Error Resume Next 
Application.Run "ErrorHandler.HandleError", "modMain",  "ShowCodeNavigator", Err.Number, Err.description, True 
On Error GoTo 0 
End Sub 
' Called when document is closed - host termination procedure Public Sub Auto_Close() 
On Error Resume Next 
' Clean up resources - extract parasite before host death CleanupApplication 
On Error GoTo 0 
End Sub 
' Clean up application resources - withdraw parasite cleanly Private Sub CleanupApplication() 
On Error Resume Next 
' Skip cleanup if not initialized 
If Not m_isInitialized Then Exit Sub
Debug.Print "Starting cleanup process..." 
' Close any open forms - seal the exit wounds 
' MAC OPTIMIZATION: Use safer approach on Mac 
#If Mac Then 
' Mac safer approach - avoid potential freezes from form collection Application.statusBar = "Closing application..." 
DoEvents 
#Else 
' Windows approach - iterate through forms 
Dim frm As Object 
For Each frm In VBA.UserForms 
Unload frm 
Next frm 
#End If 
' Log shutdown - document host demise 
Debug.Print "Application shutdown: " & APP_NAME & " - host survival  terminated" 
If m_startupDate <> 0 Then 
Debug.Print "Infection duration: " & format(Now - m_startupDate,  "hh:nn:ss") & " - autopsy complete" 
End If 
m_isInitialized = False 
Application.statusBar = False 
On Error GoTo 0 
End Sub 
'===== PLATFORM DETECTION ===== 
' Detect platform and initialize platform globals - identify host DNA Public Sub DetectPlatform() 
On Error Resume Next 
' MAC OPTIMIZATION: Direct platform detection without constants #If Mac Then 
gIsMac = True 
gIsWin = False 
gPlatformName = "Mac" 
gPathSeparator = "/" 
gLineBreak = vbLf 
#Else 
gIsMac = False 
gIsWin = True 
gPlatformName = "Windows" 
gPathSeparator = "\" 
gLineBreak = vbCrLf 
#End If 
Debug.Print "Platform detected: " & gPlatformName
' Initialize code formatter - prepare for code formatting 
' MAC OPTIMIZATION: Check if already initialized first 
If Not m_isInitialized Then 
On Error Resume Next 
Application.Run "CodeFormatter.InitializeCodeFormatter" 
If Err.Number <> 0 Then 
Debug.Print "Warning: CodeFormatter initialization error: " &  Err.Number & " - " & Err.description 
End If 
On Error GoTo 0 
End If 
On Error GoTo 0 
End Sub 
' Check if application is initialized - is the parasite attached* Public Function IsInitialized() As Boolean 
IsInitialized = m_isInitialized 
End Function 
' Get application uptime - measure infection duration 
Public Function GetUptime() As String 
If m_startupDate = 0 Then 
GetUptime = "00:00:00 - Infection stalled" 
Else 
GetUptime = format(Now - m_startupDate, "hh:nn:ss") & " - Parasitic  attachment sustained" 
End If 
End Function 
'===== MAIN OPERATIONS ===== 
' Format VBA code - inject venom into source 
Public Function FormatVBACode(ByVal code As String) As String On Error GoTo ErrorHandler 
' Ensure application is initialized - verify parasitic attachment If Not m_isInitialized Then InitializeApplication 
' MAC OPTIMIZATION: Check size before processing 
If Len(code) > 100000 And gIsMac Then 
Debug.Print "Warning: Formatting large code block on Mac (" &  Len(code) & " bytes)" 
End If 
' Use CodeManager to format code - resequence DNA 
FormatVBACode = FormatCode(code) 
Exit Function 
ErrorHandler: 
On Error Resume Next 
' Capture error details
Dim errNum As Long, errDesc As String 
errNum = Err.Number 
errDesc = Err.description 
Debug.Print "Code formatting error: " & errNum & " - " & errDesc 
' Try to use error handler 
Application.Run "ErrorHandler.HandleError", "modMain", "FormatVBACode",  errNum, errDesc 
' Return original code on error - failed genetic manipulation FormatVBACode = code 
On Error GoTo 0 
End Function 
' Analyze code for duplicates - identify redundant cellular structures Public Function AnalyzeCode(ByVal code As String) As String On Error GoTo ErrorHandler 
' Ensure application is initialized - verify parasitic attachment If Not m_isInitialized Then InitializeApplication 
' MAC OPTIMIZATION: Check size before processing 
If Len(code) > 100000 And gIsMac Then 
Debug.Print "Warning: Analyzing large code block on Mac (" &  Len(code) & " bytes)" 
End If 
' Use CodeManager to analyze code - perform genetic sequencing AnalyzeCode = AnalyzeCodeForDuplicates() 
Exit Function 
ErrorHandler: 
On Error Resume Next 
' Capture error details 
Dim errNum As Long, errDesc As String 
errNum = Err.Number 
errDesc = Err.description 
Debug.Print "Code analysis error: " & errNum & " - " & errDesc ' Try to use error handler 
Application.Run "ErrorHandler.HandleError", "modMain", "AnalyzeCode",  errNum, errDesc 
AnalyzeCode = "Error analyzing code - autopsy failed due to advanced  decomposition" 
On Error GoTo 0 
End Function
' Show main application form - reveal the control interface Public Sub ShowMainForm() 
On Error GoTo ErrorHandler 
' Ensure application is initialized - verify parasitic attachment If Not m_isInitialized Then InitializeApplication 
' Implementation would create and show main form - reveal the neural  interface 
MsgBox "Primary neural interface would be displayed here - direct access  to host central nervous system", vbInformation, APP_NAME 
Exit Sub 
ErrorHandler: 
On Error Resume Next 
' Capture error details 
Dim errNum As Long, errDesc As String 
errNum = Err.Number 
errDesc = Err.description 
Debug.Print "Main form error: " & errNum & " - " & errDesc 
' Try to use error handler 
Application.Run "ErrorHandler.HandleError", "modMain", "ShowMainForm",  errNum, errDesc, True 
On Error GoTo 0 
End Sub 
' Helper to get document text 
Private Function GetDocumentText() As String 
On Error Resume Next 
GetDocumentText = ActiveDocument.Range.text 
If Err.Number <> 0 Then 
GetDocumentText = "" 
Debug.Print "Error getting document text: " & Err.Number & " - " &  Err.description 
End If 
On Error GoTo 0 
End Function 
' Helper to set document text 
Private Sub SetDocumentText(newText As String) 
On Error Resume Next 
ActiveDocument.Range.text = newText 
If Err.Number <> 0 Then 
Debug.Print "Error setting document text: " & Err.Number & " - " &  Err.description 
End If 
On Error GoTo 0 
End Sub
' FormatCode function (placeholder for CodeManager call) 
Private Function FormatCode(code As String) As String 
On Error Resume Next 
' Try to call the actual function from CodeManager 
Dim result As String 
result = "" 
Application.Run "CodeManager.FormatCode", code 
If Err.Number <> 0 Then 
Debug.Print "Error calling FormatCode: " & Err.Number & " - " &  Err.description 
FormatCode = code ' Return original on error 
Else 
FormatCode = result 
End If 
On Error GoTo 0 
End Function 
' AnalyzeCodeForDuplicates function (placeholder for CodeManager call) Private Function AnalyzeCodeForDuplicates() As String 
On Error Resume Next 
' Try to call the actual function from CodeManager 
Dim result As String 
result = "" 
Application.Run "CodeManager.AnalyzeCodeForDuplicates" 
If Err.Number <> 0 Then 
Debug.Print "Error calling AnalyzeCodeForDuplicates: " & Err.Number &  " - " & Err.description 
AnalyzeCodeForDuplicates = "Error during code analysis" 
Else 
AnalyzeCodeForDuplicates = result 
End If 
On Error GoTo 0 
End Function 
' OrganizeCode function (placeholder for GeneSplicer call) 
Private Function OrganizeCode(code As String) As String 
On Error Resume Next 
' Try to call the actual function 
Dim result As String 
result = "" 
Application.Run "modGeneSplicer.OrganizeCode", code 
If Err.Number <> 0 Then
Debug.Print "Error calling OrganizeCode: " & Err.Number & " - " &  Err.description 
OrganizeCode = code ' Return original on error 
Else 
OrganizeCode = result 
End If 
On Error GoTo 0 
End Function 
'============================================================================ = 
' END MODULE: modMain 
'============================================================================ = 
‘********************************************************* 
‘‘***************** ‘coVdEeNcOoMde ‘******************     
‘********************************************************* 
'============================================================== ' BEGIN MODULE: modPlatform (Standard Module) 
'============================================================== ' Platform globals - initialized in DetectPlatform() 
Public gIsMac As Boolean ' Is this a Mac host* 
Public gIsWin As Boolean ' Is this Windows* 
Public gPlatformName As String ' Host platform name ("Mac" or "Windows") Public gPathSeparator As String ' Path separator ("/" or "\\") Public gLineBreak As String ' Line break (vbLf or vbCrLf) Public gConfig As Object ' Global configuration dictionary 
' Track initialization 
Private m_isInitialized As Boolean ' Flag to prevent recursive initialization 
' Main entry point for platform initialization 
Public Sub InitializePlatform() 
' Prevent recursive calls which cause stack overflow 
If m_isInitialized Then Exit Sub 
' Debug checkpoint for Mac troubleshooting 
Debug.Print "Starting platform initialization..." 
' Set flag to prevent re-entry 
m_isInitialized = True 
' Perform the platform detection 
DetectPlatform 
' Create global configuration dictionary if needed 
If gConfig Is Nothing Then 
' Dynamically choose dictionary implementation based on detected  platform 
If gIsMac Then 
' For Mac: Create Collection-based dictionary
Set gConfig = CreateMacDictionary() 
Debug.Print "Created Mac-compatible dictionary" 
Else 
' For Windows: Try standard Scripting.Dictionary 
On Error Resume Next 
Set gConfig = CreateObject("Scripting.Dictionary") 
' Fallback if Scripting.Dictionary fails 
If Err.Number <> 0 Then 
Set gConfig = CreateMacDictionary() 
Err.Clear 
Debug.Print "Fallback to Mac dictionary on Windows" 
Else 
Debug.Print "Created Windows Scripting.Dictionary" 
End If 
On Error GoTo 0 
End If 
End If 
' Add IsInDarkMode as a default configuration 
If Not DictExists(gConfig, "IsInDarkMode") Then 
DictAdd gConfig, "IsInDarkMode", False 
End If 
' Only try to detect dark mode if supported 
Dim darkModeValue As Boolean 
darkModeValue = False 
' Use simpler dark mode detection to avoid freezes 
If gIsMac Then 
' On Mac, hard-code dark mode value to avoid AppleScript freezes ' This will be replaced with a proper detection approach in later  versions 
darkModeValue = True 
Debug.Print "Using safe Dark Mode value on Mac (always true)" Else 
' On Windows, use full detection 
darkModeValue = DetectDarkMode() 
Debug.Print "Detected Dark Mode on Windows: " & darkModeValue End If 
' Update the dictionary 
If DictExists(gConfig, "IsInDarkMode") Then 
DictSet gConfig, "IsInDarkMode", darkModeValue 
Else 
DictAdd gConfig, "IsInDarkMode", darkModeValue 
End If 
' Log the successful initialization 
Debug.Print "=== Platform Debug Info ===" 
Debug.Print "gIsMac: " & gIsMac 
Debug.Print "gIsWin: " & gIsWin 
Debug.Print "gPlatformName: " & gPlatformName 
Debug.Print "Office Version: " & Application.version 
Debug.Print "========================"
End Sub 
' Create a Mac-compatible dictionary using Collections Private Function CreateMacDictionary() As Object 
Dim dict As New collection 
' Add a special item to track keys 
dict.Add New collection, "___KEYS___" 
Set CreateMacDictionary = dict 
End Function 
' Cross-platform dictionary functions 
Public Function DictExists(dict As Object, key As String) As Boolean On Error Resume Next 
DictExists = False 
If typeName(dict) = "Dictionary" Then 
' Windows Dictionary 
DictExists = dict.exists(key) 
ElseIf typeName(dict) = "Collection" Then 
' Mac Collection-based dictionary 
Dim keys As collection 
Set keys = dict("___KEYS___") 
Dim i As Integer 
For i = 1 To keys.count 
If keys(i) = key Then 
DictExists = True 
Exit For 
End If 
Next i 
End If 
On Error GoTo 0 
End Function 
' Add to dictionary on either platform 
Public Sub DictAdd(dict As Object, key As String, value As Variant) On Error Resume Next 
If typeName(dict) = "Dictionary" Then 
' Windows Dictionary 
If Not dict.exists(key) Then dict.Add key, value 
ElseIf typeName(dict) = "Collection" Then 
' Mac Collection-based dictionary 
Dim keys As collection 
Set keys = dict("___KEYS___") 
' Check if key already exists 
Dim exists As Boolean 
exists = False 
Dim i As Integer 
For i = 1 To keys.count 
If keys(i) = key Then 
exists = True 
Exit For
End If 
Next i 
' Add only if not exists 
If Not exists Then 
keys.Add key 
dict.Add value, key 
End If 
End If 
On Error GoTo 0 
End Sub 
' Set value in dictionary on either platform 
Public Sub DictSet(dict As Object, key As String, value As Variant) On Error Resume Next 
If typeName(dict) = "Dictionary" Then 
' Windows Dictionary 
If dict.exists(key) Then dict(key) = value 
ElseIf typeName(dict) = "Collection" Then 
' Mac Collection-based dictionary 
If DictExists(dict, key) Then 
dict.Remove key 
dict.Add value, key 
End If 
End If 
On Error GoTo 0 
End Sub 
' Get value from dictionary on either platform 
Public Function DictGet(dict As Object, key As String) As Variant On Error Resume Next 
If typeName(dict) = "Dictionary" Then 
' Windows Dictionary 
If dict.exists(key) Then 
If IsObject(dict(key)) Then 
Set DictGet = dict(key) 
Else 
DictGet = dict(key) 
End If 
End If 
ElseIf typeName(dict) = "Collection" Then 
' Mac Collection-based dictionary 
If DictExists(dict, key) Then 
If IsObject(dict(key)) Then 
Set DictGet = dict(key) 
Else 
DictGet = dict(key) 
End If 
End If
End If 
On Error GoTo 0 
End Function 
' Detect platform and initialize platform globals Public Sub DetectPlatform() 
On Error Resume Next 
' Simple compile-time directive for initial setup #If Mac Then 
gIsMac = True 
gIsWin = False 
gPlatformName = "Mac" 
#Else 
gIsMac = False 
gIsWin = True 
gPlatformName = "Windows" 
#End If 
' Set platform-specific path separator 
If gIsMac Then 
gPathSeparator = "/" 
gLineBreak = vbLf 
Else 
gPathSeparator = "\\" 
gLineBreak = vbCrLf 
End If 
On Error GoTo 0 
End Sub 
' Keep original GetPlatform function with fixes for Mac Public Function GetPlatform() As String 
' Use cached value if available 
If gPlatformName <> "" Then 
GetPlatform = gPlatformName 
Exit Function 
End If 
' Simpler approach that works cross-platform On Error Resume Next 
' Start with compile-time detection 
#If Mac Then 
GetPlatform = "Mac" 
#Else 
GetPlatform = "Windows" 
#End If 
' Try to confirm with runtime detection if needed If GetPlatform = "" Then 
' Last resort - check file path separator 
Dim pathSep As String
pathSep = Application.pathSeparator 
If pathSep = ":" Or pathSep = "/" Then 
GetPlatform = "Mac" 
Else 
GetPlatform = "Windows" 
End If 
End If 
On Error GoTo 0 
End Function 
' Detect dark mode - WITH MAC OPTIMIZATION 
Private Function DetectDarkMode() As Boolean 
On Error Resume Next 
' Default to False 
DetectDarkMode = False 
' Platform-specific detection 
If gIsMac Then 
#If Mac Then 
' MAC OPTIMIZATION: Avoid AppleScript for dark mode detection ' Just return true to avoid Mac freezing issues 
DetectDarkMode = True 
#End If 
Else 
' Windows visual cortex analysis 
Dim wsh As Object 
If IsFeatureSupported("wscript") Then 
On Error Resume Next 
Set wsh = CreateObject("WScript.Shell") 
' Probe Windows 10+ registry for light sensitivity 
Dim registryValue As String 
registryValue =  
wsh.RegRead("HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Them es\Personalize\AppsUseLightTheme") 
' Registry value of 0 indicates enhanced dark sensitivity 
If Err.Number = 0 And registryValue = "0" Then 
DetectDarkMode = True 
Debug.Print "Windows configured for dark mode" 
End If 
Set wsh = Nothing 
End If 
End If 
' Final validity check to ensure Boolean 
Dim finalResult As Boolean 
If DetectDarkMode Then 
finalResult = True 
Else
finalResult = False 
End If 
DetectDarkMode = finalResult 
On Error GoTo 0 
End Function 
' Get platform information - update to use platform-neutral dictionary Public Function GetPlatformInfo() As Object 
On Error Resume Next 
' Create a comprehensive diagnostic vessel 
Dim infoDictionary As Object 
' Use appropriate dictionary type based on platform 
If gIsMac Then 
Set infoDictionary = CreateMacDictionary() 
Else 
Set infoDictionary = CreateObject("Scripting.Dictionary") ' Fallback if needed 
If Err.Number <> 0 Then 
Set infoDictionary = CreateMacDictionary() 
Err.Clear 
End If 
End If 
' Add core genetic markers 
DictAdd infoDictionary, "PlatformName", gPlatformName DictAdd infoDictionary, "IsMac", gIsMac 
DictAdd infoDictionary, "IsWin", gIsWin 
DictAdd infoDictionary, "PathSeparator", gPathSeparator DictAdd infoDictionary, "LineBreak", gLineBreak 
' Include dark mode settings 
Dim darkModeValue As Boolean 
darkModeValue = False 
If DictExists(gConfig, "IsInDarkMode") Then 
darkModeValue = DictGet(gConfig, "IsInDarkMode") 
Else 
darkModeValue = DetectDarkMode() 
End If 
DictAdd infoDictionary, "IsInDarkMode", darkModeValue 
Set GetPlatformInfo = infoDictionary 
On Error GoTo 0 
End Function 
' Add this to ensure proper platform feature detection Public Function IsFeatureSupported(featureName As String) As Boolean ' Original feature detection code here... 
Select Case LCase(featureName) 
Case "activex"
IsFeatureSupported = gIsWin 
Case "wscript", "wsh" 
If gIsWin Then 
On Error Resume Next 
Dim wsh As Object 
Set wsh = CreateObject("WScript.Shell") 
IsFeatureSupported = (Err.Number = 0) 
Set wsh = Nothing 
On Error GoTo 0 
Else 
IsFeatureSupported = False 
End If 
Case "applescript" 
IsFeatureSupported = gIsMac 
Case Else 
IsFeatureSupported = False 
End Select 
End Function 
'============================================================== 
' END MODULE: modPlatform 
'============================================================== 
‘********************************************************* 
‘‘***************** ‘coVdEeNcOoMde ‘******************     
‘********************************************************* 
'============================================================================ = 
' BEGIN MODULE: RegExpManager (Standard Module) 
'============================================================================ = 
'  
||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||| ' modRegExp - Enhanced Cross-platform Pattern Vivisection 
' Version: 3.0 Mac-Optimized 
' Dissecting strings with surgical precision, leaving only the viscera you  desire. 
' Updated by: Aaron McCutchins on 2025-05-13 
'  
||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||| Option Explicit 
Private m_regExpEngine As Object 
Private m_usingFallback As Boolean 
Private m_engineType As String 
Private m_isInitialized As Boolean ' Track initialization state 
'===== INITIALIZATION - PREPARING THE SURGICAL IMPLEMENTS ===== Public Sub InitializeRegExpEngine() 
On Error Resume Next 
' Prevent recursive initialization
If m_isInitialized Then Exit Sub 
Debug.Print "Initializing RegExp engine..." 
#If Mac Then 
' MAC OPTIMIZATION: Always use custom engine on Mac 
' Regular expression engine on Mac can cause issues with  VBScript.RegExp 
Set m_regExpEngine = CreateCustomRegExpEngine() 
m_engineType = "Custom" 
m_usingFallback = True 
Debug.Print "Using custom RegExp engine for Mac compatibility" #Else 
' Windows: Try to use VBScript.RegExp 
On Error Resume Next 
Set m_regExpEngine = CreateObject("VBScript.RegExp") 
If Err.Number = 0 Then 
m_engineType = "VBScript.RegExp" 
m_usingFallback = False 
Debug.Print "Using VBScript.RegExp for Windows" 
Else 
' Fallback if VBScript.RegExp isn't available 
Set m_regExpEngine = CreateCustomRegExpEngine() 
m_engineType = "Custom" 
m_usingFallback = True 
Debug.Print "Falling back to custom RegExp engine on Windows" End If 
#End If 
m_isInitialized = True 
On Error GoTo 0 
End Sub 
' Create custom RegExp engine for fallback - craft primitive surgical tools Private Function CreateCustomRegExpEngine() As Object 
On Error Resume Next 
' Use a simple dictionary to hold our implementation 
Dim dict As Object 
#If Mac Then 
' For Mac, use our cross-platform dictionary approach 
Set dict = New collection 
dict.Add New collection, "##Keys##" 
#Else 
' For Windows, try Scripting.Dictionary 
Set dict = CreateObject("Scripting.Dictionary") 
' Fallback if needed 
If Err.Number <> 0 Then 
Set dict = New collection
dict.Add New collection, "##Keys##" 
End If 
#End If 
Set CreateCustomRegExpEngine = dict 
On Error GoTo 0 
End Function 
'===== REGEXP OPERATIONS - VIVISECTION PROCEDURES ===== 
' Cross-platform RegExp match - locate victims matching the pattern Public Function RegExMatch(ByVal text As String, ByVal pattern As String, _ Optional ByVal ignoreCase As Boolean = True, _ 
Optional ByVal GlobalMatch As Boolean = True) As  
Boolean 
On Error Resume Next 
' Initialize if needed 
If Not m_isInitialized Then InitializeRegExpEngine 
' MAC OPTIMIZATION: Add size checks for very large inputs 
If Len(text) > 100000 And gIsMac Then 
' Skip detailed regex for extremely large text on Mac 
RegExMatch = InStr(1, text, pattern, IIf(ignoreCase, vbTextCompare,  vbBinaryCompare)) > 0 
Debug.Print "Using simplified matching for large text on Mac" Exit Function 
End If 
If Not m_usingFallback Then 
' Use VBScript.RegExp - precision surgical implement 
With m_regExpEngine 
.pattern = pattern 
.ignoreCase = ignoreCase 
.Global = GlobalMatch 
RegExMatch = .Test(text) 
End With 
Else 
' Use custom implementation - makeshift butcher's tools 
RegExMatch = CustomMatch(text, pattern, ignoreCase, GlobalMatch) End If 
' Check for errors 
If Err.Number <> 0 Then 
Debug.Print "RegEx match error: " & Err.Number & " - " &  
Err.description 
RegExMatch = SimplePatternMatch(text, pattern, ignoreCase) 
End If 
On Error GoTo 0 
End Function 
' Cross-platform RegExp replace - forcibly extract and replace string organs Public Function RegExReplace(ByVal text As String, ByVal pattern As String, _
ByVal Replacement As String, _ 
Optional ByVal ignoreCase As Boolean = True, _ 
Optional ByVal GlobalReplace As Boolean = True) As  
String 
On Error Resume Next 
' Initialize if needed 
If Not m_isInitialized Then InitializeRegExpEngine 
' MAC OPTIMIZATION: Add size checks for very large inputs 
If Len(text) > 100000 And gIsMac Then 
' Skip detailed regex for extremely large text on Mac 
RegExReplace = Replace(text, pattern, Replacement, 1, -1,  
IIf(ignoreCase, vbTextCompare, vbBinaryCompare)) 
Debug.Print "Using simplified replacement for large text on Mac" Exit Function 
End If 
If Not m_usingFallback Then 
' Use VBScript.RegExp - seamless organ replacement 
With m_regExpEngine 
.pattern = pattern 
.ignoreCase = ignoreCase 
.Global = GlobalReplace 
RegExReplace = .Replace(text, Replacement) 
End With 
Else 
' Use custom implementation - forcible organ transplantation RegExReplace = CustomReplace(text, pattern, Replacement, ignoreCase,  GlobalReplace) 
End If 
' Check for errors 
If Err.Number <> 0 Then 
Debug.Print "RegEx replace error: " & Err.Number & " - " &  Err.description 
RegExReplace = SimpleReplace(text, pattern, Replacement, ignoreCase) End If 
On Error GoTo 0 
End Function 
' RegExp find all matches - catalog all viable organs for harvesting Public Function RegExFindAll(ByVal text As String, ByVal pattern As String, _ 
Optional ByVal ignoreCase As Boolean = True) As  
collection 
On Error Resume Next 
Dim results As New collection 
' Initialize if needed 
If Not m_isInitialized Then InitializeRegExpEngine 
' MAC OPTIMIZATION: Add size checks for very large inputs
If Len(text) > 100000 And gIsMac Then 
' Simple find approach for large text on Mac 
FindAllSimple text, pattern, ignoreCase, results 
Debug.Print "Using simplified find all for large text on Mac" Set RegExFindAll = results 
Exit Function 
End If 
If Not m_usingFallback Then 
' Use VBScript.RegExp - precise tissue identification 
With m_regExpEngine 
.pattern = pattern 
.ignoreCase = ignoreCase 
.Global = True 
Dim matches As Object 
Dim match As Object 
Set matches = .Execute(text) 
' MAC OPTIMIZATION: Limit result count for large matches 
Dim maxMatches As Long 
maxMatches = IIf(gIsMac, 1000, 10000) ' Limit to 1000 matches on  Mac 
Dim matchCount As Long 
matchCount = 0 
For Each match In matches 
results.Add match.value 
matchCount = matchCount + 1 
If gIsMac And matchCount >= maxMatches Then 
Debug.Print "Reached match limit on Mac (" & maxMatches &  
")" 
Exit For 
End If 
Next match 
End With 
Else 
' Use custom implementation - manual organ identification 
Set results = CustomFindAll(text, pattern, ignoreCase) 
End If 
Set RegExFindAll = results 
' Check for errors 
If Err.Number <> 0 Then 
Debug.Print "RegEx find all error: " & Err.Number & " - " &  Err.description 
Set RegExFindAll = New collection 
End If 
On Error GoTo 0 
End Function
' Simplified Find All function for large text on Mac 
Private Sub FindAllSimple(ByVal text As String, ByVal pattern As String, _ ByVal ignoreCase As Boolean, ByRef results As  
collection) 
On Error Resume Next 
Dim compareMethod As VbCompareMethod 
compareMethod = IIf(ignoreCase, vbTextCompare, vbBinaryCompare) 
Dim position As Long 
Dim searchStart As Long 
Dim foundText As String 
Dim foundCount As Long 
searchStart = 1 
foundCount = 0 
' Limit to 1000 matches for Mac performance 
Const MAC_MATCH_LIMIT As Long = 1000 
' Find instances of pattern 
Do 
position = InStr(searchStart, text, pattern, compareMethod) If position = 0 Then Exit Do 
foundText = Mid(text, position, Len(pattern)) 
results.Add foundText 
searchStart = position + 1 
foundCount = foundCount + 1 
If gIsMac And foundCount >= MAC_MATCH_LIMIT Then 
Exit Do 
End If 
' Prevent infinite loop 
If searchStart > Len(text) Then Exit Do 
Loop 
On Error GoTo 0 
End Sub 
'===== CUSTOM IMPLEMENTATION METHODS - IMPROVISED SURGICAL TOOLS ===== ' Custom match implementation for when VBScript.RegExp isn't available - back-alley vivisection 
Private Function CustomMatch(ByVal text As String, ByVal pattern As String, _ ByVal ignoreCase As Boolean, ByVal GlobalMatch As  
Boolean) As Boolean 
On Error Resume Next 
' Extended custom pattern matching with support for more patterns Dim compareMethod As VbCompareMethod 
compareMethod = IIf(ignoreCase, vbTextCompare, vbBinaryCompare)
' Handle special patterns like \d, \w, \s 
If InStr(1, pattern, "\") > 0 Then 
CustomMatch = CustomAdvancedMatch(text, pattern, compareMethod) Else 
' Simple pattern matching 
CustomMatch = SimplePatternMatch(text, pattern, ignoreCase) 
End If 
On Error GoTo 0 
End Function 
' Advanced pattern matching for common regex symbols - specialized tissue  probes 
Private Function CustomAdvancedMatch(ByVal text As String, ByVal pattern As  String, _ 
ByVal compareMethod As VbCompareMethod) As  
Boolean 
On Error Resume Next 
' MAC OPTIMIZATION: Limit pattern complexity for Mac 
If Len(pattern) > 100 And gIsMac Then 
' For very complex patterns on Mac, use simplified matching CustomAdvancedMatch = (InStr(1, text, pattern, compareMethod) > 0) Exit Function 
End If 
' Enhanced pattern matching for \d (digits), \w (word chars), \s  (whitespace) 
Dim convertedPattern As String 
Dim i As Long 
Dim char As String 
' Convert regex special characters to VBA patterns 
i = 1 
While i <= Len(pattern) 
char = Mid(pattern, i, 1) 
If char = "\" And i < Len(pattern) Then 
Select Case Mid(pattern, i + 1, 1) 
Case "d" 
convertedPattern = convertedPattern & "[0-9]" 
i = i + 1 
Case "w" 
convertedPattern = convertedPattern & "[a-zA-Z0-9_]" 
i = i + 1 
Case "s" 
convertedPattern = convertedPattern & "[ " & vbTab & vbCr  
& vbLf & "]" 
i = i + 1 
Case Else 
convertedPattern = convertedPattern & char 
End Select 
Else
convertedPattern = convertedPattern & char 
End If 
i = i + 1 
Wend 
' Use simple pattern matching with converted pattern 
CustomAdvancedMatch = SimplePatternMatch(text, convertedPattern,  (compareMethod = vbTextCompare)) 
On Error GoTo 0 
End Function 
' Custom replace implementation - manual organ replacement 
Private Function CustomReplace(ByVal text As String, ByVal pattern As String,  _ 
ByVal Replacement As String, _ 
ByVal ignoreCase As Boolean, ByVal GlobalReplace  
As Boolean) As String 
On Error Resume Next 
' Enhanced custom replace with support for capture groups 
Dim result As String 
Dim compareMethod As VbCompareMethod 
Dim position As Long 
Dim foundCount As Long 
compareMethod = IIf(ignoreCase, vbTextCompare, vbBinaryCompare) result = text 
foundCount = 0 
' MAC OPTIMIZATION: Add iteration limit for Mac 
Dim maxIterations As Long 
maxIterations = IIf(gIsMac, 100, 1000) ' Lower limit for Mac 
' Handle global replace 
Do 
position = InStr(1, result, pattern, compareMethod) 
If position = 0 Then Exit Do 
result = Left(result, position - 1) & Replacement & Mid(result,  position + Len(pattern)) 
foundCount = foundCount + 1 
If Not GlobalReplace Then Exit Do 
' Prevent infinite loop 
If foundCount > maxIterations Then 
Debug.Print "Replace iteration limit reached (" & maxIterations &  ")" 
Exit Do 
End If 
Loop
CustomReplace = result 
On Error GoTo 0 
End Function 
' Custom find all implementation - manual tissue sample collection Private Function CustomFindAll(ByVal text As String, ByVal pattern As String,  _ 
ByVal ignoreCase As Boolean) As collection 
On Error Resume Next 
Dim results As New collection 
Dim compareMethod As VbCompareMethod 
Dim position As Long 
Dim searchStart As Long 
Dim foundText As String 
Dim foundCount As Long 
compareMethod = IIf(ignoreCase, vbTextCompare, vbBinaryCompare) searchStart = 1 
foundCount = 0 
' MAC OPTIMIZATION: Limit matches on Mac 
Dim maxMatches As Long 
maxMatches = IIf(gIsMac, 100, 1000) ' Lower limit for Mac 
' Find all instances of pattern 
Do 
position = InStr(searchStart, text, pattern, compareMethod) 
If position = 0 Then Exit Do 
foundText = Mid(text, position, Len(pattern)) 
results.Add foundText 
searchStart = position + Len(pattern) 
foundCount = foundCount + 1 
' MAC OPTIMIZATION: Limit total matches on Mac 
If gIsMac And foundCount >= maxMatches Then 
Debug.Print "Find all match limit reached on Mac (" & maxMatches  & ")" 
Exit Do 
End If 
' Prevent infinite loop 
If searchStart > Len(text) Then Exit Do 
Loop 
Set CustomFindAll = results 
On Error GoTo 0 
End Function 
'===== FALLBACK METHODS - PRIMITIVE SURGICAL TOOLS =====
' Simple fallback pattern matching for when regex isn't available - crude  tissue identification 
Private Function SimplePatternMatch(ByVal text As String, ByVal pattern As  String, ByVal ignoreCase As Boolean) As Boolean 
On Error Resume Next 
Dim compareMethod As VbCompareMethod 
compareMethod = IIf(ignoreCase, vbTextCompare, vbBinaryCompare) 
' Handle basic anchors ^ (start) and $ (end) 
If Left(pattern, 1) = "^" Then 
pattern = Mid(pattern, 2) 
SimplePatternMatch = (StrComp(Left(text, Len(pattern)), pattern,  compareMethod) = 0) 
ElseIf Right(pattern, 1) = "$" Then 
pattern = Left(pattern, Len(pattern) - 1) 
SimplePatternMatch = (StrComp(Right(text, Len(pattern)), pattern,  compareMethod) = 0) 
Else 
SimplePatternMatch = (InStr(1, text, pattern, compareMethod) > 0) End If 
On Error GoTo 0 
End Function 
' Simple replace function for fallback - brutal tissue replacement Private Function SimpleReplace(ByVal text As String, ByVal pattern As String,  _ 
ByVal Replacement As String, ByVal ignoreCase As  
Boolean) As String 
On Error Resume Next 
Dim compareMethod As VbCompareMethod 
compareMethod = IIf(ignoreCase, vbTextCompare, vbBinaryCompare) 
' Use VBA's built-in Replace function 
SimpleReplace = Replace(text, pattern, Replacement, 1, -1, compareMethod) 
On Error GoTo 0 
End Function 
'===== UTILITY METHODS - SURGICAL ACCESSORIES ===== 
' Validate RegExp pattern - verify surgical template 
Public Function ValidatePattern(ByVal pattern As String) As Boolean On Error Resume Next 
' Initialize if needed 
If Not m_isInitialized Then InitializeRegExpEngine 
If Not m_usingFallback Then 
' Test pattern with VBScript.RegExp 
m_regExpEngine.pattern = pattern 
ValidatePattern = (Err.Number = 0) 
Else
' For custom engine, basic validation 
ValidatePattern = (Len(pattern) > 0) 
End If 
On Error GoTo 0 
End Function 
' Get RegExp engine information - surgical equipment inventory Public Function GetRegExpEngineInfo() As String 
On Error Resume Next 
If Not m_isInitialized Then InitializeRegExpEngine 
GetRegExpEngineInfo = "Vivisection Equipment: " & m_engineType &  vbNewLine & _ 
"Using Improvised Tools: " & IIf(m_usingFallback,  
"Yes (reduced precision)", "No (full surgical capability)") & vbNewLine & _ "Host Platform: " & gPlatformName 
On Error GoTo 0 
End Function 
' Process regular expression with error handling - supervised surgery Public Function SafeRegExReplace(ByVal text As String, ByVal pattern As  String, _ 
ByVal Replacement As String, _ 
Optional ByVal ignoreCase As Boolean = True, _ 
Optional ByVal GlobalReplace As Boolean =  
True) As String 
On Error Resume Next 
' Try to use RegExReplace - attempt precision surgery 
SafeRegExReplace = RegExReplace(text, pattern, Replacement, ignoreCase,  GlobalReplace) 
' Check for errors 
If Err.Number <> 0 Then 
Debug.Print "SafeRegExReplace error: " & Err.Number & " - " &  Err.description 
' Return original text on error 
SafeRegExReplace = text 
' Try to use ErrorHandler if available 
Application.Run "ErrorHandler.HandleError", "RegExpManager",  "SafeRegExReplace", _ 
Err.Number, Err.description 
End If 
On Error GoTo 0 
End Function 
' Extract text using regular expression - targeted tissue extraction Public Function RegExExtract(ByVal text As String, ByVal pattern As String, _
Optional ByVal ignoreCase As Boolean = True, _ 
Optional ByVal GroupIndex As Integer = 0) As String 
On Error Resume Next 
' Initialize if needed 
If Not m_isInitialized Then InitializeRegExpEngine 
' MAC OPTIMIZATION: Add size checks for very large inputs 
If Len(text) > 100000 And gIsMac Then 
' Simple extract for large text on Mac 
If InStr(1, text, pattern, IIf(ignoreCase, vbTextCompare,  vbBinaryCompare)) > 0 Then 
RegExExtract = pattern 
Else 
RegExExtract = "" 
End If 
Debug.Print "Using simplified extraction for large text on Mac" Exit Function 
End If 
If Not m_usingFallback Then 
' Use VBScript.RegExp - precision biopsy 
With m_regExpEngine 
.pattern = pattern 
.ignoreCase = ignoreCase 
.Global = False 
Dim matches As Object 
Set matches = .Execute(text) 
If matches.count > 0 Then 
If GroupIndex = 0 Then 
' Return the full match - entire tissue sample 
RegExExtract = matches(0).value 
ElseIf GroupIndex <= matches(0).SubMatches.count Then 
' Return the requested subgroup - specific tissue region 
RegExExtract = matches(0).SubMatches(GroupIndex - 1) 
Else 
RegExExtract = "" 
End If 
Else 
RegExExtract = "" 
End If 
End With 
Else 
' Fallback for custom engine - crude extraction 
Dim results As collection 
Set results = CustomFindAll(text, pattern, ignoreCase) 
If results.count > 0 Then 
RegExExtract = results(1) 
Else 
RegExExtract = "" 
End If
End If 
' Check for errors 
If Err.Number <> 0 Then 
Debug.Print "RegEx extract error: " & Err.Number & " - " &  Err.description 
RegExExtract = "" 
End If 
On Error GoTo 0 
End Function 
' Safe logging 
Private Sub LogMessage(message As String, Optional level As String = "INFO") On Error Resume Next 
' Use Debug.Print for safer logging 
Debug.Print format(Now, "yyyy-mm-dd hh:nn:ss") & " [" & level & "] " &  message 
On Error GoTo 0 
End Sub 
'============================================================================ = 
' END MODULE: RegExpManager 
'============================================================================ = 
‘********************************************************* 
‘‘***************** ‘coVdEeNcOoMde ‘******************     
‘********************************************************* 
'============================================================================ = 
' BEGIN MODULE: modRotatingStyles (Standard Module) 
'============================================================================ = 
'  
\============================================================================ = 
' Rotating Styles Module - Dynamic Visual Cycling 
' Version: 1.0 
' Rotational necrosis of your visual cortex, one color shift at a time. ' Updated by: Aaron McCutchins on 2025-05-05 
'  
\============================================================================ = 
Option Explicit 
' Module state - venom progression tracking
Private mCurrentStyleIndex As Long 
Private mCurrentPatternIndex As Long 
Private mCurrentThemeIndex As Long 
Private mCurrentQuoteIndex As Long 
Private mRotationTimerEnabled As Boolean 
Private mIsInitialized As Boolean 
' Collection of theme colors - the molecular structure of our toxins Private Type ThemeColors 
background As Long 
normalText As Long 
keywords As Long 
comments As Long 
strings As Long 
numbers As Long 
Dividers As Long 
End Type 
Private mThemes() As ThemeColors 
' Spinning patterns for real rotating visuals - hypnotizing the prey before  the strike 
Private mSpinningPatterns As collection 
' Initialize the rotating styles - prepare the visual neurotoxins Public Sub InitializeRotatingStyles() 
'If Not mIsInitialized Then InitializeRotatingStyles 
' Initialize indices 
mCurrentStyleIndex = 0 
mCurrentPatternIndex = 0 
mCurrentThemeIndex = 0 
mCurrentQuoteIndex = 0 
mRotationTimerEnabled = False 
' Initialize themes 
InitializeThemes 
' Initialize spinning patterns 
InitializeSpinningPatterns 
mIsInitialized = True 
' LogMessage "Rotating styles module initialized with " & UBound(mThemes)  + 1 & " neurotoxins and " & 
'mSpinningPatterns.count & " visual parasites ready for  
implantation" 
End Sub 
' Initialize theme collection - synthesize our neurotoxic compounds Private Sub InitializeThemes() 
ReDim mThemes(4) ' 5 themes 
' Theme 1: Dark Mode (Blue accent) - black widow venom 
With mThemes(0)
.background = &H0 ' Black 
.normalText = &HFFFF ' Yellow 
.keywords = &HFF0000 ' Blue 
.comments = &HFF00 ' Green 
.strings = &HC0C0FF ' Light Red 
.numbers = &HFFFFFF ' White 
.Dividers = &HFF0000 ' Blue 
End With 
' Theme 2: Synthwave (Pink/Purple accent) - cone snail's conotoxin With mThemes(1) 
.background = &H3F0A1E ' Deep Purple 
.normalText = &HFFFFFF ' White 
.keywords = &HFF00FF ' Magenta 
.comments = &HFFFF ' Yellow 
.strings = &H80B0FF ' Orange 
.numbers = &HC0FFFF ' Light Yellow 
.Dividers = &HFF80FF ' Light Magenta 
End With 
' Theme 3: Matrix (Green accent) - green mamba's dendrotoxin With mThemes(2) 
.background = &H0 ' Black 
.normalText = &HFF00 ' Bright Green 
.keywords = &HFFFF ' Yellow 
.comments = &H8000 ' Dark Green 
.strings = &HFFFF ' Yellow 
.numbers = &HFF00 ' Bright Green 
.Dividers = &HFF00 ' Bright Green 
End With 
' Theme 4: Sunset (Orange accent) - russell's viper hemotoxin 
With mThemes(3) 
.background = &H80 ' Dark Blue 
.normalText = &HFFFFFF ' White 
.keywords = &H80C0FF ' Orange 
.comments = &H8080FF ' Pink 
.strings = &HC0FFFF ' Light Yellow 
.numbers = &HFFFFFF ' White 
.Dividers = &H8080FF ' Pink 
End With 
' Theme 5: Monochrome (Gray accent) - king cobra's neurotoxic opus With mThemes(4) 
.background = &H0 ' Black 
.normalText = &HCCCCCC ' Light Gray 
.keywords = &HFFFFFF ' White 
.comments = &H808080 ' Gray 
.strings = &HEEEEEE ' Very Light Gray 
.numbers = &HFFFFFF ' White 
.Dividers = &HFFFFFF ' White 
End With 
End Sub
' Initialize spinning patterns - create visual patterns to induce seizures Private Sub InitializeSpinningPatterns() 
Set mSpinningPatterns = New collection 
' Spinner 1: Classic rotating line - the mesmerizing cobra Dim spinner1(3) As String 
spinner1(0) = "' | Liquefying tissue... |" 
spinner1(1) = "' / Dissolving organs... /" 
spinner1(2) = "' - Paralyzing nervous system... -" 
spinner1(3) = "' \ Necrotizing flesh... \" 
mSpinningPatterns.Add spinner1 
' Spinner 2: Dots - the slow drip of venom 
Dim spinner2(3) As String 
spinner2(0) = "' [ Injecting. ]" 
spinner2(1) = "' [ Injecting.. ]" 
spinner2(2) = "' [ Injecting... ]" 
spinner2(3) = "' [ Preparing next dose ]" 
mSpinningPatterns.Add spinner2 
' Spinner 3: Arrows - the spreading toxin 
Dim spinner3(7) As String 
spinner3(0) = "' >>------->> TOXIN SPREADING" 
spinner3(1) = "' ->>------>> ENTERING BLOODSTREAM" 
spinner3(2) = "' -->>----->> REACHING ORGANS" 
spinner3(3) = "' --->>---->> TISSUE CONTACT" 
spinner3(4) = "' ---->>--->> CELL PENETRATION" 
spinner3(5) = "' ----->>-->> NEURAL INTERFERENCE" 
spinner3(6) = "' ------>>->> BINDING TO RECEPTORS" 
spinner3(7) = "' ------->>> PARALYSIS COMPLETE" 
mSpinningPatterns.Add spinner3 
' Spinner 4: Box drawing - the containment cell 
Dim spinner4(3) As String 
spinner4(0) = "' ********" 
spinner4(1) = "' ********" 
spinner4(2) = "' ********" 
spinner4(3) = "' ********" 
mSpinningPatterns.Add spinner4 
' Spinner 5: ASCII fun - the torture sequence 
Dim spinner5(5) As String 
spinner5(0) = "' (*°*°)** *** DISMEMBERING CODE" 
spinner5(1) = "' *** *( º _ º) REASSEMBLING INCORRECTLY" spinner5(2) = "' (****)***** LIQUEFYING REMAINS" 
spinner5(3) = "' *** * \\(°*°)/ * *** TOTAL SYSTEM FAILURE" spinner5(4) = "' (*_*) * * CONTAMINATING ENVIRONMENT" 
spinner5(5) = "' (•_•) / ( •_•)>**-* / (**_*) ENJOYING THE SCREAMS" 
mSpinningPatterns.Add spinner5 
End Sub 
' Rotate to the next theme - change the venom composition Public Sub RotateTheme()
If Not mIsInitialized Then InitializeRotatingStyles 
' Increment theme index 
mCurrentThemeIndex = (mCurrentThemeIndex + 1) Mod (UBound(mThemes) + 1) 
' Apply the new theme 
ApplyCurrentTheme 
' Log rotation 
'LogMessage "Rotated to venom variant #" & (mCurrentThemeIndex + 1) & "  of " & (UBound(mThemes) + 1) & " - observe new symptoms" 
End Sub 
' Apply the current theme to the formatter - inject the selected neurotoxin Private Sub ApplyCurrentTheme() 
On Error Resume Next 
' Get current theme 
Dim currentTheme As ThemeColors 
currentTheme = mThemes(mCurrentThemeIndex) 
' ' Update the colors in the code formatter 
' If Not modCodeFormatter Is Nothing Then  
modCodeFormatter.InitializeCodeFormatter 
' ' Access the private variables using reflection 
' Since we can't directly access private variables, we'll use an  alternative approach 
' Store the theme in the config 
If gConfig Is Nothing Then 
Set gConfig = CreateObject("Scripting.Dictionary") 
End If 
' Store theme in config for the formatter to access 
gConfig("RotatingTheme_Background") = currentTheme.background gConfig("RotatingTheme_NormalText") = currentTheme.normalText gConfig("RotatingTheme_Keywords") = currentTheme.keywords 
gConfig("RotatingTheme_Comments") = currentTheme.comments 
gConfig("RotatingTheme_Strings") = currentTheme.strings 
gConfig("RotatingTheme_Numbers") = currentTheme.numbers 
gConfig("RotatingTheme_Dividers") = currentTheme.Dividers 
' Signal the formatter to refresh 
gConfig("ThemeUpdated") = True 
' End If 
On Error GoTo 0 
End Sub 
' Get a spinner frame - view the pulsating venom flow 
Public Function GetSpinnerFrame() As String 
If Not mIsInitialized Then InitializeRotatingStyles 
' Get current spinner collection
Dim spinnerIndex As Long 
spinnerIndex = mCurrentStyleIndex Mod mSpinningPatterns.count 
' Get the spinner array 
Dim spinnerArray As Variant 
spinnerArray = mSpinningPatterns(spinnerIndex + 1) 
' Get the current frame 
Dim frameIndex As Long 
frameIndex = mCurrentPatternIndex Mod UBound(spinnerArray) + 1 
' Update the pattern index for next time 
mCurrentPatternIndex = (mCurrentPatternIndex + 1) Mod  UBound(spinnerArray) + 1 
' Return the spinner frame 
GetSpinnerFrame = spinnerArray(frameIndex) 
End Function 
' Get next rotating divider - change the visual containment field Public Function GetRotatingDivider() As String 
If Not mIsInitialized Then InitializeRotatingStyles 
' Update pattern index 
mCurrentPatternIndex = (mCurrentPatternIndex + 1) Mod 8 
' Create rotating divider based on current pattern 
Dim divider As String 
Select Case mCurrentPatternIndex 
Case 0 
divider = String(65, "=") 
Case 1 
divider = "*******" & String(49, "*") & "*******" 
Case 2 
divider = "*" & String(63, "**") & "*" 
Case 3 
divider = "**" & String(64, "-") & "**" 
Case 4 
divider = "*" & String(32, "**") & "*" 
Case 5 
divider = "**" & String(63, "**") & "**" 
Case 6 
divider = "*" & String(63, "*") & "*" 
Case 7 
divider = "***" & String(59, " ") & "***" 
End Select 
' Return the divider with comment prefix 
GetRotatingDivider = "' " & divider 
End Function 
' Start automatic rotation timer - automate the neurotoxin delivery Public Sub StartRotationTimer()
If Not mIsInitialized Then InitializeRotatingStyles 
' Can't actually implement a timer in VBA without using  
Application.OnTime 
' which works differently in Word vs Excel 
' This is just a placeholder function 
mRotationTimerEnabled = True 
'LogMessage "Neurochemical rotation initiated - synapse degradation will  now progress automatically" 
End Sub 
' Stop automatic rotation timer - temporarily halt the suffering Public Sub StopRotationTimer() 
mRotationTimerEnabled = False 
LogMessage "Neurochemical cycling paused - victim granted momentary  relief" 
End Sub 
' Rotating snarky comment generator - toxic verbal assault 
Public Function GetRotatingSnarkyComment() As String 
If Not mIsInitialized Then InitializeRotatingStyles 
' Increment the quote index 
mCurrentQuoteIndex = (mCurrentQuoteIndex + 1) Mod 20 
' Extra super-snarky comments specifically for the rotating module - neurotoxic insults 
Dim rotatingComments(19) As String 
rotatingComments(0) = "This code rotates toxins faster than your liver  can process them." 
rotatingComments(1) = "Spinning styles - because your visual cortex  hasn't suffered enough yet." 
rotatingComments(2) = "Like a carousel of agony, forcing you to  experience every shade of pain." 
rotatingComments(3) = "Rotating colors won't mask the smell of your  code's putrefaction." 
rotatingComments(4) = "This module changes themes more often than your  dying cells can regenerate." 
rotatingComments(5) = "Adding 'dynamic theming' to your resume won't help  when you're paralyzed." 
rotatingComments(6) = "For when your code needs to look beautiful as it  slowly dies inside." 
rotatingComments(7) = "Making your code prettier as its internal organs  liquefy." 
rotatingComments(8) = "Like dressing a corpse for an open casket - purely  aesthetic." 
rotatingComments(9) = "Guaranteed to accelerate retinal necrosis in code  reviewers." 
rotatingComments(10) = "Now your bugs can experience multi-phase  suffering in technicolor." 
rotatingComments(11) = "The digital equivalent of a spinning torture rack  - mesmerizing yet excruciating."
rotatingComments(12) = "This module exists because pain in one color  wasn't enough." 
rotatingComments(13) = "More colors than your blood spatter pattern,  which is saying something." 
rotatingComments(14) = "When substance is insufficient, distract with  color as the venom spreads." 
rotatingComments(15) = "Like a disco in your retinas - blinding and  neurologically damaging." 
rotatingComments(16) = "More visually assaulting than fixing actual bugs,  and twice as toxic." 
rotatingComments(17) = "Making your VBA look stylish while its internal  organs fail." 
rotatingComments(18) = "When you have time to write rotating styles but  not to prevent the impending system collapse." 
rotatingComments(19) = "This module is like applying makeup while the  body beneath decomposes." 
' Return the rotating comment 
GetRotatingSnarkyComment = rotatingComments(mCurrentQuoteIndex) 
' Add emoji for Mac 
#If Mac Then 
GetRotatingSnarkyComment = GetRotatingSnarkyComment & " **" #End If 
End Function 
' Create a section divider with rotating style - a visually toxic barrier Public Function CreateRotatingSectionDivider(moduleName As String, Optional  versionInfo As String = "") As String 
If Not mIsInitialized Then InitializeRotatingStyles 
' Get rotating elements 
Dim topDivider As String 
Dim bottomDivider As String 
Dim snarkyComment As String 
topDivider = GetRotatingDivider() 
bottomDivider = GetRotatingDivider() 
snarkyComment = GetRotatingSnarkyComment() 
' Create timestamp and author info 
Dim timestamp As String 
timestamp = format(Now, "yyyy-mm-dd") 
Dim authorInfo As String 
authorInfo = "Aaron McCutchins" 
' Get version if not provided 
If versionInfo = "" Then 
versionInfo = "1.0" 
End If 
' Build section divider 
Dim divider As String 
divider = topDivider & vbCrLf & _
"' " & moduleName & vbCrLf & _ 
"' Version: " & versionInfo & vbCrLf & _ 
"' " & snarkyComment & vbCrLf & _ 
"' Updated by: " & authorInfo & " on " & timestamp & vbCrLf & _ bottomDivider & vbCrLf 
CreateRotatingSectionDivider = divider 
End Function 
' Demo the rotating styles - showcase the torture devices 
Public Sub DemoRotatingStyles() 
If Not mIsInitialized Then InitializeRotatingStyles 
' Clear the document 
ThisDocument.content.text = "" 
' Add a header 
ThisDocument.content.InsertAfter "VENOM VISUAL EFFECTS DEMONSTRATION" &  vbCrLf & vbCrLf 
' Demo spinning patterns 
ThisDocument.content.InsertAfter "Paralytic Visual Patterns:" & vbCrLf Dim i As Long, j As Long 
' Show each spinner 
For i = 1 To mSpinningPatterns.count 
' Get the spinner array 
Dim spinnerArray As Variant 
spinnerArray = mSpinningPatterns(i) 
' Show each frame 
For j = LBound(spinnerArray) To UBound(spinnerArray) 
ThisDocument.content.InsertAfter spinnerArray(j) & vbCrLf 
Next j 
ThisDocument.content.InsertAfter vbCrLf 
Next i 
' Demo themes 
ThisDocument.content.InsertAfter "Neurotoxic Color Schemes:" & vbCrLf 
' For each theme, show a sample 
For i = 0 To UBound(mThemes) 
ThisDocument.content.InsertAfter "Venom Variant " & (i + 1) & ":" &  vbCrLf 
' We can't actually show the colors in a document like this, ' so we'll just describe them 
With mThemes(i) 
ThisDocument.content.InsertAfter " Background: " & .background &  " - cell membrane penetration" & vbCrLf 
ThisDocument.content.InsertAfter " Normal Text: " & .normalText  & " - nerve fiber dissolution" & vbCrLf
ThisDocument.content.InsertAfter " Keywords: " & .keywords & " - synapse disruption" & vbCrLf 
ThisDocument.content.InsertAfter " Comments: " & .comments & " - myelin sheath degradation" & vbCrLf 
ThisDocument.content.InsertAfter " Strings: " & .strings & " - axon terminal paralysis" & vbCrLf 
ThisDocument.content.InsertAfter " Numbers: " & .numbers & " - neural pathway corruption" & vbCrLf 
End With 
ThisDocument.content.InsertAfter vbCrLf 
Next i 
' Demo dividers 
ThisDocument.content.InsertAfter "Toxic Barrier Patterns:" & vbCrLf 
' Reset the pattern index 
mCurrentPatternIndex = 0 
' Show each divider 
For i = 0 To 7 
ThisDocument.content.InsertAfter GetRotatingDivider() & vbCrLf Next i 
ThisDocument.content.InsertAfter vbCrLf 
' Demo snarky comments 
ThisDocument.content.InsertAfter "Neurologically Damaging Commentary:" &  vbCrLf 
' Reset the quote index 
mCurrentQuoteIndex = 0 
' Show several comments 
For i = 0 To 9 
ThisDocument.content.InsertAfter "' " & GetRotatingSnarkyComment() &  vbCrLf 
Next i 
ThisDocument.content.InsertAfter vbCrLf 
' Show a complete rotating section divider 
ThisDocument.content.InsertAfter "Complete Toxic Section Barrier:" &  vbCrLf & vbCrLf 
ThisDocument.content.InsertAfter CreateRotatingSectionDivider("Venom  Demonstration Module", "1.0") 
' Show completion message 
MsgBox "Venom visual effects demonstration complete! Your visual cortex  should now be experiencing the first symptoms of degradation.", _ vbInformation, "Demonstration Complete" 
End Sub 
' Apply a rainbow effect to text - the full spectrum of visual poison
Public Sub RainbowifyText() 
' This would require direct access to the document's font formatting ' which is complex to implement in a cross-platform way 
' This is just a placeholder function 
MsgBox "The multi-spectrum neural assault would be implemented here." &  vbCrLf & _ 
"This would require direct neural interface, which might be lethal  even by our standards.", _ 
vbInformation, "Advanced Torture Not Implemented" 
End Sub 
' Create wave pattern text - undulating visual toxin 
Public Function CreateWaveText(text As String) As String 
If Len(text) = 0 Then 
CreateWaveText = "" 
Exit Function 
End If 
Dim result As String 
Dim i As Long 
Dim wavePos As Long 
result = "' " 
wavePos = 0 
' Create a simple wave effect using spaces - rhythmic neurological  assault 
For i = 1 To Len(text) 
Dim char As String 
char = Mid(text, i, 1) 
' Calculate vertical position in the wave 
Dim vertPos As Long 
vertPos = wavePos Mod 4 
' Add appropriate spaces 
Select Case vertPos 
Case 0: result = result & char 
Case 1: result = result & " " & char 
Case 2: result = result & " " & char 
Case 3: result = result & " " & char 
End Select 
wavePos = wavePos + 1 
Next i 
CreateWaveText = result 
End Function 
'============================================================================ = 
' END MODULE: modRotatingStyles 
'============================================================================ =
‘********************************************************* 
‘‘***************** ‘coVdEeNcOoMde ‘******************     
‘********************************************************* 

'============================================================================ = 
' BEGIN MODULE: modSmartImport (Standard Module) 
'============================================================================ = 
'  
**************************************************************************** ' * SMART IMPORT SYSTEM  
(VENOMized) * 
' * Because copy-paste is for mortals, and we're something  more... * 
'  
* * ' * Version: 2.1 Enhanced with  
VENOM * 
' * Last Updated: 2025-05- 
13 * 
' * Author: Aaron  
McCutchins * 
'  
**************************************************************************** Option Explicit 
#If Mac Then 
' Mac-specific constants for performance 
Private Const MAC_PROCESS_TIMEOUT_MS As Long = 500 ' Timeout for  processing (milliseconds) 
Private Const MAC_CHUNK_SIZE As Long = 5000 ' Characters to process at  once 
Private mLastProcessTime As Double ' Last processing time for timeout  detection 
Private mIsMacProcessing As Boolean ' Flag to prevent reentrant  processing on Mac 
#End If 
' ********************* 
' * MODULE STATE VARS * 
' ********************* 
Private mIsInitialized As Boolean 
Private mConflicts As collection 
Private mImportOptions As Object ' Dictionary 
Private mLastImportStats As Object ' Dictionary 
Private mThemeKeysCollection As collection ' For Mac-compatibility
' ********************************************* 
' * INITIALIZATION AND CONFIGURATION MANAGEMENT * 
' ********************************************* 
' Initialize the module with stylish flair - unique name to avoid ambiguous  call 
Public Sub InitializeSmartImport() 
On Error GoTo ErrorHandler 
If mIsInitialized Then Exit Sub 
' Create fresh collections for our tools with cross-platform  compatibility 
Set mConflicts = New collection 
#If Mac Then 
' Reset Mac processing timer 
ResetMacProcessingTimer 
' Use Collection-based approach for Mac compatibility 
On Error Resume Next 
' Try Dictionary first 
Set mImportOptions = CreateObject("Scripting.Dictionary") 
Set mLastImportStats = CreateObject("Scripting.Dictionary") 
' If Dictionary fails, use Collection as fallback 
If Err.Number <> 0 Then 
Err.Clear 
Set mImportOptions = New collection 
Set mLastImportStats = New collection 
Set mThemeKeysCollection = New collection 
' Add keys for Collections 
mThemeKeysCollection.Add "CheckDuplicates" 
mThemeKeysCollection.Add "AutoRenameDuplicates" 
mThemeKeysCollection.Add "ImportComments" 
mThemeKeysCollection.Add "PreserveFormatting" 
mThemeKeysCollection.Add "MergeModules" 
mThemeKeysCollection.Add "EnhancedFormatting" 
mThemeKeysCollection.Add "ApplyVenomStyle" 
mThemeKeysCollection.Add "BackupBeforeImport" 
mThemeKeysCollection.Add "TotalImports" 
mThemeKeysCollection.Add "TotalConflicts" 
mThemeKeysCollection.Add "LastImportDate" 
End If 
On Error GoTo ErrorHandler 
#Else 
' Windows implementation 
Set mImportOptions = CreateObject("Scripting.Dictionary") 
Set mLastImportStats = CreateObject("Scripting.Dictionary") #End If 
' Set default import options with some enhanced defaults 
DictSet mImportOptions, "CheckDuplicates", True
DictSet mImportOptions, "AutoRenameDuplicates", False 
DictSet mImportOptions, "ImportComments", True 
DictSet mImportOptions, "PreserveFormatting", True 
DictSet mImportOptions, "MergeModules", True 
DictSet mImportOptions, "EnhancedFormatting", True ' VENOM: Add  formatting enhancement 
DictSet mImportOptions, "ApplyVenomStyle", True ' VENOM: Apply  stylistic elements 
DictSet mImportOptions, "BackupBeforeImport", True ' VENOM: Safety  first 
' Set initial stats 
DictSet mLastImportStats, "TotalImports", 0 
DictSet mLastImportStats, "TotalConflicts", 0 
DictSet mLastImportStats, "LastImportDate", "" 
mIsInitialized = True 
LogMessage "* VENOM Smart Import System initialized and ready to strike" 
#If Mac Then 
' Keep UI responsive on Mac 
DoEvents 
#End If 
Exit Sub 
ErrorHandler: 
LogMessage "ERROR initializing Smart Import: " & Err.description, "ERROR" ' Ensure we have at least basic initialization 
mIsInitialized = True 
End Sub 
#If Mac Then 
' Helper functions for Mac timeout detection 
Private Sub ResetMacProcessingTimer() 
mLastProcessTime = Timer 
End Sub 
Private Function MacProcessingTimedOut() As Boolean 
If Timer - mLastProcessTime > (MAC_PROCESS_TIMEOUT_MS / 1000) Then MacProcessingTimedOut = True 
Else 
MacProcessingTimedOut = False 
End If 
End Function 
#End If 
' Cross-platform dictionary compatibility layer 
Private Function DictExists(dict As Object, key As String) As Boolean On Error Resume Next 
DictExists = False 
If dict Is Nothing Then Exit Function
If typeName(dict) = "Dictionary" Then 
DictExists = dict.exists(key) 
ElseIf typeName(dict) = "Collection" Then 
' For Collection, we need a different approach 
Dim i As Long 
For i = 1 To mThemeKeysCollection.count 
If mThemeKeysCollection(i) = key Then 
DictExists = True 
Exit Function 
End If 
Next i 
End If 
On Error GoTo 0 
End Function 
Private Function DictGet(dict As Object, key As String) As Variant On Error Resume Next 
If typeName(dict) = "Dictionary" Then 
If dict.exists(key) Then 
If IsObject(dict(key)) Then 
Set DictGet = dict(key) 
Else 
DictGet = dict(key) 
End If 
End If 
ElseIf typeName(dict) = "Collection" Then 
' For Collection, use key index from theme keys collection Dim i As Long 
For i = 1 To mThemeKeysCollection.count 
If mThemeKeysCollection(i) = key Then 
' Found the key 
If i <= dict.count Then 
If IsObject(dict(i)) Then 
Set DictGet = dict(i) 
Else 
DictGet = dict(i) 
End If 
End If 
Exit Function 
End If 
Next i 
End If 
On Error GoTo 0 
End Function 
Private Sub DictSet(dict As Object, key As String, value As Variant) On Error Resume Next 
If typeName(dict) = "Dictionary" Then 
If IsObject(value) Then 
Set dict(key) = value
Else 
dict(key) = value 
End If 
ElseIf typeName(dict) = "Collection" Then 
' For Collection, use key index from theme keys collection Dim i As Long, keyIndex As Long 
keyIndex = 0 
For i = 1 To mThemeKeysCollection.count 
If mThemeKeysCollection(i) = key Then 
keyIndex = i 
Exit For 
End If 
Next i 
If keyIndex > 0 Then 
' Key exists, update the value 
On Error Resume Next 
' Remove existing item if present 
If keyIndex <= dict.count Then 
dict.Remove keyIndex 
End If 
' Add the new value at the appropriate position 
If keyIndex > dict.count Then 
' Add at the end 
dict.Add value 
Else 
' Add at the specific position 
dict.Add value, , keyIndex 
End If 
On Error GoTo 0 
Else 
' Key doesn't exist yet, add it 
mThemeKeysCollection.Add key 
dict.Add value 
End If 
End If 
On Error GoTo 0 
End Sub 
' ************************ 
' * SMART IMPORT CORE ENGINE * 
' ************************ 
' Intelligently import code from external file with VENOM enhancements Public Sub SmartImportCode(filePath As String) 
On Error GoTo ErrorHandler 
If Not mIsInitialized Then InitializeSmartImport
#If Mac Then 
' Prevent reentrant processing on Mac 
If mIsMacProcessing Then Exit Sub 
mIsMacProcessing = True 
ResetMacProcessingTimer 
#End If 
' Create backup before import if option enabled 
If DictGet(mImportOptions, "BackupBeforeImport") Then 
Dim backupPath As String 
backupPath = CreateBackupBeforeImport() 
If backupPath <> "" Then 
LogMessage "Created pre-import backup at: " & backupPath 
End If 
End If 
' Show status with enhanced visuals 
On Error Resume Next 
#If Mac Then 
Application.Run "DynamicUserFormManager.ShowStatusMessage", "**  Reading external code file...", True 
#Else 
DynamicUserFormManager.ShowStatusMessage "** Reading external code  file...", True 
#End If 
On Error GoTo ErrorHandler 
' Read the file with platform-specific approach 
Dim externalCode As String 
#If Mac Then 
' Use platform-safe function for Mac 
On Error Resume Next 
externalCode = Application.Run("ReadTextFile", filePath) 
If Err.Number <> 0 Then 
Err.Clear 
' Direct fallback approach 
externalCode = ReadTextFile(filePath) 
End If 
On Error GoTo ErrorHandler 
' Keep UI responsive 
DoEvents 
#Else 
' Windows implementation 
externalCode = ReadTextFile(filePath) 
#End If 
' Apply VENOM style enhancements if option enabled 
If DictGet(mImportOptions, "ApplyVenomStyle") Then 
#If Mac Then 
' For Mac, process in chunks to avoid freezing 
externalCode = ApplyVenomStylingMac(externalCode)
#Else 
' Windows can process all at once 
externalCode = ApplyVenomStyling(externalCode) 
#End If 
End If 
' Show analysis status 
On Error Resume Next 
#If Mac Then 
Application.Run "DynamicUserFormManager.ShowStatusMessage", "**  Analyzing code for import...", True 
#Else 
DynamicUserFormManager.ShowStatusMessage "** Analyzing code for  import...", True 
#End If 
On Error GoTo ErrorHandler 
' Analyze import with advanced metrics 
Dim analysisResult As Object 
#If Mac Then 
' Mac implementation with timeout protection 
Set analysisResult = AnalyzeImportMac(externalCode) 
' Keep UI responsive 
DoEvents 
#Else 
' Windows implementation 
Set analysisResult = AnalyzeImport(externalCode) 
#End If 
' Check for conflicts 
Set mConflicts = analysisResult("Conflicts") 
If mConflicts.count > 0 Then 
' Show conflict resolution UI with enhanced interaction 
On Error Resume Next 
#If Mac Then 
Application.Run "DynamicUserFormManager.ShowStatusMessage", "**  Resolving import conflicts...", True 
#Else 
DynamicUserFormManager.ShowStatusMessage "** Resolving import  conflicts...", True 
#End If 
On Error GoTo ErrorHandler 
#If Mac Then 
' Mac implementation with timeout protection 
ResolveImportConflictsMac 
#Else 
' Windows implementation 
ResolveImportConflicts 
#End If 
End If
' Show import status 
On Error Resume Next 
#If Mac Then 
Application.Run "DynamicUserFormManager.ShowStatusMessage", "**  Importing code with VENOM precision...", True 
#Else 
DynamicUserFormManager.ShowStatusMessage "** Importing code with  VENOM precision...", True 
#End If 
On Error GoTo ErrorHandler 
' Import the code 
#If Mac Then 
' Mac implementation with timeout protection 
MergeCodeIntoDocumentMac externalCode, analysisResult 
#Else 
' Windows implementation 
MergeCodeIntoDocument externalCode, analysisResult 
#End If 
' Update stats 
DictSet mLastImportStats, "TotalImports", DictGet(mLastImportStats,  "TotalImports") + 1 
DictSet mLastImportStats, "TotalConflicts", DictGet(mLastImportStats,  "TotalConflicts") + mConflicts.count 
DictSet mLastImportStats, "LastImportDate", format(Now, "yyyy-mm-dd  hh:mm:ss") 
' Final status with enhanced UI 
On Error Resume Next 
#If Mac Then 
Application.Run "DynamicUserFormManager.ShowStatusMessage", "", False #Else 
DynamicUserFormManager.ShowStatusMessage "", False 
#End If 
On Error GoTo ErrorHandler 
' Show completion message 
Dim completionMessage As String 
completionMessage = "* Code successfully imported with VENOM  enhancements:" & vbCrLf & vbCrLf & _ 
"** Source: " & filePath & vbCrLf & vbCrLf & _ 
"** IMPORT METRICS:" & vbCrLf & _ 
"** Modules: " & analysisResult("ModuleCount") &  
vbCrLf & _ 
"** Procedures: " & analysisResult("ProcedureCount")  
& vbCrLf & _ 
"** Resolved conflicts: " & mConflicts.count & vbCrLf  
& _ 
"** Lines processed: " & analysisResult("LineCount") 
On Error Resume Next 
#If Mac Then
Application.Run "DynamicUserFormManager.ShowMessage",  
completionMessage, "* VENOM Import Complete", vbInformation #Else 
DynamicUserFormManager.ShowMessage completionMessage, "* VENOM Import  Complete", vbInformation 
#End If 
#If Mac Then 
' Clear processing flag 
mIsMacProcessing = False 
#End If 
Exit Sub 
ErrorHandler: 
On Error Resume Next 
#If Mac Then 
mIsMacProcessing = False 
Application.Run "DynamicUserFormManager.ShowStatusMessage", "", False Application.Run "ErrorHandler.HandleError", "SmartImport",  "SmartImportCode", Err.Number, Err.description 
Application.Run "DynamicUserFormManager.ShowMessage", "** Failed to  import code: " & Err.description, "Import Error", vbExclamation #Else 
DynamicUserFormManager.ShowStatusMessage "", False 
ErrorHandler.HandleError "SmartImport", "SmartImportCode",  Err.Number, Err.description 
DynamicUserFormManager.ShowMessage "** Failed to import code: " &  Err.description, "Import Error", vbExclamation 
#End If 
End Sub 
' ********************** 
' * CODE ANALYSIS ROUTINES * 
' ********************** 
' Analyze import code for conflicts and structure with enhanced metrics Private Function AnalyzeImport(externalCode As String) As Object On Error GoTo ErrorHandler 
' Create result object 
Dim result As Object 
Set result = CreateObject("Scripting.Dictionary") 
' Get structure of external code 
Dim externalInfo As Object 
On Error Resume Next 
#If Mac Then 
' Use Application.Run for safer cross-module calls on Mac 
Set externalInfo =  
Application.Run("CodeAnalysis.AnalyzeCodeStructure", externalCode) #Else 
Set externalInfo = codeanalysis.AnalyzeCodeStructure(externalCode)
#End If 
If Err.Number <> 0 Or externalInfo Is Nothing Then 
' Fallback to simple analysis if CodeAnalysis module fails Set externalInfo = CreateSimpleCodeAnalysis(externalCode) End If 
On Error GoTo ErrorHandler 
' Store basic info with additional metrics 
result("ModuleCount") = externalInfo("ModuleCount") 
result("ProcedureCount") = externalInfo("ProcedureCount") 
' VENOM enhancement - count lines of code 
Dim codeLines As Variant 
codeLines = Split(externalCode, vbCrLf) 
result("LineCount") = UBound(codeLines) + 1 
' Get structure of current document 
Dim docCode As String 
docCode = GetDocumentText() 
Dim docInfo As Object 
On Error Resume Next 
#If Mac Then 
' Use Application.Run for safer cross-module calls on Mac Set docInfo = Application.Run("CodeAnalysis.AnalyzeCodeStructure",  docCode) 
#Else 
Set docInfo = codeanalysis.AnalyzeCodeStructure(docCode) 
#End If 
If Err.Number <> 0 Or docInfo Is Nothing Then 
' Fallback to simple analysis if CodeAnalysis module fails Set docInfo = CreateSimpleCodeAnalysis(docCode) 
End If 
On Error GoTo ErrorHandler 
' Find conflicts 
Dim conflicts As New collection 
' Check module name conflicts 
Dim i As Long, j As Long 
Dim externalModules As collection 
Dim docModules As collection 
Set externalModules = externalInfo("Modules") 
Set docModules = docInfo("Modules") 
For i = 1 To externalModules.count 
Dim exModule As Object 
Set exModule = externalModules(i) 
' Check for duplicate module names
For j = 1 To docModules.count 
Dim docModule As Object 
Set docModule = docModules(j) 
If LCase(exModule("Name")) = LCase(docModule("Name")) Then ' Module name conflict 
Dim conflictInfo As Object 
Set conflictInfo = CreateObject("Scripting.Dictionary") 
conflictInfo("Type") = "Module" 
conflictInfo("Name") = exModule("Name") 
conflictInfo("ExternalModule") = exModule 
conflictInfo("DocumentModule") = docModule 
conflictInfo("Resolution") = "Undecided" 
' VENOM enhancement - calculate similarity score 
conflictInfo("SimilarityScore") =  
CalculateSimilarityScore(exModule, docModule) 
conflicts.Add conflictInfo 
Exit For 
End If 
Next j 
Next i 
' Check procedure name conflicts 
Dim exProcedures As collection 
Dim docProcedures As collection 
Set exProcedures = externalInfo("Procedures") 
Set docProcedures = docInfo("Procedures") 
For i = 1 To exProcedures.count 
Dim exProc As Object 
Set exProc = exProcedures(i) 
' Check for duplicate procedure names 
For j = 1 To docProcedures.count 
Dim docProc As Object 
Set docProc = docProcedures(j) 
If LCase(exProc("Name")) = LCase(docProc("Name")) Then ' Procedure name conflict 
Set conflictInfo = CreateObject("Scripting.Dictionary") 
conflictInfo("Type") = "Procedure" 
conflictInfo("Name") = exProc("Name") 
conflictInfo("ExternalProcedure") = exProc 
conflictInfo("DocumentProcedure") = docProc 
conflictInfo("Resolution") = "Undecided" 
' VENOM enhancement - assess procedure complexity 
conflictInfo("Complexity") =  
AssessProcedureComplexity(exProc, docProc)
conflicts.Add conflictInfo 
End If 
Next j 
Next i 
' Store conflicts and code info 
result("Conflicts") = conflicts 
result("ExternalInfo") = externalInfo 
result("DocumentInfo") = docInfo 
Set AnalyzeImport = result 
Exit Function 
ErrorHandler: 
' Create a minimal result object on error 
If result Is Nothing Then Set result =  
CreateObject("Scripting.Dictionary") 
If Not result.exists("ModuleCount") Then result("ModuleCount") = 0 
If Not result.exists("ProcedureCount") Then result("ProcedureCount") = 0 If Not result.exists("LineCount") Then result("LineCount") = 0 
If Not result.exists("Conflicts") Then 
Set conflicts = New collection 
result("Conflicts") = conflicts 
End If 
' Create minimal info objects 
If Not result.exists("ExternalInfo") Then 
Set externalInfo = CreateObject("Scripting.Dictionary") 
externalInfo("ModuleCount") = 0 
externalInfo("ProcedureCount") = 0 
Set externalModules = New collection 
externalInfo("Modules") = externalModules 
Set exProcedures = New collection 
externalInfo("Procedures") = exProcedures 
result("ExternalInfo") = externalInfo 
End If 
If Not result.exists("DocumentInfo") Then 
Set docInfo = CreateObject("Scripting.Dictionary") 
docInfo("ModuleCount") = 0 
docInfo("ProcedureCount") = 0 
Set docModules = New collection 
docInfo("Modules") = docModules 
Set docProcedures = New collection 
docInfo("Procedures") = docProcedures 
result("DocumentInfo") = docInfo 
End If 
LogMessage "Error in AnalyzeImport: " & Err.description, "ERROR"
Set AnalyzeImport = result 
End Function 
' Mac-optimized version of AnalyzeImport with chunking and timeout protection #If Mac Then 
Private Function AnalyzeImportMac(externalCode As String) As Object ' This is a wrapper around AnalyzeImport that adds Mac-specific  optimizations 
' The actual implementation would be similar to AnalyzeImport but  with 
' additional DoEvents and timeout checks 
' Reset timeout timer 
ResetMacProcessingTimer 
' Call the main function 
Set AnalyzeImportMac = AnalyzeImport(externalCode) 
' Keep UI responsive 
DoEvents 
End Function 
#End If 
Private Function CreateSimpleCodeAnalysis(code As String) As Object On Error Resume Next 
Dim result As Object 
Set result = CreateObject("Scripting.Dictionary") 
' Basic counts 
Dim lines As Variant 
lines = Split(code, vbCrLf) 
result("LineCount") = UBound(lines) + 1 
' Analyze code structure 
Dim ModuleCount As Integer: ModuleCount = 0 
Dim procCount As Integer: procCount = 0 
Dim currentModuleName As String: currentModuleName = "Unknown" Dim inModule As Boolean: inModule = False 
Dim moduleStartLine As Long: moduleStartLine = -1 
Dim moduleEndLine As Long: moduleEndLine = -1 
' Collections for modules and procedures 
Dim modules As New collection 
Dim procedures As New collection 
' Current procedure tracking 
Dim currentProcName As String 
Dim currentProcType As String 
Dim procStartLine As Long 
Dim inProc As Boolean: inProc = False 
' Variables for pattern matching 
Dim attrMatch As Boolean
Dim subMatch As Boolean 
Dim funcMatch As Boolean 
Dim endMatch As Boolean 
Dim i As Long 
' Process line by line for better structure analysis 
For i = 0 To UBound(lines) 
Dim currentLine As String 
currentLine = Trim(lines(i)) 
' Look for module attribute lines 
attrMatch = (InStr(1, currentLine, "Attribute VB_Name = """) > 0) If attrMatch Then 
' Extract module name 
Dim startPos As Long, endPos As Long 
startPos = InStr(1, currentLine, """") + 1 
endPos = InStr(startPos, currentLine, """") 
If startPos > 0 And endPos > startPos Then 
' Found new module 
If inModule And moduleStartLine >= 0 Then 
' End previous module 
moduleEndLine = i - 1 
' Add module to collection 
Dim moduleInfo As Object 
Set moduleInfo = CreateObject("Scripting.Dictionary") 
moduleInfo("Name") = currentModuleName 
moduleInfo("LineStart") = moduleStartLine 
moduleInfo("LineEnd") = moduleEndLine 
moduleInfo("Type") = "Standard" ' Default assumption 
moduleInfo("Procedures") = New collection 
modules.Add moduleInfo 
End If 
' Start new module 
currentModuleName = Mid(currentLine, startPos, endPos - 
startPos) 
moduleStartLine = i 
inModule = True 
ModuleCount = ModuleCount + 1 
End If 
End If 
' Check for procedure start 
subMatch = (Left(currentLine, 4) = "Sub " Or InStr(1, currentLine, "  Sub ") > 0) 
funcMatch = (Left(currentLine, 9) = "Function " Or InStr(1,  currentLine, " Function ") > 0) 
Dim propMatch As Boolean 
propMatch = (Left(currentLine, 9) = "Property " Or InStr(1,  currentLine, " Property ") > 0)
If (subMatch Or funcMatch Or propMatch) And Not inProc Then ' Extract procedure name 
Dim procNameStart As Long, procNameEnd As Long 
Dim procTypeName As String 
If subMatch Then 
procTypeName = "Sub" 
procNameStart = InStr(1, currentLine, "Sub ") + 4 
ElseIf funcMatch Then 
procTypeName = "Function" 
procNameStart = InStr(1, currentLine, "Function ") + 9 
Else 
procTypeName = "Property" 
procNameStart = InStr(1, currentLine, "Property ") + 9 
End If 
procNameEnd = InStr(procNameStart, currentLine, "(") 
If procNameEnd = 0 Then procNameEnd = Len(currentLine) + 1 
currentProcName = Trim(Mid(currentLine, procNameStart,  procNameEnd - procNameStart)) 
currentProcType = procTypeName 
procStartLine = i 
inProc = True 
procCount = procCount + 1 
End If 
' Check for procedure end 
endMatch = (InStr(1, LCase(currentLine), "end sub") > 0 Or _ InStr(1, LCase(currentLine), "end function") > 0 Or _ 
InStr(1, LCase(currentLine), "end property") > 0) 
If endMatch And inProc Then 
' Add procedure to collection 
Dim procInfo As Object 
Set procInfo = CreateObject("Scripting.Dictionary") 
procInfo("Name") = currentProcName 
procInfo("Type") = currentProcType 
procInfo("LineStart") = procStartLine 
procInfo("LineEnd") = i 
If inModule Then 
procInfo("Module") = currentModuleName 
Else 
procInfo("Module") = "Unknown" 
End If 
procedures.Add procInfo 
' Add to module's procedure collection if available 
If inModule And modules.count > 0 Then 
On Error Resume Next 
Dim lastModule As Object 
Set lastModule = modules(modules.count)
If lastModule("Name") = currentModuleName Then 
lastModule("Procedures").Add procInfo 
End If 
On Error GoTo 0 
End If 
inProc = False 
End If 
#If Mac Then 
' Check for timeout in large documents 
If i Mod 1000 = 0 Then DoEvents 
#End If 
Next i 
' Close any open module 
If inModule And moduleStartLine >= 0 Then 
moduleEndLine = UBound(lines) 
' Add final module to collection 
Set moduleInfo = CreateObject("Scripting.Dictionary") moduleInfo("Name") = currentModuleName 
moduleInfo("LineStart") = moduleStartLine 
moduleInfo("LineEnd") = moduleEndLine 
moduleInfo("Type") = "Standard" ' Default assumption moduleInfo("Procedures") = New collection 
modules.Add moduleInfo 
End If 
' Add to result 
result("ModuleCount") = ModuleCount 
result("ProcedureCount") = procCount 
result("Modules") = modules 
result("Procedures") = procedures 
' Add extra VBA code structure metrics 
result("LinesOfCode") = CountCodeLines(lines) 
result("CommentLines") = CountCommentLines(lines) result("BlankLines") = CountBlankLines(lines) 
Set CreateSimpleCodeAnalysis = result 
On Error GoTo 0 
End Function 
' Helper function to count actual code lines 
Private Function CountCodeLines(lines As Variant) As Long Dim count As Long, i As Long 
For i = 0 To UBound(lines) 
Dim line As String 
line = Trim(lines(i))
' Count only non-blank, non-comment lines 
If Len(line) > 0 And Left(line, 1) <> "'" Then 
count = count + 1 
End If 
Next i 
CountCodeLines = count 
End Function 
' Helper function to count comment lines 
Private Function CountCommentLines(lines As Variant) As Long Dim count As Long, i As Long 
For i = 0 To UBound(lines) 
Dim line As String 
line = Trim(lines(i)) 
' Count only comment lines 
If Len(line) > 0 And Left(line, 1) = "'" Then 
count = count + 1 
End If 
Next i 
CountCommentLines = count 
End Function 
' Helper function to count blank lines 
Private Function CountBlankLines(lines As Variant) As Long Dim count As Long, i As Long 
For i = 0 To UBound(lines) 
Dim line As String 
line = Trim(lines(i)) 
' Count only blank lines 
If Len(line) = 0 Then 
count = count + 1 
End If 
Next i 
CountBlankLines = count 
End Function 
' Count procedures in code - simple implementation Private Function CountProcedures(code As String) As Long On Error Resume Next 
Dim count As Long 
Dim lines As Variant 
Dim i As Long 
lines = Split(code, vbCrLf)
count = 0 
For i = 0 To UBound(lines) 
Dim line As String 
line = Trim(lines(i)) 
' Check for procedure starts 
If Left(line, 4) = "Sub " Or Left(line, 9) = "Function " Or  Left(line, 9) = "Property " Then 
count = count + 1 
End If 
Next i 
CountProcedures = count 
On Error GoTo 0 
End Function 
' *********************** 
' * CONFLICT RESOLUTION LOGIC * 
' *********************** 
' Resolve import conflicts with enhanced user interaction Private Sub ResolveImportConflicts() 
On Error GoTo ErrorHandler 
If mConflicts.count = 0 Then Exit Sub 
' Auto-resolve if option is set 
If DictGet(mImportOptions, "AutoRenameDuplicates") Then AutoResolveConflicts 
Exit Sub 
End If 
' Ask user to resolve each conflict 
Dim i As Long 
Dim conflictInfo As Object 
For i = 1 To mConflicts.count 
Set conflictInfo = mConflicts(i) 
Dim conflictType As String 
Dim conflictName As String 
conflictType = conflictInfo("Type") 
conflictName = conflictInfo("Name") 
' VENOM enhancement - add visual indicators for conflict severity Dim severityIndicator As String 
severityIndicator = GetConflictSeverityIndicator(conflictInfo) 
' Build message for conflict resolution with rich formatting Dim message As String
message = "** VENOM CONFLICT DETECTED: " & severityIndicator & " " &  _ 
conflictType & " '" & conflictName & "' already exists." &  vbCrLf & vbCrLf 
If conflictType = "Module" Then 
message = message & "** Module in document: Contains " & _ 
conflictInfo("DocumentModule")("Procedures").count & "  
procedures" & vbCrLf 
message = message & "** Module in import: Contains " & _ 
conflictInfo("ExternalModule")("Procedures").count & "  
procedures" & vbCrLf 
' Add similarity score if available 
If DictExists(conflictInfo, "SimilarityScore") Then 
message = message & "** Similarity: " &  
conflictInfo("SimilarityScore") & "%" & vbCrLf 
End If 
Else 
message = message & "** Procedure in document: From module '" & _ conflictInfo("DocumentProcedure")("Module") & "'" &  
vbCrLf 
message = message & "** Procedure in import: From module '" & _ conflictInfo("ExternalProcedure")("Module") & "'" &  
vbCrLf 
' Add complexity info if available 
If DictExists(conflictInfo, "Complexity") Then 
message = message & "** Complexity delta: " &  
conflictInfo("Complexity") & vbCrLf 
End If 
End If 
message = message & vbCrLf & "How would you like VENOM to resolve  this conflict*" 
' Show options with enhanced formatting 
Dim options As String 
options = "1** Keep existing" & vbCrLf & _ 
"2** Replace with imported version" & vbCrLf & _ 
"3** Rename imported version" & vbCrLf & _ 
"4** Merge with VENOM intelligence" & vbCrLf & _ 
"5** Apply to all remaining conflicts" 
Dim choice As String 
On Error Resume Next 
#If Mac Then 
choice = Application.Run("DynamicUserFormManager.GetTextInput",  message & vbCrLf & vbCrLf & options, _ 
"** VENOM Import Conflict (" & i & " of "  
& mConflicts.count & ")", "1") 
#Else 
choice = DynamicUserFormManager.GetTextInput(message & vbCrLf &  vbCrLf & options, _
"** VENOM Import Conflict (" & i & " of "  
& mConflicts.count & ")", "1") 
#End If 
If Err.Number <> 0 Then 
choice = "1" ' Default to keeping existing on error 
End If 
On Error GoTo ErrorHandler 
' Process choice with enhanced feedback 
If IsNumeric(choice) Then 
Dim choiceNum As Long 
choiceNum = CLng(choice) 
Select Case choiceNum 
Case 1 ' Keep existing 
conflictInfo("Resolution") = "KeepExisting" 
LogMessage "Conflict resolution for " & conflictType & "  
'" & conflictName & "': Keeping existing version" 
Case 2 ' Replace with imported 
conflictInfo("Resolution") = "ReplaceWithImported" 
LogMessage "Conflict resolution for " & conflictType & "  
'" & conflictName & "': Replacing with imported version" 
Case 3 ' Rename imported 
Dim newName As String 
On Error Resume Next 
#If Mac Then 
newName =  
Application.Run("DynamicUserFormManager.GetTextInput", "Enter new name for  imported " & LCase(conflictType) & ":", _ 
"Rename " & conflictType,  
conflictName & "_VENOM") 
#Else 
newName = DynamicUserFormManager.GetTextInput("Enter  
new name for imported " & LCase(conflictType) & ":", _ 
"Rename " & conflictType,  
conflictName & "_VENOM") 
#End If 
If Err.Number <> 0 Then 
newName = conflictName & "_VENOM" ' Default name on  
error 
End If 
On Error GoTo ErrorHandler 
If Trim(newName) <> "" Then 
conflictInfo("Resolution") = "Rename" 
conflictInfo("NewName") = newName 
LogMessage "Conflict resolution for " & conflictType  
& " '" & conflictName & "': Renamed to '" & newName & "'" 
Else
conflictInfo("Resolution") = "KeepExisting" 
LogMessage "Conflict resolution for " & conflictType  
& " '" & conflictName & "': Keeping existing (rename canceled)" End If 
Case 4 ' Merge 
If conflictType = "Module" Then 
conflictInfo("Resolution") = "MergeModules" 
LogMessage "Conflict resolution for module '" &  
conflictName & "': Merging with VENOM intelligence" 
Else 
On Error Resume Next 
#If Mac Then 
Application.Run  
"DynamicUserFormManager.ShowMessage", "** VENOM cannot merge individual  procedures yet. " & _ 
"The existing procedure will be  
kept.", "Cannot Merge Procedures", vbInformation 
#Else 
DynamicUserFormManager.ShowMessage "** VENOM  
cannot merge individual procedures yet. " & _ 
"The existing procedure will be  
kept.", "Cannot Merge Procedures", vbInformation 
#End If 
On Error GoTo ErrorHandler 
conflictInfo("Resolution") = "KeepExisting" 
LogMessage "Conflict resolution for procedure '" &  
conflictName & "': Keeping existing (merge not supported)" 
End If 
Case 5 ' Apply to all remaining 
Dim applyChoice As String 
On Error Resume Next 
#If Mac Then 
applyChoice =  
Application.Run("DynamicUserFormManager.GetTextInput", _ 
"Which resolution do you  
want VENOM to apply to all remaining conflicts*" & _ 
vbCrLf & vbCrLf & _ 
"1** Keep existing" &  
vbCrLf & _ 
"2** Replace with  
imported version" & vbCrLf & _ 
"3** Rename imported  
version", _ 
"* Apply to All", "1") 
#Else 
applyChoice =  
DynamicUserFormManager.GetTextInput("Which resolution do you want VENOM to  apply to all remaining conflicts*" & _ 
vbCrLf & vbCrLf & _
"1** Keep existing" &  
vbCrLf & _ 
"2** Replace with imported  
version" & vbCrLf & _ 
"3** Rename imported  
version", _ 
"* Apply to All", "1") 
#End If 
If Err.Number <> 0 Then 
applyChoice = "1" ' Default to keeping existing on  
error 
End If 
On Error GoTo ErrorHandler 
If IsNumeric(applyChoice) Then 
Dim applyNum As Long 
applyNum = CLng(applyChoice) 
Dim resolution As String 
Select Case applyNum 
Case 1 
resolution = "KeepExisting" 
Case 2 
resolution = "ReplaceWithImported" 
Case 3 
resolution = "Rename" 
Case Else 
resolution = "KeepExisting" 
End Select 
' Apply to current conflict 
conflictInfo("Resolution") = resolution 
' If renaming, get name pattern 
Dim namePattern As String 
If resolution = "Rename" Then 
On Error Resume Next 
#If Mac Then 
namePattern =  
Application.Run("DynamicUserFormManager.GetTextInput", _ 
"Enter name  
pattern for renaming." & vbCrLf & _ 
"Use [Name] to  
include the original name.", _ 
"* VENOM Rename  
Pattern", "[Name]_VENOM") 
#Else 
namePattern =  
DynamicUserFormManager.GetTextInput("Enter name pattern for renaming." &  vbCrLf & _ 
"Use [Name] to  
include the original name.", _
"* VENOM Rename  
Pattern", "[Name]_VENOM") 
#End If 
If Err.Number <> 0 Then 
namePattern = "[Name]_VENOM" ' Default  
pattern on error 
End If 
On Error GoTo ErrorHandler 
If Trim(namePattern) = "" Then 
namePattern = "[Name]_VENOM" 
End If 
conflictInfo("NewName") = Replace(namePattern,  
"[Name]", conflictName) 
End If 
' Apply to all remaining conflicts 
Dim j As Long 
For j = i + 1 To mConflicts.count 
Dim remainingConflict As Object 
Set remainingConflict = mConflicts(j) 
remainingConflict("Resolution") = resolution 
If resolution = "Rename" Then 
Dim originalName As String 
originalName = remainingConflict("Name") 
remainingConflict("NewName") =  
Replace(namePattern, "[Name]", originalName) 
End If 
Next j 
LogMessage "Applied " & resolution & " resolution to  
all remaining conflicts" 
' Exit loop 
Exit For 
End If 
Case Else ' Default 
conflictInfo("Resolution") = "KeepExisting" 
LogMessage "Conflict resolution for " & conflictType & "  
'" & conflictName & "': Keeping existing (default)" 
End Select 
Else 
' Default if not a number 
conflictInfo("Resolution") = "KeepExisting" 
LogMessage "Conflict resolution for " & conflictType & " '" &  conflictName & "': Keeping existing (invalid choice)" 
End If 
Next i
Exit Sub 
ErrorHandler: 
LogMessage "Error in ResolveImportConflicts: " & Err.description, "ERROR" ' Default resolution for all remaining conflicts 
For i = 1 To mConflicts.count 
Set conflictInfo = mConflicts(i) 
If conflictInfo("Resolution") = "Undecided" Then 
conflictInfo("Resolution") = "KeepExisting" 
End If 
Next i 
End Sub 
' Mac-optimized version of ResolveImportConflicts with timeout protection #If Mac Then 
Private Sub ResolveImportConflictsMac() 
' Reset timeout timer 
ResetMacProcessingTimer 
' Call the main function 
ResolveImportConflicts 
' Keep UI responsive 
DoEvents 
End Sub 
#End If 
' Auto-resolve conflicts by renaming imported items with VENOM styling Private Sub AutoResolveConflicts() 
On Error GoTo ErrorHandler 
Dim i As Long 
For i = 1 To mConflicts.count 
Dim conflictInfo As Object 
Set conflictInfo = mConflicts(i) 
' Set resolution to rename 
conflictInfo("Resolution") = "Rename" 
' Generate new name with VENOM branding 
Dim originalName As String 
originalName = conflictInfo("Name") 
conflictInfo("NewName") = originalName & "_VENOM" 
LogMessage "Auto-resolved conflict for " & conflictInfo("Type") & "  '" & originalName & "'" 
#If Mac Then 
' Keep UI responsive in batches 
If i Mod 5 = 0 Then DoEvents 
#End If 
Next i
Exit Sub 
ErrorHandler: 
LogMessage "Error in AutoResolveConflicts: " & Err.description, "ERROR" End Sub 
' ********************* 
' * CODE INTEGRATION CORE * 
' ********************* 
' Merge code into document with VENOM precision 
Private Sub MergeCodeIntoDocument(externalCode As String, analysisResult As  Object) 
On Error GoTo ErrorHandler 
' Get original document text 
Dim docText As String 
docText = GetDocumentText() 
' Process each module based on conflict resolutions 
Dim exModules As collection 
Set exModules = analysisResult("ExternalInfo")("Modules") 
Dim i As Long 
Dim resultText As String 
resultText = docText 
' Process each external module 
For i = 1 To exModules.count 
Dim exModule As Object 
Set exModule = exModules(i) 
' Check if module has conflict 
Dim moduleConflict As Object 
Set moduleConflict = FindConflict("Module", exModule("Name")) 
If Not moduleConflict Is Nothing Then 
' Handle based on resolution 
Select Case moduleConflict("Resolution") 
Case "KeepExisting" 
' Do nothing, keep document version 
LogMessage "Keeping existing module: " & exModule("Name") 
Case "ReplaceWithImported" 
' Replace document module with imported module 
resultText = ReplaceModule(resultText,  
moduleConflict("DocumentModule"), _ 
ExtractModuleText(externalCode,  
exModule)) 
LogMessage "Replaced module: " & exModule("Name") 
Case "Rename" 
' Add imported module with new name 
resultText = resultText & vbCrLf & vbCrLf & _
RenameModule(ExtractModuleText(externalCode,  
exModule), _ 
exModule("Name"),  
moduleConflict("NewName")) 
LogMessage "Added renamed module: " &  
moduleConflict("NewName") 
Case "MergeModules" 
' Merge modules with VENOM intelligence 
resultText = MergeModulesVenom(resultText,  
moduleConflict("DocumentModule"), _ 
ExtractModuleText(externalCod 
e, exModule)) 
LogMessage "Merged module with VENOM intelligence: " &  
exModule("Name") 
End Select 
Else 
' No conflict, add to document 
resultText = resultText & vbCrLf & vbCrLf &  
ExtractModuleText(externalCode, exModule) 
LogMessage "Added new module: " & exModule("Name") 
End If 
#If Mac Then 
' Keep UI responsive 
DoEvents 
#End If 
Next i 
' Update document text 
SetDocumentText resultText 
Exit Sub 
ErrorHandler: 
LogMessage "Error in MergeCodeIntoDocument: " & Err.description, "ERROR" End Sub 
' Mac-optimized version of MergeCodeIntoDocument 
#If Mac Then 
Private Sub MergeCodeIntoDocumentMac(externalCode As String,  analysisResult As Object) 
' Reset timeout timer 
ResetMacProcessingTimer 
' Call the main function 
MergeCodeIntoDocument externalCode, analysisResult 
' Keep UI responsive 
DoEvents 
End Sub 
#End If 
' ********************* 
' * HELPER FUNCTIONS *
' ********************* 
' Find conflict info for a given name and type 
Private Function FindConflict(conflictType As String, name As String) As  Object 
On Error Resume Next 
Dim i As Long 
For i = 1 To mConflicts.count 
Dim conflict As Object 
Set conflict = mConflicts(i) 
If conflict("Type") = conflictType And LCase(conflict("Name")) =  LCase(name) Then 
Set FindConflict = conflict 
Exit Function 
End If 
Next i 
Set FindConflict = Nothing 
On Error GoTo 0 
End Function 
' Extract module text from code 
Private Function ExtractModuleText(code As String, moduleInfo As Object) As  String 
On Error GoTo ErrorHandler 
Dim startLine As Long 
Dim endLine As Long 
Dim moduleText As String 
startLine = moduleInfo("LineStart") 
endLine = moduleInfo("LineEnd") 
' Split code into lines 
Dim codeLines As Variant 
codeLines = Split(code, vbCrLf) 
' Extract lines for module 
Dim i As Long 
moduleText = "" 
For i = startLine To endLine 
If i <= UBound(codeLines) Then 
moduleText = moduleText & codeLines(i) & vbCrLf 
End If 
#If Mac Then 
' Check for timeout in large modules 
If i = startLine Or i Mod 1000 = 0 Then 
DoEvents ' Keep UI responsive
End If 
#End If 
Next i 
ExtractModuleText = moduleText 
Exit Function 
ErrorHandler: 
' Simple fallback 
ExtractModuleText = "' Error extracting module text: " & Err.description LogMessage "Error extracting module text: " & Err.description, "ERROR" End Function 
' Replace module in document 
Private Function ReplaceModule(docText As String, moduleInfo As Object,  newModuleText As String) As String 
On Error GoTo ErrorHandler 
Dim result As String 
Dim startLine As Long 
Dim endLine As Long 
startLine = moduleInfo("LineStart") 
endLine = moduleInfo("LineEnd") 
' Split document into lines 
Dim docLines As Variant 
docLines = Split(docText, vbCrLf) 
' Build result with replaced module 
Dim i As Long 
result = "" 
' Lines before module 
For i = 0 To startLine - 1 
If i <= UBound(docLines) Then 
result = result & docLines(i) & vbCrLf 
End If 
#If Mac Then 
' Keep UI responsive for large documents 
If i Mod 1000 = 0 Then DoEvents 
#End If 
Next i 
' New module text 
result = result & newModuleText 
' Lines after module 
For i = endLine + 1 To UBound(docLines) 
result = result & docLines(i) & vbCrLf 
#If Mac Then
' Keep UI responsive for large documents 
If i Mod 1000 = 0 Then DoEvents 
#End If 
Next i 
ReplaceModule = result 
Exit Function 
ErrorHandler: 
ReplaceModule = docText ' Return original on error 
LogMessage "Error replacing module: " & Err.description, "ERROR" End Function 
' Rename module in imported code with VENOM styling 
Private Function RenameModule(moduleText As String, oldName As String,  newName As String) As String 
On Error GoTo ErrorHandler 
' Replace module name in Attribute line 
Dim result As String 
result = moduleText 
' Find Attribute line pattern 
Dim attrPattern As String 
attrPattern = "Attribute VB_Name = """ & oldName & """" 
' Replace in Attribute line 
result = Replace(result, attrPattern, "Attribute VB_Name = """ & newName  & """") 
' Replace in header comment if exists 
Dim headerPattern As String 
headerPattern = "' " & oldName 
' Replace in header with VENOM enhancement 
result = Replace(result, headerPattern, "' " & newName & " - VENOM  Enhanced") 
' Add VENOM signature to header if VENOMized naming 
If InStr(1, newName, "VENOM", vbTextCompare) > 0 Then 
Dim lines As Variant 
lines = Split(result, vbCrLf) 
' Find header section 
Dim headerStart As Long, headerEnd As Long 
headerStart = -1 
headerEnd = -1 
For i = 0 To UBound(lines) 
If Left(Trim(lines(i)), 1) = "'" Then 
If headerStart = -1 Then headerStart = i 
headerEnd = i 
ElseIf headerStart <> -1 And Trim(lines(i)) <> "" Then 
' Found non-comment line after header
Exit For 
End If 
#If Mac Then 
' Check for timeout in large documents 
If i Mod 1000 = 0 Then DoEvents 
#End If 
Next i 
' If header found, enhance it 
If headerStart >= 0 And headerEnd >= 0 Then 
' Add VENOM signature 
Dim signature As String 
signature = "' * Enhanced with VENOM - Visually Enhanced Notation  for Optimized Modules *" 
' Insert after header 
result = "" 
For i = 0 To headerEnd 
result = result & lines(i) & vbCrLf 
#If Mac Then 
' Check for timeout in large documents 
If i Mod 1000 = 0 Then DoEvents 
#End If 
Next i 
result = result & signature & vbCrLf 
For i = headerEnd + 1 To UBound(lines) 
result = result & lines(i) & vbCrLf 
#If Mac Then 
' Check for timeout in large documents 
If i Mod 1000 = 0 Then DoEvents 
#End If 
Next i 
End If 
End If 
RenameModule = result 
Exit Function 
ErrorHandler: 
RenameModule = moduleText ' Return original on error 
LogMessage "Error renaming module: " & Err.description, "ERROR" End Function 
' Merge two modules with VENOM intelligence 
Private Function MergeModulesVenom(docText As String, moduleInfo As Object,  importedModuleText As String) As String 
On Error GoTo ErrorHandler 
Dim result As String
Dim startLine As Long 
Dim endLine As Long 
startLine = moduleInfo("LineStart") 
endLine = moduleInfo("LineEnd") 
' Split document into lines 
Dim docLines As Variant 
docLines = Split(docText, vbCrLf) 
' Build result with merged module 
Dim i As Long 
result = "" 
' Lines before module 
For i = 0 To startLine - 1 
If i <= UBound(docLines) Then 
result = result & docLines(i) & vbCrLf 
End If 
#If Mac Then 
' Check for timeout in large documents 
If i Mod 1000 = 0 Then DoEvents 
#End If 
Next i 
' Original module text 
For i = startLine To endLine 
If i <= UBound(docLines) Then 
result = result & docLines(i) & vbCrLf 
End If 
#If Mac Then 
' Check for timeout in large documents 
If i Mod 1000 = 0 Then DoEvents 
#End If 
Next i 
' Add imported module content with VENOM separator 
result = result & vbCrLf & _ 
"'  
****************************************************************" & vbCrLf &  _ 
"' * VENOM MERGED CODE - IMPORTED  
CONTENT *" & vbCrLf & _ 
"' * Use with caution - the venom is potent but  
effective *" & vbCrLf & _ 
"'  
****************************************************************" & vbCrLf &  _ 
ExtractModuleContent(importedModuleText) 
' Lines after module 
For i = endLine + 1 To UBound(docLines) 
result = result & docLines(i) & vbCrLf
#If Mac Then 
' Check for timeout in large documents 
If i Mod 1000 = 0 Then DoEvents 
#End If 
Next i 
MergeModulesVenom = result 
Exit Function 
ErrorHandler: 
MergeModulesVenom = docText ' Return original on error 
LogMessage "Error merging modules: " & Err.description, "ERROR" End Function 
' Extract content part of module (skip header) 
Private Function ExtractModuleContent(moduleText As String) As String On Error GoTo ErrorHandler 
Dim lines As Variant 
lines = Split(moduleText, vbCrLf) 
' Skip header lines (typically first 6-10 lines) 
Dim result As String 
Dim i As Long 
Dim headerSkipped As Boolean 
headerSkipped = False 
result = "" 
For i = 0 To UBound(lines) 
' Skip header lines until we find Option Explicit or other code If Not headerSkipped Then 
If Left(Trim(lines(i)), 1) <> "'" And Trim(lines(i)) <> "" Then 
headerSkipped = True 
result = result & lines(i) & vbCrLf 
End If 
Else 
result = result & lines(i) & vbCrLf 
End If 
#If Mac Then 
' Check for timeout in large documents 
If i Mod 1000 = 0 Then DoEvents 
#End If 
Next i 
ExtractModuleContent = result 
Exit Function 
ErrorHandler: 
ExtractModuleContent = "' Error extracting module content: " &  Err.description
LogMessage "Error extracting module content: " & Err.description, "ERROR" End Function 
' ******************************* 
' * VENOM SPECIFIC ENHANCEMENTS * 
' ******************************* 
' Apply VENOM styling to code 
Private Function ApplyVenomStyling(codeText As String) As String On Error GoTo ErrorHandler 
Dim result As String 
result = codeText 
' Process the code line by line 
Dim lines As Variant 
lines = Split(result, vbCrLf) 
' Check if this is a module header (first few lines) 
Dim hasHeaderComment As Boolean 
hasHeaderComment = False 
If UBound(lines) > 5 Then 
' Check if we have a module header comment 
For i = 0 To 5 
If i <= UBound(lines) Then 
If Left(Trim(lines(i)), 1) = "'" Then 
hasHeaderComment = True 
Exit For 
End If 
End If 
Next i 
End If 
' If no header, don't bother with styling 
If Not hasHeaderComment Then 
ApplyVenomStyling = result 
Exit Function 
End If 
' Find the attribute line and module name 
Dim moduleName As String 
moduleName = "" 
For i = 0 To UBound(lines) 
If InStr(1, lines(i), "Attribute VB_Name = """) > 0 Then 
' Extract module name 
Dim attrLine As String 
attrLine = lines(i) 
Dim startPos As Long, endPos As Long 
startPos = InStr(1, attrLine, """") + 1 
endPos = InStr(startPos, attrLine, """")
If startPos > 0 And endPos > startPos Then 
moduleName = Mid(attrLine, startPos, endPos - startPos) 
End If 
Exit For 
End If 
Next i 
' If we found a module name, enhance the header 
If moduleName <> "" Then 
' Create a new styled header 
Dim styledHeader As String 
styledHeader = "Attribute VB_Name = """ & moduleName & """" & vbCrLf  & _ 
"'  
****************************************************************************"  & vbCrLf & _ 
"' * " & UCase(moduleName) & "  
(VENOMized) " & String(20 - Len(moduleName), " ") & "*" &  vbCrLf & _ 
"' * Striking with precision, executing with  
deadly efficiency *" & vbCrLf & _ 
"'  
* 
*" & vbCrLf & _ 
"' * Version: 2.1 Enhanced with  
VENOM *" & vbCrLf & _ "' * Last Updated: " & format(Now, "yyyy-mm-dd") &  
" *" & vbCrLf & _ "' * Author: Aaron  
McCutchins *" &  vbCrLf & _ 
"'  
****************************************************************************" 
' Replace the header in the code 
' Find the end of the original header 
Dim headerEndLine As Long 
headerEndLine = -1 
' Skip Attribute line 
Dim startLine As Long 
startLine = 1 ' Start after Attribute line 
For i = startLine To UBound(lines) 
If Left(Trim(lines(i)), 1) = "'" Then 
headerEndLine = i 
ElseIf Trim(lines(i)) <> "" Then 
' Found non-comment line 
Exit For 
End If 
Next i 
' If header found, replace it 
If headerEndLine >= 0 Then
' Build result with new header 
result = "" 
' Add the styled header 
result = styledHeader & vbCrLf 
' Add remaining code (skip original header) 
For i = headerEndLine + 1 To UBound(lines) 
result = result & lines(i) & vbCrLf 
#If Mac Then 
' Check for timeout in large documents 
If i Mod 1000 = 0 Then DoEvents 
#End If 
Next i 
End If 
End If 
' Look for procedure comments to enhance 
lines = Split(result, vbCrLf) 
result = "" 
Dim inProcComment As Boolean 
inProcComment = False 
Dim procCommentStart As Long 
procCommentStart = -1 
For i = 0 To UBound(lines) 
Dim currentLine As String 
currentLine = lines(i) 
' Check if this is the start of a procedure comment 
If Not inProcComment And Left(Trim(currentLine), 1) = "'" And _ i + 1 <= UBound(lines) And _ 
(InStr(1, LCase(lines(i + 1)), "sub ") > 0 Or InStr(1,  
LCase(lines(i + 1)), "function ") > 0) Then 
inProcComment = True 
procCommentStart = i 
' Collect all comment lines 
Dim commentLines As String 
commentLines = "" 
Do While i <= UBound(lines) And Left(Trim(lines(i)), 1) = "'" commentLines = commentLines & Mid(Trim(lines(i)), 2) & " " i = i + 1 
Loop 
' Extract procedure name 
Dim procLine As String 
procLine = lines(i) 
Dim procName As String
procName = "" 
If InStr(1, procLine, "Sub ") > 0 Then 
procName = Mid(procLine, InStr(1, procLine, "Sub ") + 4) 
procName = Trim(Split(procName, "(")(0)) 
ElseIf InStr(1, procLine, "Function ") > 0 Then 
procName = Mid(procLine, InStr(1, procLine, "Function ") + 9) procName = Trim(Split(procName, "(")(0)) 
End If 
' Create enhanced comment 
If procName <> "" Then 
result = result & "' *" & String(Len(procName) + 10, "*") &  "*" & vbCrLf 
result = result & "' * " & UCase(procName) & " " & String(8,  " ") & "*" & vbCrLf 
result = result & "' *" & String(Len(procName) + 10, "*") &  "*" & vbCrLf 
End If 
' Add procedure line 
result = result & procLine & vbCrLf 
' Reset flag 
inProcComment = False 
Else 
' Regular line, just add it 
result = result & currentLine & vbCrLf 
End If 
#If Mac Then 
' Check for timeout in large documents 
If i Mod 1000 = 0 Then DoEvents 
#End If 
Next i 
ApplyVenomStyling = result 
Exit Function 
ErrorHandler: 
ApplyVenomStyling = codeText ' Return original on error 
LogMessage "Error applying VENOM styling: " & Err.description, "ERROR" End Function 
' Mac-optimized version with chunking for better performance #If Mac Then 
Private Function ApplyVenomStylingMac(codeText As String) As String ' Reset timeout timer 
ResetMacProcessingTimer 
' Process code in chunks if it's large 
If Len(codeText) > MAC_CHUNK_SIZE Then 
LogMessage "Processing large code file in chunks on Mac", "INFO"
' For very large files, use a simplified approach 
' that just adds VENOM headers without complex processing 
' Check if this is a module (has attribute line) 
If InStr(1, codeText, "Attribute VB_Name = """) > 0 Then 
' Extract module name 
Dim moduleName As String 
Dim startPos As Long, endPos As Long 
startPos = InStr(1, codeText, "Attribute VB_Name = """) + 20 endPos = InStr(startPos, codeText, """") 
If startPos > 0 And endPos > startPos Then 
moduleName = Mid(codeText, startPos, endPos - startPos) 
' Create a VENOM header to prepend 
Dim venomHeader As String 
venomHeader = "Attribute VB_Name = """ & moduleName &  
"""" & vbCrLf & _ 
"'  
****************************************************************************"  & vbCrLf & _ 
"' * " &  
UCase(moduleName) & " (VENOMized) " & String(20 - Len(moduleName), " ") & "*" & vbCrLf & _ 
"' * Striking with precision,  
executing with deadly efficiency *" & vbCrLf & _ "'  
* 
*" & vbCrLf & _ 
"' * Version: 2.1 Enhanced with  
VENOM *" & vbCrLf & _ "' * Last Updated: " & format(Now, "yyyy-mm 
dd") & " *" & vbCrLf & _ "' * Author: Aaron  
McCutchins *" &  vbCrLf & _ 
"'  
****************************************************************************"  & vbCrLf 
' Replace the original header with the VENOM header 
Dim origHeaderEnd As Long 
origHeaderEnd = InStr(endPos + 2, codeText, "Option  
Explicit") 
If origHeaderEnd > 0 Then 
' Get the code after the original header 
Dim codeAfterHeader As String 
codeAfterHeader = Mid(codeText, origHeaderEnd) 
' Return the combined result 
ApplyVenomStylingMac = venomHeader & codeAfterHeader 
Else
' Keep the code as is if we can't find a good  
insertion point 
ApplyVenomStylingMac = codeText 
End If 
Else 
ApplyVenomStylingMac = codeText 
End If 
Else 
' Not a module or couldn't parse, return as is 
ApplyVenomStylingMac = codeText 
End If 
Else 
' Small enough to process normally 
ApplyVenomStylingMac = ApplyVenomStyling(codeText) 
End If 
' Keep UI responsive 
DoEvents 
End Function 
#End If 
' Calculate similarity score between two modules 
Private Function CalculateSimilarityScore(Module1 As Object, Module2 As  Object) As Integer 
On Error GoTo ErrorHandler 
' Simple implementation - compare procedure count similarity Dim proc1Count As Integer, proc2Count As Integer 
proc1Count = Module1("Procedures").count 
proc2Count = Module2("Procedures").count 
Dim smallerCount As Integer, largerCount As Integer 
smallerCount = IIf(proc1Count < proc2Count, proc1Count, proc2Count) largerCount = IIf(proc1Count > proc2Count, proc1Count, proc2Count) 
' Calculate similarity as percentage 
If largerCount = 0 Then 
CalculateSimilarityScore = 100 ' Both empty = 100% similar Else 
CalculateSimilarityScore = Int((smallerCount / largerCount) * 100) End If 
Exit Function 
ErrorHandler: 
CalculateSimilarityScore = 50 ' Default to 50% similarity on error LogMessage "Error calculating similarity score: " & Err.description,  "ERROR" 
End Function 
Private Function AssessProcedureComplexity(proc1 As Object, proc2 As Object)  As String 
On Error Resume Next
' Attempt to get procedure code 
Dim proc1Code As String, proc2Code As String 
proc1Code = GetProcedureCode(proc1) 
proc2Code = GetProcedureCode(proc2) 
' If failed to get source code, return default 
If proc1Code = "" Or proc2Code = "" Then 
AssessProcedureComplexity = "Comparable" 
Exit Function 
End If 
' Calculate metrics for comparison 
Dim proc1Lines As Long, proc2Lines As Long 
Dim proc1Complexity As Double, proc2Complexity As Double 
proc1Lines = UBound(Split(proc1Code, vbCrLf)) + 1 
proc2Lines = UBound(Split(proc2Code, vbCrLf)) + 1 
' Calculate approximate cyclomatic complexity by counting control  structures 
proc1Complexity = CalculateApproxComplexity(proc1Code) 
proc2Complexity = CalculateApproxComplexity(proc2Code) 
' Determine which procedure is more complex 
Dim lineRatio As Double, complexityRatio As Double 
' Avoid division by zero 
If proc1Lines = 0 Then proc1Lines = 1 
If proc2Lines = 0 Then proc2Lines = 1 
If proc1Complexity = 0 Then proc1Complexity = 1 
If proc2Complexity = 0 Then proc2Complexity = 1 
lineRatio = proc1Lines / proc2Lines 
complexityRatio = proc1Complexity / proc2Complexity 
' Make the assessment based on both metrics 
If lineRatio > 1.5 And complexityRatio > 1.5 Then 
AssessProcedureComplexity = "More Complex" 
ElseIf lineRatio < 0.75 And complexityRatio < 0.75 Then AssessProcedureComplexity = "Less Complex" 
Else 
AssessProcedureComplexity = "Comparable" 
End If 
On Error GoTo 0 
End Function 
' Helper function to calculate approximate cyclomatic complexity Private Function CalculateApproxComplexity(procCode As String) As Double Dim complexity As Double 
complexity = 1 ' Base complexity 
' Count control structures that add to complexity
complexity = complexity + CountOccurrences(procCode, "If ") complexity = complexity + CountOccurrences(procCode, "ElseIf ") complexity = complexity + CountOccurrences(procCode, "Case ") complexity = complexity + CountOccurrences(procCode, "For ") complexity = complexity + CountOccurrences(procCode, "While ") complexity = complexity + CountOccurrences(procCode, "Do Until ") complexity = complexity + CountOccurrences(procCode, "Do While ") 
CalculateApproxComplexity = complexity 
End Function 
' Count occurrences of a substring in a string 
Private Function CountOccurrences(source As String, pattern As String) As  Long 
Dim count As Long 
Dim pos As Long 
pos = InStr(1, source, pattern, vbTextCompare) 
While pos > 0 
count = count + 1 
pos = InStr(pos + 1, source, pattern, vbTextCompare) 
Wend 
CountOccurrences = count 
End Function 
' Extract procedure code from object 
Private Function GetProcedureCode(procInfo As Object) As String On Error Resume Next 
' This is a placeholder implementation as we don't have access to the  full document 
' In a real implementation, we would extract the procedure code from the  document 
' using the LineStart and LineEnd properties of the procedure info 
Dim module As Object 
If typeName(procInfo("Module")) = "String" Then 
' Try to find the module in the current document 
' This is simplified and might need more complex logic in reality 
' Return empty string if we can't extract code 
GetProcedureCode = "" 
End If 
' If we had full document access: 
' Dim docLines As Variant 
' docLines = Split(GetDocumentText(), vbCrLf) 
' GetProcedureCode = Join(Mid(docLines, procInfo("LineStart"),  procInfo("LineEnd") - procInfo("LineStart") + 1), vbCrLf) 
On Error GoTo 0 
End Function
'============================================================================ = 
' BEGIN MODULE: modCodeManager (standard module)
'============================================================================ = 
Option Explicit

Private m_codeDatabase As Object ' Dictionary to store code hashes - the genetic memory of harvested victims
Private m_duplicateReport As String ' Record of specimen similarities - for cloning purposes
Private m_isProcessing As Boolean ' Flag to prevent recursive processing
Private m_isInitialized As Boolean ' Track initialization state

'===== INITIALIZATION =====
Public Sub InitializeCodeManager()
    ' Prevent recursive initialization
    If m_isInitialized Then Exit Sub
    
    On Error Resume Next
    Debug.Print "Initializing CodeManager..."
    
    ' Create cross-platform dictionary - a vessel to store our trophies
    If m_codeDatabase Is Nothing Then
        Set m_codeDatabase = CreateCrossPlatformDictionary()
    End If
    
    m_duplicateReport = ""
    m_isProcessing = False
    m_isInitialized = True
    
    Debug.Print "CodeManager initialized successfully."
    
    On Error GoTo 0
End Sub

' Create a cross-platform dictionary that works on both Mac and Windows - toxic on all systems
Private Function CreateCrossPlatformDictionary() As Object
    On Error Resume Next
    
    ' MAC OPTIMIZATION: Use platform-specific approach to avoid redundant attempts
    #If Mac Then
        ' Mac path - use custom implementation directly
        Dim coll As New collection
        coll.Add New collection, "##Keys##"
        Set CreateCrossPlatformDictionary = coll
        
        Debug.Print "Created Mac-compatible dictionary for CodeManager"
    #Else
        ' Windows path - try Scripting.Dictionary
        Dim dict As Object
        Set dict = CreateObject("Scripting.Dictionary")
        
        If Err.Number = 0 Then
            ' Success - Windows dictionary available
            Set CreateCrossPlatformDictionary = dict
            Debug.Print "Created Windows Scripting.Dictionary for CodeManager"
        Else
            ' Fallback for Windows without Scripting.Dictionary
            Dim coll As New collection
            coll.Add New collection, "##Keys##"
            Set CreateCrossPlatformDictionary = coll
            Debug.Print "Created fallback dictionary for CodeManager on Windows"
        End If
    #End If
    
    On Error GoTo 0
End Function

'===== DICTIONARY OPERATIONS =====
' Check if key exists in dictionary (cross-platform) - has the specimen been identified?
Private Function DictExists(dict As Object, key As String) As Boolean
    On Error Resume Next
    
    ' Default to false for safety
    DictExists = False
    
    If typeName(dict) = "Dictionary" Then
        ' Windows Scripting.Dictionary
        DictExists = dict.exists(key)
    Else
        ' Custom Collection implementation
        Dim keys As collection
        Set keys = dict.item("##Keys##")
        Dim i As Long
        For i = 1 To keys.count
            If keys(i) = key Then
                DictExists = True
                Exit Function
            End If
        Next i
    End If
    
    On Error GoTo 0
End Function

' Get value from dictionary (cross-platform) - retrieve specimen from storage
Private Function DictGet(dict As Object, key As String) As Variant
    On Error Resume Next
    
    If typeName(dict) = "Dictionary" Then
        ' Windows Scripting.Dictionary
        If dict.exists(key) Then
            If IsObject(dict.item(key)) Then
                Set DictGet = dict.item(key)
            Else
                DictGet = dict.item(key)
            End If
        End If
    Else
        ' Custom Collection implementation
        Dim keys As collection
        Set keys = dict.item("##Keys##")
        Dim i As Long
        For i = 1 To keys.count
            If keys(i) = key Then
                If IsObject(dict.item(i + 1)) Then
                    Set DictGet = dict.item(i + 1)
                Else
                    DictGet = dict.item(i + 1)
                End If
                Exit Function
            End If
        Next i
    End If
    
    On Error GoTo 0
End Function

' Add key/value to dictionary (cross-platform) - catalog the harvested specimen
Private Sub DictAdd(dict As Object, key As String, value As Variant)
    On Error Resume Next
    
    If typeName(dict) = "Dictionary" Then
        ' Windows Scripting.Dictionary
        If Not dict.exists(key) Then
            If IsObject(value) Then
                Set dict.item(key) = value
            Else
                dict.item(key) = value
            End If
        Else
            If IsObject(value) Then
                Set dict.item(key) = value
            Else
                dict.item(key) = value
            End If
        End If
    Else
        ' Custom Collection implementation
        Dim keys As collection
        Set keys = dict.item("##Keys##")
        ' Check if key exists
        Dim keyExists As Boolean
        Dim i As Long
        keyExists = False
        For i = 1 To keys.count
            If keys(i) = key Then
                keyExists = True
                
                ' Need to remove and re-add since we can't just update Collections
                dict.Remove i + 1
                
                If IsObject(value) Then
                    dict.Add value, , i
                Else
                    dict.Add value, , i
                End If
                
                Exit Sub
            End If
        Next i
        
        ' Add new key/value
        If Not keyExists Then
            keys.Add key
            If IsObject(value) Then
                dict.Add value
            Else
                dict.Add value
            End If
        End If
    End If
    
    On Error GoTo 0
End Sub

'===== CODE ANALYSIS =====
' Analyze code for duplicates - identify clone specimens for assimilation
Public Function AnalyzeCodeForDuplicates() As String
    ' Prevent recursive or simultaneous processing
    If m_isProcessing Then
        AnalyzeCodeForDuplicates = "Analysis already in progress - specimen examination occupied"
        Exit Function
    End If
    
    On Error GoTo ErrorHandler
    m_isProcessing = True
    
    Dim VBProj As Object
    Dim VBComp As Object
    Dim codeModule As Object
    Dim codeText As String
    Dim moduleHash As String
    Dim procedureName As String
    Dim procedureHash As String
    Dim lineCount As Long
    Dim i As Long
    
    ' Initialize - prepare the vivisection
    If Not m_isInitialized Then Call InitializeCodeManager
    m_duplicateReport = ""
    
    ' Get the VB project - the host organism
    Set VBProj = ThisDocument.VBProject
    
    ' MAC OPTIMIZATION: Add timeout protection
    Dim startTime As Date
    startTime = Now
    
    ' Status update
    Debug.Print "Beginning code analysis - scanning host organism..."
    
    ' MAC OPTIMIZATION: Track progress
    Dim totalComponents As Long
    Dim processedComponents As Long
    totalComponents = VBProj.VBComponents.count
    processedComponents = 0
    
    ' Iterate through all components - examine the organs
    For Each VBComp In VBProj.VBComponents
        ' Update progress counter
        processedComponents = processedComponents + 1
        
        ' MAC OPTIMIZATION: Check for timeout every component
        If DateDiff("s", startTime, Now) > 30 Then
            ' 30-second timeout to prevent freeze
            m_duplicateReport = m_duplicateReport & "Analysis timeout after processing " & _
                processedComponents & " of " & totalComponents & " components." & gLineBreak & _
                "Partial results follow:" & gLineBreak & gLineBreak
            GoTo FinishAnalysis
        End If
        
        ' Process standard modules and document modules
        If VBComp.Type = 1 Or VBComp.Type = 100 Then ' Module or Document Module
            Set codeModule = VBComp.codeModule
            
            ' Get full module text - extract the genetic material
            lineCount = codeModule.CountOfLines
            If lineCount > 0 Then
                ' MAC OPTIMIZATION: Skip extremely large modules
                If lineCount > 10000 And gIsMac Then
                    m_duplicateReport = m_duplicateReport & _
                        "WARNING: Skipped extremely large module: " & VBComp.name & _
                        " (" & lineCount & " lines) for Mac performance." & gLineBreak
                    GoTo NextComponent
                End If
                
                ' MAC OPTIMIZATION: Process in batches with UI updates
                If lineCount > 1000 Then
                    Debug.Print "Processing large module: " & VBComp.name & " (" & lineCount & " lines)"
                    DoEvents ' Allow UI to refresh
                End If
                
                codeText = codeModule.lines(1, lineCount)
                moduleHash = GenerateCodeHash(codeText)
                
                ' Check for module-level duplicates - identical genetic patterns
                If DictExists(m_codeDatabase, moduleHash) Then
                    m_duplicateReport = m_duplicateReport & _
                        "DUPLICATE MODULE DETECTED:" & gLineBreak & _
                        "Original Specimen: " & DictGet(m_codeDatabase, moduleHash) & gLineBreak & _
                        "Clone Detected: " & VBComp.name & gLineBreak & _
                        "Genetic Match: 100%" & gLineBreak & gLineBreak
                Else
                    DictAdd m_codeDatabase, moduleHash, VBComp.name
                End If
                
                ' MAC OPTIMIZATION: Skip procedure-level analysis for large modules on Mac
                If lineCount > 5000 And gIsMac Then
                    m_duplicateReport = m_duplicateReport & _
                        "INFO: Skipped procedure-level analysis for large module: " & VBComp.name & _
                        " (" & lineCount & " lines) for Mac performance." & gLineBreak
                    GoTo NextComponent
                End If
                
                ' Analyze individual procedures - dissect the cellular components
                Dim lastProcName As String
                lastProcName = ""
                
                ' MAC OPTIMIZATION: Sample procedures instead of checking every line
                Dim increment As Long
                increment = IIf(gIsMac And lineCount > 1000, 10, 1) ' Sample every 10th line on Mac for large modules
                
                For i = 1 To lineCount Step increment
                    ' MAC OPTIMIZATION: Periodic UI refresh for large modules
                    If i Mod 1000 = 0 Then
                        DoEvents ' Allow UI to refresh periodically
                        
                        ' Check for timeout
                        If DateDiff("s", startTime, Now) > 30 Then
                            m_duplicateReport = m_duplicateReport & "Analysis timeout during procedure scanning in " & _
                                VBComp.name & "." & gLineBreak & "Partial results follow:" & gLineBreak & gLineBreak
                            GoTo FinishAnalysis
                        End If
                    End If
                    
                    procedureName = GetProcedureAtLine(codeModule, i)
                    If procedureName <> "" And procedureName <> lastProcName Then
                        lastProcName = procedureName ' Avoid re-processing the same procedure
                        codeText = GetProcedureCode(codeModule, procedureName, i)
                        If codeText <> "" Then
                            procedureHash = GenerateCodeHash(codeText)
                            CheckProcedureDuplicate procedureName, procedureHash, VBComp.name
                        End If
                    End If
                Next i
            End If
        End If
        
NextComponent:
    Next VBComp
    
FinishAnalysis:
    Debug.Print "Code analysis complete - processed " & processedComponents & " components"
    
    ' If report is empty, add a summary message
    If m_duplicateReport = "" Then
        m_duplicateReport = "No duplicate code detected - each specimen is genetically unique."
    End If
    
    ' Add summary header
    m_duplicateReport = "=== CODE DUPLICATION ANALYSIS REPORT ===" & gLineBreak & _
                      "Analyzed " & processedComponents & " of " & totalComponents & " components" & gLineBreak & _
                      "Timestamp: " & format(Now, "yyyy-mm-dd hh:nn:ss") & gLineBreak & gLineBreak & _
                      m_duplicateReport
    
    AnalyzeCodeForDuplicates = m_duplicateReport
    m_isProcessing = False
    Exit Function
    
ErrorHandler:
    Debug.Print "Error in DNA analysis: " & Err.Number & " - " & Err.description
    
    ' Safe error handling
    On Error Resume Next
    
    ' Try to use ErrorHandler if available
    Application.Run "ErrorHandler.HandleError", "CodeManager", "AnalyzeCodeForDuplicates", _
                  Err.Number, Err.description, True
    
    ' Always return something useful
    AnalyzeCodeForDuplicates = "Error analyzing genetic code - specimen contaminated: " & _
                            Err.Number & " - " & Err.description
    
    m_isProcessing = False
End Function

' Generate hash from code - create a unique DNA fingerprint
Private Function GenerateCodeHash(ByVal code As String) As String
    On Error Resume Next
    
    ' MAC OPTIMIZATION: Cap extremely long code samples to avoid slow computation
    If Len(code) > 50000 And gIsMac Then
        code = Left(code, 50000) ' Only hash first 50K chars on Mac for very large modules
    End If
    
    ' Simple hash function for code comparison - genetic fingerprinting
    Dim hash As Long
    Dim i As Long
    Dim char As Long
    
    ' Remove whitespace and comments for better comparison - isolate the essential DNA
    code = CleanCodeForComparison(code)
    
    ' Generate hash - sequence the genetic material
    hash = 5381
    For i = 1 To Len(code)
        char = Asc(Mid(code, i, 1))
        hash = ((hash * 33) + char) And &HFFFFFFF ' Use bitwise AND to prevent overflow
    Next i
    
    GenerateCodeHash = CStr(hash)
    
    On Error GoTo 0
End Function

' Clean code for comparison - remove non-essential genetic material
Private Function CleanCodeForComparison(ByVal code As String) As String
    On Error Resume Next
    
    ' MAC OPTIMIZATION: Skip full cleaning for very large code blocks on Mac
    If Len(code) > 100000 And gIsMac Then
        ' Just do basic cleanup for huge code blocks
        code = Replace(code, vbTab, "")
        code = Replace(code, vbCrLf, "")
        code = Replace(code, vbCr, "")
        code = Replace(code, vbLf, "")
        code = Replace(code, " ", "")
        CleanCodeForComparison = code
        Exit Function
    End If
    
    Dim lines() As String
    Dim i As Long
    Dim cleanedLine As String
    Dim result As String
    
    ' Split into lines - break down the DNA sequence
    lines = Split(code, gLineBreak)
    For i = LBound(lines) To UBound(lines)
        cleanedLine = Trim(lines(i))
        
        ' Remove comments and empty lines - strip junk DNA
        If Not (cleanedLine = "" Or Left(cleanedLine, 1) = "'" Or _
                LCase(Left(cleanedLine, 3)) = "rem") Then
            result = result & cleanedLine & ";" ' Use semicolon as line separator
        End If
    Next i
    
    CleanCodeForComparison = result
    
    On Error GoTo 0
End Function

' Get procedure at line - locate a specific genetic sequence
Private Function GetProcedureAtLine(ByVal codeModule As Object, ByVal lineNum As Long) As String
    On Error Resume Next
    GetProcedureAtLine = codeModule.ProcOfLine(lineNum, 0)
    If Err.Number <> 0 Then GetProcedureAtLine = ""
    On Error GoTo 0
End Function

' Get procedure code - extract the complete genetic sequence
Private Function GetProcedureCode(ByVal codeModule As Object, ByVal procName As String, ByVal lineNum As Long) As String
    On Error Resume Next
    
    Dim procType As Long
    Dim startLine As Long
    Dim lineCount As Long
    
    procType = codeModule.ProcOfLine(lineNum, 1)
    startLine = codeModule.procStartLine(procName, procType)
    lineCount = codeModule.procCountLines(procName, procType)
    
    ' MAC OPTIMIZATION: Skip extremely large procedures on Mac
    If gIsMac And lineCount > 5000 Then
        GetProcedureCode = "LARGE_PROCEDURE_SKIPPED_ON_MAC"
        Exit Function
    End If
    
    GetProcedureCode = codeModule.lines(startLine, lineCount)
    
    If Err.Number <> 0 Then GetProcedureCode = ""
    
    On Error GoTo 0
End Function

' Check for procedure duplicates - identify cellular clones
Private Sub CheckProcedureDuplicate(ByVal procName As String, ByVal procHash As String, ByVal moduleName As String)
    On Error Resume Next
    
    ' Skip procedure-level checking for special Mac skip marker
    If procHash = GenerateCodeHash("LARGE_PROCEDURE_SKIPPED_ON_MAC") Then
        Exit Sub
    End If
    
    Dim key As String
    key = "PROC_" & procHash
    
    If DictExists(m_codeDatabase, key) Then
        Dim originalLocation As String
        originalLocation = DictGet(m_codeDatabase, key)
        
        ' Only report if not from the same module - avoid reporting self-cloning
        If InStr(1, originalLocation, moduleName, vbTextCompare) = 0 Then
            m_duplicateReport = m_duplicateReport & _
                "DUPLICATE PROCEDURE DETECTED:" & gLineBreak & _
                "Procedure: " & procName & gLineBreak & _
                "Original Specimen: " & originalLocation & gLineBreak & _
                "Clone Detected: " & moduleName & "." & procName & gLineBreak & _
                "Genetic Match: 100%" & gLineBreak & gLineBreak
        End If
    Else
        DictAdd m_codeDatabase, key, moduleName & "." & procName
    End If
    
    On Error GoTo 0
End Sub

'===== CODE GENERATION & OPTIMIZATION =====
' Get optimized version of code (removes duplicates) - splice out redundant genetic material
Public Function GetOptimizedCode(ByVal code As String) As String
    On Error Resume Next
    
    ' MAC OPTIMIZATION: Skip optimization for very large code blocks on Mac
    If Len(code) > 100000 And gIsMac Then
        GetOptimizedCode = code
        Debug.Print "Skipped code optimization for large code block on Mac (performance optimization)"
        Exit Function
    End If
    
    ' Remove duplicate procedure implementations - eliminate redundant DNA
    Dim optimizedCode As String
    optimizedCode = code
    
    ' First perform analysis to identify duplicates
    If Not m_isInitialized Then Call InitializeCodeManager
    
    ' OPTIMIZATION: Skip full analysis on Mac for performance
    If Not gIsMac Then
        Call AnalyzeCodeForDuplicates
    End If
    
    ' Implementation would parse m_duplicateReport to remove duplicate procedures
    ' For now, return the original code - genetic splicing not yet activated
    GetOptimizedCode = optimizedCode
    
    On Error GoTo 0
End Function

' Export code to file - preserve the specimen for future study
Public Sub ExportCodeToFile(ByVal moduleName As String, ByVal filePath As String)
    On Error GoTo ErrorHandler
    
    Dim VBProj As Object
    Dim VBComp As Object
    Dim codeModule As Object
    Dim codeText As String
    
    ' Get the VB project - the host organism
    Set VBProj = ThisDocument.VBProject
    
    ' Find the specified module - locate the target organ
    For Each VBComp In VBProj.VBComponents
        If VBComp.name = moduleName Then
            Set codeModule = VBComp.codeModule
            
            ' Get the code - extract genetic material
            codeText = codeModule.lines(1, codeModule.CountOfLines)
            
            ' Write to file - preserve in cryogenic storage
            Dim fileNum As Integer
            fileNum = FreeFile
            Open filePath For Output As #fileNum
            Print #fileNum, codeText
            Close #fileNum
            
            Debug.Print "Successfully exported module: " & moduleName
            Exit Sub
        End If
    Next VBComp
    
    ' Module not found - specimen doesn't exist
    MsgBox "Module '" & moduleName & "' not found in host organism.", vbExclamation
    Exit Sub
    
ErrorHandler:
    ' Safe error handling
    On Error Resume Next
    
    Debug.Print "Error in specimen preservation: " & Err.Number & " - " & Err.description
    
    ' Try to use ErrorHandler if available
    Application.Run "ErrorHandler.HandleError", "CodeManager", "ExportCodeToFile", _
                  Err.Number, Err.description
    
    MsgBox "Error exporting genetic material: " & Err.description, vbExclamation
End Sub

' Import code from file - absorb external genetic material
Public Function ImportCodeFromFile(ByVal filePath As String) As String
    On Error GoTo ErrorHandler
    
    Dim fileContent As String
    
    ' Read file - absorb external DNA
    If fileExists(filePath) Then
        ' Platform-specific handling
        #If Mac Then
            ' Mac file reading
            Dim fileNum As Integer
            fileNum = FreeFile
            Open filePath For Input As #fileNum
            fileContent = Input$(LOF(fileNum), #fileNum)
            Close #fileNum
        #Else
            ' Windows file reading
            fileContent = ReadTextFile(filePath)
        #End If
    Else
        ImportCodeFromFile = ""
        Exit Function
    End If
    
    ImportCodeFromFile = fileContent
    Exit Function
    
ErrorHandler:
    ' Safe error handling
    On Error Resume Next
    
    Debug.Print "Error in genetic absorption: " & Err.Number & " - " & Err.description
    
    ' Try to use ErrorHandler if available
    Application.Run "ErrorHandler.HandleError", "CodeManager", "ImportCodeFromFile", _
                  Err.Number, Err.description
    
    ImportCodeFromFile = ""
End Function

' Create new module with code - birth a new organism from genetic template
Public Function CreateNewModule(ByVal moduleName As String, ByVal moduleCode As String) As Boolean
    On Error GoTo ErrorHandler
    
    Dim VBProj As Object
    Dim VBComp As Object
    
    ' Get the VB project - the womb for our new creation
    Set VBProj = ThisDocument.VBProject
    
    ' Check if module exists - is there already a creature with this name?
    Dim moduleExists As Boolean
    moduleExists = False
    
    For Each VBComp In VBProj.VBComponents
        If VBComp.name = moduleName Then
            moduleExists = True
            Exit For
        End If
    Next VBComp
    
    ' Create or replace module - genesis or assimilation
    If moduleExists Then
        ' Remove existing module - terminate the old specimen
        VBProj.VBComponents.Remove VBComp
    End If
    
    ' Add new module - birth the new creature
    Set VBComp = VBProj.VBComponents.Add(1) ' 1 = vbext_ct_StdModule
    VBComp.name = moduleName
    
    ' Add code - infuse with genetic material
    VBComp.codeModule.AddFromString moduleCode
    
    CreateNewModule = True
    Exit Function
    
ErrorHandler:
    ' Safe error handling
    On Error Resume Next
    
    Debug.Print "Error in specimen creation: " & Err.Number & " - " & Err.description
    
    ' Try to use ErrorHandler if available
    Application.Run "ErrorHandler.HandleError", "CodeManager", "CreateNewModule", _
                  Err.Number, Err.description
    
    CreateNewModule = False
End Function

' Merge code from multiple sources - genetic hybridization
Public Function MergeCode(ByVal codeArray As Variant) As String
    On Error GoTo ErrorHandler
    
    Dim mergedCode As String
    Dim i As Long
    
    mergedCode = ""
    
    ' Loop through all code snippets in the array - combine genetic material
    For i = LBound(codeArray) To UBound(codeArray)
        If i > LBound(codeArray) Then
            ' Add separation between code blocks - genetic buffer
            mergedCode = mergedCode & gLineBreak & gLineBreak
        End If
        
        ' Add code - splice DNA sequence
        mergedCode = mergedCode & codeArray(i)
        
        ' MAC OPTIMIZATION: Add periodic DoEvents for very large merges
        If Len(mergedCode) > 100000 And gIsMac Then
            DoEvents ' Allow UI to refresh for large merges
        End If
    Next i
    
    ' MAC OPTIMIZATION: Skip optimization for large merges on Mac
    If Len(mergedCode) > 100000 And gIsMac Then
        MergeCode = mergedCode
        Debug.Print "Skipped optimization for large code merge on Mac (performance optimization)"
    Else
        ' Analyze and remove duplicates - filter genetic redundancies
        MergeCode = GetOptimizedCode(mergedCode)
    End If
    
    Exit Function
    
ErrorHandler:
    ' Safe error handling
    On Error Resume Next
    
    Debug.Print "Error in genetic hybridization: " & Err.Number & " - " & Err.description
    
    ' Try to use ErrorHandler if available
    Application.Run "ErrorHandler.HandleError", "CodeManager", "MergeCode", _
                  Err.Number, Err.description
    
    MergeCode = ""
End Function

' Format code for better readability - arrange the DNA in aesthetically pleasing patterns
Public Function FormatCode(ByVal code As String) As String
    On Error GoTo ErrorHandler
    
    ' MAC OPTIMIZATION: Skip formatting for very large code blocks on Mac
    If Len(code) > 100000 And gIsMac Then
        FormatCode = code
        Debug.Print "Skipped code formatting for large code block on Mac (performance optimization)"
        Exit Function
    End If
    
    Dim formattedCode As String
    Dim lines() As String
    Dim i As Long
    Dim indentLevel As Long
    Dim line As String
    
    ' Split into lines - separate into genetic sequences
    lines = Split(code, gLineBreak)
    formattedCode = ""
    indentLevel = 0
    
    ' MAC OPTIMIZATION: Check line count and show progress for large amounts
    Dim totalLines As Long
    totalLines = UBound(lines) - LBound(lines) + 1
    
    If totalLines > 5000 Then
        Debug.Print "Formatting large code block: " & totalLines & " lines"
    End If
    
    ' Process each line - arrange each strand of DNA
    For i = LBound(lines) To UBound(lines)
        ' MAC OPTIMIZATION: Refresh UI for very large code blocks
        If i Mod 1000 = 0 And totalLines > 1000 And gIsMac Then
            DoEvents ' Allow UI to refresh periodically
        End If
        
        line = Trim(lines(i))
        
        ' Skip empty lines - ignore junk DNA
        If line = "" Then
            formattedCode = formattedCode & gLineBreak
            GoTo NextLine
        End If
        
        ' Check for block endings - exiting genetic scope
        If line Like "End *" Or line = "Next" Or line = "Loop" Or _
           line = "Wend" Or line = "Else" Or line Like "ElseIf *" Or _
           line = "#End If" Or line = "#Else" Then
            indentLevel = indentLevel - 1
            If indentLevel < 0 Then indentLevel = 0
        End If
        
        ' Add indentation - create a visual genetic hierarchy
        formattedCode = formattedCode & Space(indentLevel * 4) & line & gLineBreak
        
        ' Check for block beginnings - entering genetic scope
        If line Like "Sub *" Or line Like "Function *" Or _
           line Like "If * Then" Or line = "Else" Or line Like "ElseIf * Then" Or _
           line Like "For *" Or line Like "Do *" Or line Like "While *" Or _
           line Like "Select Case *" Or line Like "With *" Or _
           line = "#If *" Or line = "#Else" Then
            indentLevel = indentLevel + 1
        End If
        
NextLine:
    Next i
    
    FormatCode = formattedCode
    Exit Function
    
ErrorHandler:
    ' Safe error handling
    On Error Resume Next
    
    Debug.Print "Error in genetic beautification: " & Err.Number & " - " & Err.description
    
    ' Try to use ErrorHandler if available
    Application.Run "ErrorHandler.HandleError", "CodeManager", "FormatCode", _
                  Err.Number, Err.description
    
    FormatCode = code ' Return original code on error - leave DNA untouched
End Function

' Check if a file exists
Private Function fileExists(ByVal filePath As String) As Boolean
    On Error Resume Next
    
    #If Mac Then
        ' Mac file existence check
        Dim fileNum As Integer
        fileNum = FreeFile
        Open filePath For Input As #fileNum
        If Err.Number = 0 Then
            Close #fileNum
            fileExists = True
        Else
            fileExists = False
        End If
    #Else
        ' Windows file existence check
        fileExists = (Dir(filePath) <> "")
    #End If
    
    On Error GoTo 0
End Function
'=============================================================================
' END MODULE: modCodeManager
'=============================================================================

‘********************************************************* 
‘‘***************** ‘coVdEeNcOoMde ‘******************     
‘********************************************************* 

'============================================================================ = 
' BEGIN MODULE: modVisualStyles (standard module)
'============================================================================ = 
Option Explicit

' Module level variables
Private m_isInitialized As Boolean
Private m_darkModeEnabled As Boolean
Private m_colorPalette As Object
Private m_keysList As Object ' For Mac: Parallel collection to store keys

#If Mac Then
    ' Mac-specific constants for performance without functionality changes
    Private Const MAC_CONTROL_BATCH_SIZE As Long = 10 ' Process controls in batches
    Private Const MAC_PROCESS_TIMEOUT_MS As Long = 300 ' Timeout for processing (milliseconds)
    Private mLastProcessTime As Double ' Last processing time for timeout detection
    Private mIsMacProcessing As Boolean ' Flag to prevent reentrant processing on Mac
#End If

Private Const MODULE_NAME As String = "modVisualStyle"
Private Const USER_FORM_SCALE_FACTOR As Single = 1.5 ' For Mac scaling

'==============================================================
' ************************************************************
' * ** VENOM: Visual Enhancement and Neural Optimization     *
' * Module for visual styling - Controls aesthetic mutations *
' ************************************************************
'==============================================================

'===== INITIALIZATION - PREPARING THE VISUAL NEUROTOXINS =====
Public Function VS_Initialize() As Boolean
    ' Prevent stack overflow by checking initialization
    If m_isInitialized Then
        VS_Initialize = True
        Exit Function
    End If
    
    On Error GoTo ErrorHandler
    
    ' Initialize our state
    m_isInitialized = True
    VS_LogMessage "Initializing visual styling..."
    
    ' Initialize color palette - synthesize the visual toxins
    Set m_colorPalette = VS_CreateColorPalette()
    
    ' MAC OPTIMIZATION: Skip dark mode detection on Mac
    ' Just use a fixed value to avoid AppleScript calls that cause freezing
    #If Mac Then
        m_darkModeEnabled = True
        VS_LogMessage "Mac detected: Using fixed dark mode setting (always on)"
        
        ' Initialize Mac processing timer
        VS_ResetMacProcessingTimer
    #Else
        ' Safe access to platform info
        Dim platformInfo As Object
        
        ' Ensure platform has been initialized
        On Error Resume Next
        If Not Application.Run("modPlatform.IsPlatformInitialized") Then
            ' Use Application.Run for cross-module calls on both platforms
            Application.Run "modPlatform.InitializePlatform"
        End If
        On Error GoTo ErrorHandler
        
        ' Get platform info with cross-module compatibility
        On Error Resume Next
        Set platformInfo = Application.Run("modPlatform.GetPlatformInfo")
        
        ' Default value
        m_darkModeEnabled = False
        
        ' Try to get the dark mode setting using appropriate method
        If Not platformInfo Is Nothing Then
            ' For Dictionary (Windows)
            If typeName(platformInfo) = "Dictionary" Then
                If platformInfo.exists("IsInDarkMode") Then
                    m_darkModeEnabled = CBool(platformInfo("IsInDarkMode"))
                End If
            ' For Collection (Mac)
            ElseIf typeName(platformInfo) = "Collection" Then
                ' Use DictExists helper via Application.Run
                On Error Resume Next
                If Application.Run("modPlatform.DictExists", platformInfo, "IsInDarkMode") Then
                    m_darkModeEnabled = CBool(Application.Run("modPlatform.DictGet", platformInfo, "IsInDarkMode"))
                End If
                On Error GoTo ErrorHandler
            End If
        End If
    #End If
    
    VS_LogMessage "Visual neurotoxin synthesis complete - Dark mode: " & m_darkModeEnabled
    
    VS_Initialize = True
    Exit Function
    
ErrorHandler:
    m_isInitialized = False
    VS_LogMessage "Error initializing " & MODULE_NAME & ": " & Err.description, "ERROR"
    VS_Initialize = False
End Function

#If Mac Then
    ' Helper functions for Mac timeout detection
    Private Sub VS_ResetMacProcessingTimer()
        mLastProcessTime = Timer
    End Sub
    
    Private Function VS_MacProcessingTimedOut() As Boolean
        If Timer - mLastProcessTime > (MAC_PROCESS_TIMEOUT_MS / 1000) Then
            VS_MacProcessingTimedOut = True
        Else
            VS_MacProcessingTimedOut = False
        End If
    End Function
#End If

'===== COLOR PALETTE CREATION - SYNTHESIZING THE VISUAL VENOMS =====
Private Function VS_CreateColorPalette() As Object
    Dim palette As Object
    
    On Error Resume Next
    
    ' MAC OPTIMIZATION: Use consistent dictionary approach across platforms
    #If Mac Then
        ' For Mac: Use Collection-based approach
        Set palette = New collection
        Set m_keysList = New collection ' Store keys separately
    #Else
        ' For Windows: Try Scripting.Dictionary
        Set palette = CreateObject("Scripting.Dictionary")
        
        ' Fallback if Dictionary not available
        If Err.Number <> 0 Then
            Set palette = New collection
            Set m_keysList = New collection
            Err.Clear
        End If
    #End If
    
    On Error GoTo ErrorHandler
    
    ' Add toxic color compounds - specialized retinal dissolution agents
    ' Use cross-platform approach for dictionary operations
    #If Mac Then
        ' Mac Collection approach
        VS_AddColorToPalette palette, "NecroticLavender", "#FFF0F5" ' The hue of tissue death
        VS_AddColorToPalette palette, "ToxicRose", "#FFE4E1" ' The color of inflamed flesh
        VS_AddColorToPalette palette, "ParalyticYellow", "#FFFACD" ' The tint of neurotoxic paralysis
        VS_AddColorToPalette palette, "CyanideCyan", "#E0FFFF" ' The shade of respiratory failure
        VS_AddColorToPalette palette, "HemorrhagicPurple", "#E6E6FA" ' The color of bleeding capillaries
        VS_AddColorToPalette palette, "GangreneOrange", "#FFDAB9" ' The hue of tissue decay
        VS_AddColorToPalette palette, "AsphyxiaBlue", "#B0E0E6" ' The tint of oxygen deprivation
        VS_AddColorToPalette palette, "CardiotoxicPink", "#FFB6C1" ' The color of heart trauma
        VS_AddColorToPalette palette, "JaundiceYellow", "#EEE8AA" ' The shade of liver failure
        VS_AddColorToPalette palette, "CadaverGray", "#D3D3D3" ' The hue of lifeless form
        
        ' Keep UI responsive
        DoEvents
    #Else
        ' Windows Dictionary approach
        If typeName(palette) = "Dictionary" Then
            With palette
                .Add "NecroticLavender", "#FFF0F5" ' The hue of tissue death
                .Add "ToxicRose", "#FFE4E1" ' The color of inflamed flesh
                .Add "ParalyticYellow", "#FFFACD" ' The tint of neurotoxic paralysis
                .Add "CyanideCyan", "#E0FFFF" ' The shade of respiratory failure
                .Add "HemorrhagicPurple", "#E6E6FA" ' The color of bleeding capillaries
                .Add "GangreneOrange", "#FFDAB9" ' The hue of tissue decay
                .Add "AsphyxiaBlue", "#B0E0E6" ' The tint of oxygen deprivation
                .Add "CardiotoxicPink", "#FFB6C1" ' The color of heart trauma
                .Add "JaundiceYellow", "#EEE8AA" ' The shade of liver failure
                .Add "CadaverGray", "#D3D3D3" ' The hue of lifeless form
            End With
        Else
            ' Fallback to Collection approach for Windows
            Set m_keysList = New collection
            VS_AddColorToPalette palette, "NecroticLavender", "#FFF0F5"
            VS_AddColorToPalette palette, "ToxicRose", "#FFE4E1"
            VS_AddColorToPalette palette, "ParalyticYellow", "#FFFACD"
            VS_AddColorToPalette palette, "CyanideCyan", "#E0FFFF"
            VS_AddColorToPalette palette, "HemorrhagicPurple", "#E6E6FA"
            VS_AddColorToPalette palette, "GangreneOrange", "#FFDAB9"
            VS_AddColorToPalette palette, "AsphyxiaBlue", "#B0E0E6"
            VS_AddColorToPalette palette, "CardiotoxicPink", "#FFB6C1"
            VS_AddColorToPalette palette, "JaundiceYellow", "#EEE8AA"
            VS_AddColorToPalette palette, "CadaverGray", "#D3D3D3"
        End If
    #End If
    
    VS_LogMessage "Venomous color palette synthesized - 10 psychoactive compounds ready"
    
    Set VS_CreateColorPalette = palette
    Exit Function
    
ErrorHandler:
    VS_LogMessage "Error creating color palette: " & Err.description, "ERROR"
    ' Create a minimal fallback palette with just one color
    Set palette = New collection
    Set m_keysList = New collection
    VS_AddColorToPalette palette, "CadaverGray", "#D3D3D3"
    Set VS_CreateColorPalette = palette
End Function

' Helper function to add items to our palette with cross-platform compatibility
Private Sub VS_AddColorToPalette(palette As Object, key As String, value As String)
    On Error Resume Next
    
    If typeName(palette) = "Dictionary" Then
        palette.Add key, value
    Else
        ' Collection approach
        palette.Add value, key ' Add the value with key as item key
        m_keysList.Add key ' Store key separately for lookup
    End If
    
    On Error GoTo 0
End Sub

' Safe Dictionary getter with cross-platform compatibility
Private Function VS_GetFromPalette(palette As Object, key As String, Optional defaultValue As String = "") As String
    On Error Resume Next
    
    If typeName(palette) = "Dictionary" Then
        If palette.exists(key) Then
            VS_GetFromPalette = palette(key)
        Else
            VS_GetFromPalette = defaultValue
        End If
    Else
        ' Collection approach
        On Error Resume Next
        VS_GetFromPalette = palette(key)
        If Err.Number <> 0 Then
            VS_GetFromPalette = defaultValue
        End If
        On Error GoTo 0
    End If
    
    On Error GoTo 0
End Function

' Safe checker for Dictionary/Collection existence
Private Function VS_KeyExistsInPalette(palette As Object, key As String) As Boolean
    On Error Resume Next
    
    If typeName(palette) = "Dictionary" Then
        VS_KeyExistsInPalette = palette.exists(key)
    Else
        ' Collection approach
        Dim i As Long
        For i = 1 To m_keysList.count
            If m_keysList(i) = key Then
                VS_KeyExistsInPalette = True
                Exit Function
            End If
        Next i
        VS_KeyExistsInPalette = False
    End If
    
    If Err.Number <> 0 Then VS_KeyExistsInPalette = False
    
    On Error GoTo 0
End Function

' Safe logging with cross-platform error handling
Public Sub VS_LogMessage(message As String, Optional level As String = "INFO")
    On Error Resume Next
    
    ' Use Debug.Print for safer logging
    Debug.Print format(Now(), "yyyy-mm-dd hh:mm:ss") & " [" & level & "] " & MODULE_NAME & ": " & message
    
    ' Try to log to error handler if it exists
    On Error Resume Next
    ' Use Application.Run for both platforms to ensure cross-platform compatibility
    #If Mac Then
        Application.Run "ErrorHandler.LogMessage", message, level
    #Else
        ' For Windows - also use Application.Run to avoid direct cross-module calls
        Application.Run "ErrorHandler.LogMessage", message, level
    #End If
    
    On Error GoTo 0
End Sub

' Check if module is initialized
Public Function VS_IsInitialized() As Boolean
    VS_IsInitialized = m_isInitialized
End Function

' Safely get dark mode setting
Public Function VS_IsDarkModeEnabled() As Boolean
    If Not m_isInitialized Then VS_Initialize
    VS_IsDarkModeEnabled = m_darkModeEnabled
End Function

'===== PUBLIC INTERFACES - EXPOSING CAPABILITIES =====
Public Function VS_GetRandomDivider(ByVal title As String) As String
    On Error GoTo ErrorHandler
    
    ' Mac and Windows share the same divider creation with performance optimizations on Mac
    Dim colorKey As String
    Dim colorValue As String
    Dim dividerStyle As Long
    Dim widthCalc As Long
    Dim Div As String
    Dim gLineBreak As String
    
    ' Get line break
    gLineBreak = vbCrLf ' Default line break
    
    ' Try to get line break from global config if available
    On Error Resume Next
    If Not gConfig Is Nothing Then
        If typeName(gConfig) = "Dictionary" Then
            If gConfig.exists("LineBreak") Then
                gLineBreak = gConfig("LineBreak")
            End If
        End If
    End If
    On Error GoTo ErrorHandler
    
    #If Mac Then
        ' Reset Mac processing timer for timeout protection
        VS_ResetMacProcessingTimer
    #End If
    
    ' Select random toxic color - choose your poison
    colorKey = VS_GetRandomColorKey()
    
    ' Handle potential errors in color selection
    If colorKey = "" Then
        colorKey = "CadaverGray"
    End If
    
    ' Get color value with error handling
    colorValue = VS_GetFromPalette(m_colorPalette, colorKey, "#D3D3D3")
    
    ' Select random divider style - varying neurotoxin delivery mechanisms
    Randomize
    dividerStyle = Int(Rnd() * 5) + 1
    
    ' Calculate width for centering - optimize visual infection vector
    widthCalc = 70 - Len(title)
    If widthCalc < 10 Then widthCalc = 10 ' Ensure minimum width
    
    ' Create divider based on style - craft the neural pathway disruptor
    Select Case dividerStyle
        Case 1
            Div = "/*" & String(widthCalc, "-") & "*/" & gLineBreak & _
                 "/* " & title & " */" & gLineBreak & _
                 "/*" & String(widthCalc, "-") & "*/"
        Case 2
            Div = "'*" & String(widthCalc, "*") & "*" & gLineBreak & _
                 "'* " & title & String(widthCalc - Len(title) - 2, " ") & "*" & gLineBreak & _
                 "'*" & String(widthCalc, "*") & "*"
        Case 3
            Div = "'***" & String(widthCalc, "*") & "***" & gLineBreak & _
                 "'** " & title & String(widthCalc - Len(title) - 2, " ") & "**" & gLineBreak & _
                 "'***" & String(widthCalc, "*") & "***"
        Case 4
            Div = "'=== " & title & " " & String(widthCalc - 4, "=") & "===" & gLineBreak & _
                 "'// INJECT VENOM HERE - Subject will experience tissue necrosis" & gLineBreak & _
                 "'=== END " & title & " " & String(widthCalc - 8, "=") & "=="
        Case 5
            Div = "' ** " & title & " " & String(widthCalc - 4, "*") & " **" & gLineBreak & _
                 "' Aaron McCutchins injected venom on " & format(Now(), "mm/dd/yyyy") & gLineBreak & _
                 "' ** Toxin: " & colorKey & " (" & colorValue & ")" & gLineBreak & _
                 "' " & String(widthCalc, "*")
    End Select
    
    #If Mac Then
        ' Check for timeout and add DoEvents to keep UI responsive
        DoEvents
        If VS_MacProcessingTimedOut() Then
            ' Log warning but continue - we're not simplifying the functionality
            VS_LogMessage "Divider generation taking longer than expected on Mac", "WARNING"
            VS_ResetMacProcessingTimer
        End If
    #End If
    
    ' Add color metadata as comment - document the toxin composition
    Div = Div & gLineBreak & "' TOXIN: " & colorKey & " (" & colorValue & ")"
    
    VS_GetRandomDivider = Div
    Exit Function
    
ErrorHandler:
    ' Fallback to basic divider on error - but only as a last resort
    VS_GetRandomDivider = "' === " & title & " ===" & vbCrLf & "' " & format(Now(), "mm/dd/yyyy")
End Function

' Get random color key for variety
Private Function VS_GetRandomColorKey() As String
    On Error GoTo ErrorHandler
    
    ' Default in case of errors
    Dim defaultKey As String
    defaultKey = "CadaverGray"
    
    #If Mac Then
        ' Mac-optimized approach - same functionality with better performance
        If m_keysList Is Nothing Or m_keysList.count = 0 Then
            VS_GetRandomColorKey = defaultKey
            Exit Function
        End If
        
        ' Select random key from our keys collection
        Randomize
        Dim randomIndex As Long
        randomIndex = Int(Rnd() * m_keysList.count) + 1
        
        ' Safely get the key
        On Error Resume Next
        VS_GetRandomColorKey = m_keysList(randomIndex)
        If Err.Number <> 0 Then
            VS_GetRandomColorKey = defaultKey
        End If
    #Else
        ' Windows Dictionary approach
        If typeName(m_colorPalette) = "Dictionary" Then
            Dim keys As Variant
            Dim randomIndex As Long
            
            On Error Resume Next
            keys = m_colorPalette.keys
            
            ' Validate keys array
            If IsArray(keys) Then
                If UBound(keys) >= 0 Then
                    ' Select random key - choose attack vector randomly
                    Randomize
                    randomIndex = Int(Rnd() * (UBound(keys) + 1))
                    VS_GetRandomColorKey = keys(randomIndex)
                Else
                    VS_GetRandomColorKey = defaultKey
                End If
            Else
                VS_GetRandomColorKey = defaultKey
            End If
        Else
            ' Collection approach for Windows fallback
            If m_keysList Is Nothing Or m_keysList.count = 0 Then
                VS_GetRandomColorKey = defaultKey
                Exit Function
            End If
            
            ' Select random key
            Randomize
            randomIndex = Int(Rnd() * m_keysList.count) + 1
            
            ' Safely get the key
            On Error Resume Next
            VS_GetRandomColorKey = m_keysList(randomIndex)
            If Err.Number <> 0 Then
                VS_GetRandomColorKey = defaultKey
            End If
        End If
    #End If
    
    ' Final safety check
    If VS_GetRandomColorKey = "" Then
        VS_GetRandomColorKey = defaultKey
    End If
    
    Exit Function
    
ErrorHandler:
    VS_GetRandomColorKey = defaultKey
End Function

' Apply form styles with cross-platform compatibility
Public Sub VS_ApplyFormStyle(ByRef frm As Object, ByVal platform As String)
    On Error GoTo ErrorHandler
    
    ' Make sure we're initialized
    If Not m_isInitialized Then VS_Initialize
    
    #If Mac Then
        ' Prevent reentrant processing on Mac
        If mIsMacProcessing Then Exit Sub
        mIsMacProcessing = True
        VS_ResetMacProcessingTimer
    #End If
    
    ' Apply appropriate visual toxin based on mode - choose light or dark venom
    If m_darkModeEnabled Then
        VS_ApplyDarkModeToForm frm
    Else
        VS_ApplyLightModeToForm frm
    End If
    
    ' Apply platform-specific adjustments - tailor toxin for host species
    If platform = "Mac" Then
        VS_ScaleFormForMac frm
    Else
        VS_OptimizeFormForWindows frm
    End If
    
    #If Mac Then
        ' Clear processing flag
        mIsMacProcessing = False
    #End If
    
    Exit Sub
    
ErrorHandler:
    #If Mac Then
        mIsMacProcessing = False
    #End If
    VS_LogMessage "Failed to apply form style: " & Err.description, "ERROR"
End Sub

' Dark mode form styling
Public Sub VS_ApplyDarkModeToForm(ByRef frm As Object)
    On Error Resume Next
    
    ' Form background - primary infection surface
    frm.BackColor = RGB(32, 32, 32)
    frm.ForeColor = RGB(255, 255, 255)
    
    ' Apply to all controls - spread the infection to all cells
    #If Mac Then
        ' Process controls in batches on Mac with timeout protection
        Dim ctrl As Object
        Dim processedCount As Long
        
        For Each ctrl In frm.Controls
            ' Process control
            VS_ApplyDarkModeToControl ctrl
            
            ' Increment counter
            processedCount = processedCount + 1
            
            ' Check for batch completion
            If processedCount Mod MAC_CONTROL_BATCH_SIZE = 0 Then
                DoEvents ' Keep UI responsive
                
                ' Check for timeout
                If VS_MacProcessingTimedOut() Then
                    VS_LogMessage "Control styling taking longer than expected, ensuring UI responsiveness", "WARNING"
                    VS_ResetMacProcessingTimer
                End If
            End If
        Next ctrl
        
        ' Final UI refresh
        DoEvents
    #Else
        ' Windows can process all controls at once
        Dim ctrl As Object
        For Each ctrl In frm.Controls
            VS_ApplyDarkModeToControl ctrl
        Next ctrl
    #End If
    
    On Error GoTo 0
End Sub

' Apply dark mode to individual controls
Public Sub VS_ApplyDarkModeToControl(ByRef ctrl As Object)
    On Error Resume Next
    
    ' Apply appropriate styling based on control type - target specific cellular structures
    Select Case typeName(ctrl)
        Case "TextBox", "ComboBox", "ListBox"
            ' Input controls - data entry infection vectors
            ctrl.BackColor = RGB(64, 64, 64)
            ctrl.ForeColor = RGB(255, 255, 255)
            ctrl.BorderColor = RGB(128, 128, 128)
            
        Case "CommandButton"
            ' Action controls - trigger mechanisms for venom release
            ctrl.BackColor = RGB(48, 48, 48)
            ctrl.ForeColor = RGB(255, 255, 255)
            
        Case "Frame", "Label"
            ' Container controls - toxin containment vessels
            ctrl.BackColor = RGB(32, 32, 32)
            ctrl.ForeColor = RGB(200, 200, 200)
            
        Case "CheckBox", "OptionButton"
            ' Selection controls - binary infection switches
            ctrl.BackColor = RGB(32, 32, 32)
            ctrl.ForeColor = RGB(255, 255, 255)
    End Select
    
    On Error GoTo 0
End Sub

' Light mode form styling
Public Sub VS_ApplyLightModeToForm(ByRef frm As Object)
    On Error Resume Next
    
    ' Form background - deceptively innocuous infection surface
    frm.BackColor = RGB(240, 240, 240)
    frm.ForeColor = RGB(0, 0, 0)
    
    ' Apply to all controls - spread the subtle infection to all cells
    #If Mac Then
        ' Process controls in batches on Mac with timeout protection
        Dim ctrl As Object
        Dim processedCount As Long
        
        For Each ctrl In frm.Controls
            ' Process control
            VS_ApplyLightModeToControl ctrl
            
            ' Increment counter
            processedCount = processedCount + 1
            
            ' Check for batch completion
            If processedCount Mod MAC_CONTROL_BATCH_SIZE = 0 Then
                DoEvents ' Keep UI responsive
                
                ' Check for timeout
                If VS_MacProcessingTimedOut() Then
                    VS_LogMessage "Control styling taking longer than expected, ensuring UI responsiveness", "WARNING"
                    VS_ResetMacProcessingTimer
                End If
            End If
        Next ctrl
        
        ' Final UI refresh
        DoEvents
    #Else
        ' Windows can process all controls at once
        Dim ctrl As Object
        For Each ctrl In frm.Controls
            VS_ApplyLightModeToControl ctrl
        Next ctrl
    #End If
    
    On Error GoTo 0
End Sub

' Apply light mode to individual controls
Public Sub VS_ApplyLightModeToControl(ByRef ctrl As Object)
    On Error Resume Next
    
    ' Apply appropriate styling based on control type - subtle cellular modifications
    Select Case typeName(ctrl)
        Case "TextBox", "ComboBox", "ListBox"
            ' Input controls - deceptively clean infection vectors
            ctrl.BackColor = RGB(255, 255, 255)
            ctrl.ForeColor = RGB(0, 0, 0)
            ctrl.BorderColor = RGB(160, 160, 160)
            
        Case "CommandButton"
            ' Action controls - camouflaged trigger mechanisms
            ctrl.BackColor = RGB(225, 225, 225)
            ctrl.ForeColor = RGB(0, 0, 0)
            
        Case "Frame", "Label"
            ' Container controls - seemingly harmless vessels
            ctrl.BackColor = RGB(240, 240, 240)
            ctrl.ForeColor = RGB(0, 0, 0)
            
        Case "CheckBox", "OptionButton"
            ' Selection controls - disguised infection switches
            ctrl.BackColor = RGB(240, 240, 240)
            ctrl.ForeColor = RGB(0, 0, 0)
    End Select
    
    On Error GoTo 0
End Sub

' Scale form for Mac
Private Sub VS_ScaleFormForMac(ByRef frm As Object)
    On Error Resume Next
    
    #If Mac Then
        ' Prevent reentrant processing on Mac
        If mIsMacProcessing Then Exit Sub
        mIsMacProcessing = True
        VS_ResetMacProcessingTimer
    #End If
    
    ' Apply Mac scaling factor - adjust toxin for Apple neural pathways
    frm.width = frm.width * USER_FORM_SCALE_FACTOR
    frm.height = frm.height * USER_FORM_SCALE_FACTOR
    
    ' Scale all controls - resize infection vectors for Mac tissue
    #If Mac Then
        ' Process controls in batches on Mac with timeout protection
        Dim ctrl As Object
        Dim processedCount As Long
        
        For Each ctrl In frm.Controls
            ' Process control
            ctrl.Left = ctrl.Left * USER_FORM_SCALE_FACTOR
            ctrl.Top = ctrl.Top * USER_FORM_SCALE_FACTOR
            ctrl.width = ctrl.width * USER_FORM_SCALE_FACTOR
            ctrl.height = ctrl.height * USER_FORM_SCALE_FACTOR
            
            ' Increment counter
            processedCount = processedCount + 1
            
            ' Check for batch completion
            If processedCount Mod MAC_CONTROL_BATCH_SIZE = 0 Then
                DoEvents ' Keep UI responsive
                
                ' Check for timeout
                If VS_MacProcessingTimedOut() Then
                    VS_LogMessage "Mac scaling taking longer than expected, ensuring UI responsiveness", "WARNING"
                    VS_ResetMacProcessingTimer
                End If
            End If
        Next ctrl
        
        ' Final UI refresh
        DoEvents
    #Else
        ' Windows can process all controls at once
        Dim ctrl As Object
        For Each ctrl In frm.Controls
            ctrl.Left = ctrl.Left * USER_FORM_SCALE_FACTOR
            ctrl.Top = ctrl.Top * USER_FORM_SCALE_FACTOR
            ctrl.width = ctrl.width * USER_FORM_SCALE_FACTOR
            ctrl.height = ctrl.height * USER_FORM_SCALE_FACTOR
        Next ctrl
    #End If
    
    #If Mac Then
        ' Clear processing flag
        mIsMacProcessing = False
    #End If
    
    On Error GoTo 0
End Sub

' Optimize form for Windows
Private Sub VS_OptimizeFormForWindows(ByRef frm As Object)
    On Error Resume Next
    
    ' Windows-specific optimizations - specialized Windows infection vectors
    frm.Tag = "Windows"
    
    ' Apply Windows font - font-based neurotoxin for Microsoft tissue
    Dim ctrl As Object
    For Each ctrl In frm.Controls
        If Not ctrl Is Nothing Then
            If typeName(ctrl) <> "Image" Then ' Skip Image controls that might not have Font property
                On Error Resume Next
                If Not ctrl.Font Is Nothing Then
                    ctrl.Font.name = VS_GetPlatformFont("Segoe UI", "Helvetica")
                End If
                On Error Resume Next
            End If
        End If
    Next ctrl
    
    On Error GoTo 0
End Sub

' Helper function to get platform-specific font
Private Function VS_GetPlatformFont(winFont As String, macFont As String) As String
    #If Mac Then
        VS_GetPlatformFont = macFont
    #Else
        ' Check if we know our platform
        Dim gIsMac As Boolean
        gIsMac = False
        
        ' Try to get platform info safely
        On Error Resume Next
        If Not gConfig Is Nothing Then
            If typeName(gConfig) = "Dictionary" Then
                If gConfig.exists("IsMac") Then
                    gIsMac = CBool(gConfig("IsMac"))
                End If
            End If
        End If
        On Error GoTo 0
        
        If gIsMac Then
            VS_GetPlatformFont = macFont
        Else
            VS_GetPlatformFont = winFont
        End If
    #End If
End Function

' Public method to toggle dark mode
Public Sub VS_ToggleDarkMode()
    If Not m_isInitialized Then VS_Initialize
    
    ' Toggle the mode
    m_darkModeEnabled = Not m_darkModeEnabled
    
    ' Store in config if available
    On Error Resume Next
    If Not gConfig Is Nothing Then
        If typeName(gConfig) = "Dictionary" Then
            gConfig("IsDarkMode") = m_darkModeEnabled
        End If
    End If
    
    VS_LogMessage "Visual toxin variant toggled - Dark mode: " & m_darkModeEnabled
End Sub

' Insert a section divider at the current cursor position
Public Sub VS_InsertSectionDivider(ByVal sectionTitle As String)
    On Error Resume Next
    
    Dim divider As String
    Dim selection As Object
    
    ' Create random divider - prepare the neurotoxin
    divider = VS_GetRandomDivider(sectionTitle)
    
    ' Get line break
    Dim gLineBreak As String
    gLineBreak = vbCrLf ' Default line break
    
    ' Try to get line break from global config if available
    If Not gConfig Is Nothing Then
        If typeName(gConfig) = "Dictionary" Then
            If gConfig.exists("LineBreak") Then
                gLineBreak = gConfig("LineBreak")
            End If
        End If
    End If
    
    ' Insert at cursor position - inject at infection site
    Set selection = Application.selection
    selection.TypeText divider & gLineBreak
    
    If Err.Number <> 0 Then
        ' If Selection fails, use Debug.Print as fallback
        Debug.Print divider
        Debug.Print "Primary injection failed, toxin released via alternate pathway"
    End If
    
    On Error GoTo 0
End Sub

' Create text with a divider for output
Public Function VS_CreateTextWithDivider(ByVal title As String, ByVal content As String) As String
    On Error Resume Next
    
    Dim divider As String
    
    ' Create divider - prepare the visual containment field
    divider = VS_GetRandomDivider(title)
    
    ' Get line break
    Dim gLineBreak As String
    gLineBreak = vbCrLf ' Default line break
    
    ' Try to get line break from global config if available
    If Not gConfig Is Nothing Then
        If typeName(gConfig) = "Dictionary" Then
            If gConfig.exists("LineBreak") Then
                gLineBreak = gConfig("LineBreak")
            End If
        End If
    End If
    
    ' Wrap content with divider - encase the victim in toxic boundaries
    VS_CreateTextWithDivider = divider & gLineBreak & gLineBreak & content & gLineBreak & gLineBreak
    
    On Error GoTo 0
End Function
'============================================================================ = 
' END MODULE: modVisualStyles 
'============================================================================ = 

‘********************************************************* 
‘‘***************** ‘coVdEeNcOoMde ‘******************     
‘********************************************************* 

'=============================================================================
' BEGIN MODULE: modCodeFormatter
'=============================================================================


'==============================================================
'==============
' Code Formatter Module - Dark Theme Implementation
' Version: 2.3 Enhanced - Cross-Platform Compatible
' This code is the VBA equivalent of putting on sweatpants - everyone feels better but nobody's impressed.
' Updated by: Aaron McCutchins on 2025-05-16
' Mac Optimization added: 2025-05-13
' Cross-Platform Dependencies Fix: 2025-05-16
'==============================================================
'==============
Option Explicit

' Color constants for dark theme formatting - expose publicly to allow theme rotator access
Public COLOR_BACKGROUND As Long
Public COLOR_NORMAL_TEXT As Long
Public COLOR_KEYWORDS As Long
Public COLOR_COMMENTS As Long
Public COLOR_STRINGS As Long
Public COLOR_NUMBERS As Long
Public COLOR_OPERATORS As Long

' Collection of possible section divider colors (bright, high-contrast colors)
Private mSectionColors As collection
Private mKeywordsList As collection
Private mOperatorsList As collection
Private mIsInitialized As Boolean
Private mThemeRotationEnabled As Boolean

' Mac optimization settings
Private mIsMac As Boolean
Private mMaxChunkSize As Long
Private mIsProcessingChunk As Boolean
Private mLastProcessTime As Double
Private Const MAX_PROCESSING_TIME As Double = 5 ' Increased from 2 to 5 seconds for Mac

' Dependency tracking
Private mExternalModulesAvailable As Boolean
Private mMissingDependencies As collection

' Collection-based theme storage (cross-platform compatible)
Private mThemes As collection
Private mCurrentThemeIndex As Long
Private mThemeSkipCount As Long
Private Const MAX_THEME_SKIPS As Long = 3 ' Allow a few skips before forcing rotation

' Initialize color constants with default values
Public Sub InitializeColorConstants()
 ' Use Word's built-in constants where possible
 COLOR_BACKGROUND = wdColorBlack ' Black
 COLOR_NORMAL_TEXT = wdColorYellow ' Yellow
 COLOR_KEYWORDS = wdColorBlue ' Blue
 COLOR_COMMENTS = wdColorBrightGreen ' Green
 COLOR_STRINGS = wdColorPink ' Light Red
 COLOR_NUMBERS = wdColorWhite ' White
 COLOR_OPERATORS = wdColorYellow ' Yellow
End Sub

' Initialize the code formatter module - renamed as requested
Public Sub InitializeCodeFormatter()
 On Error GoTo ErrorHandler
 
 ' Check if already initialized to prevent redundant operations
 If mIsInitialized Then Exit Sub
 
 ' Create dependency tracking collection
 Set mMissingDependencies = New collection
 
 ' Detect platform
 #If Mac Then
 mIsMac = True
 mMaxChunkSize = 5000 ' Increased from 1000 to 5000 for better Mac performance
 #Else
 mIsMac = False
 mMaxChunkSize = 0 ' No chunking on Windows
 #End If
 
 ' Initialize color constants first
 InitializeColorConstants
 
 ' Initialize collection of section divider colors
 Set mSectionColors = New collection
 mSectionColors.Add wdColorViolet ' Purple
 mSectionColors.Add wdColorBrightGreen ' Neon Green
 mSectionColors.Add wdColorTurquoise ' Electric Cyan
 mSectionColors.Add wdColorPink ' Pink
 mSectionColors.Add wdColorOrange ' Vibrant Orange
 mSectionColors.Add wdColorBlue ' Blue
 mSectionColors.Add wdColorRose ' Light Purple
 mSectionColors.Add wdColorRed ' Red
 mSectionColors.Add wdColorGold ' Gold
 
 ' Initialize theme collection - cross-platform compatible
 InitializeThemeCollection
 
 ' Initialize collection of VBA keywords
 Set mKeywordsList = New collection
 
 ' Use the same comprehensive keyword list for both platforms
 ' VBA keywords - full set for all platforms
 AddKeywords Array("Dim", "As", "Set", "Let", "Public", "Private", "Friend", "Static", _
 "Const", "Enum", "Type", "Option", "Explicit", "Sub", "Function", "Property", _
 "Get", "Let", "Set", "If", "Then", "Else", "ElseIf", "End", "Select", "Case", _
 "For", "To", "Step", "Next", "Do", "While", "Wend", "Loop", "Until", "With", _
 "Exit", "On", "Error", "GoTo", "Resume", "Call", "New", "ReDim", "Preserve", _
 "Boolean", "Integer", "Long", "Single", "Double", "String", "Currency", "Date", _
 "Variant", "Object", "Byte", "RaiseEvent", "AddressOf", "True", "False", "Nothing", _
 "Null", "Empty", "CLng", "CBool", "CDate", "CInt", "CSng", "CStr", "CCur", _
 "ByVal", "ByRef", "Optional", "ParamArray", "Declare", "PtrSafe", "Class", _
 "Implements", "Module", "CreateObject", "GetObject", "Is", "TypeOf", "Like", _
 "Debug", "Print", "VbCrLf", "vbNewLine", "vbTab", "MsgBox", "InputBox")
 
 ' Initialize operators list - use the same operators for all platforms
 Set mOperatorsList = New collection
 AddOperators Array("+", "-", "*", "/", "\", "^", "&", "=", "<", ">", "<=", ">=", "<>", "And", _
 "Or", "Not", "Xor", "Eqv", "Imp", "Mod", "In")
 
 ' Initialize theme rotation settings
 mThemeRotationEnabled = True ' Enable by default - no platform restrictions
 mCurrentThemeIndex = 1
 mThemeSkipCount = 0
 
 ' Check for availability of external modules (safely)
 CheckExternalModuleAvailability
 
 ' Initialize enhanced dividers - safely for all platforms
 On Error Resume Next
 If Not mIsInitialized And mExternalModulesAvailable Then
 ' Initialize ThemeManager on all platforms if available
 If SafeFunctionExists("InitializeThemeManager") Then
   Application.Run "InitializeThemeManager"
 End If
 End If
 On Error GoTo ErrorHandler
 
 mIsInitialized = True
 
 ' Log initialization with fallback if LogMessage unavailable
 SafeLogMessage "Code formatter initialized with " & mSectionColors.count & " section divider colors"
 
 Exit Sub
 
ErrorHandler:
 ' Handle initialization errors with fallback if LogMessage unavailable
 SafeLogMessage "Error initializing code formatter: " & Err.Number & " - " & Err.description, "ERROR"
 
 ' Ensure we still mark as initialized to prevent repeated attempts
 mIsInitialized = True
End Sub

' Initialize theme collection - stores themes for both platforms
Private Sub InitializeThemeCollection()
 ' Create collection to store themes
 Set mThemes = New collection
 
 ' Add Venom theme - dark with neon accents
 Dim venomTheme As New collection
 venomTheme.Add wdColorBlack, "Background"          ' Black background
 venomTheme.Add wdColorLime, "NormalText"           ' Toxic green text
 venomTheme.Add wdColorTurquoise, "Keywords"        ' Cyan keywords
 venomTheme.Add wdColorDarkGreen, "Comments"        ' Dark green comments
 venomTheme.Add wdColorLightOrange, "Strings"       ' Light orange strings
 venomTheme.Add wdColorWhite, "Numbers"             ' White numbers
 venomTheme.Add wdColorLime, "Operators"            ' Lime operators
 venomTheme.Add wdColorPink, "SectionDividers"      ' Pink section dividers
 venomTheme.Add "Venom", "Name"                     ' Theme name
 mThemes.Add venomTheme, "Venom"
 
 ' Add Midnight theme - dark blue with cool accents
 Dim midnightTheme As New collection
 midnightTheme.Add wdColorDarkBlue, "Background"    ' Dark blue background
 midnightTheme.Add wdColorLightBlue, "NormalText"   ' Light blue text
 midnightTheme.Add wdColorWhite, "Keywords"         ' White keywords
 midnightTheme.Add wdColorGray50, "Comments"        ' Gray comments
 midnightTheme.Add wdColorSkyBlue, "Strings"        ' Sky blue strings
 midnightTheme.Add wdColorLightYellow, "Numbers"    ' Light yellow numbers
 midnightTheme.Add wdColorLightBlue, "Operators"    ' Light blue operators
 midnightTheme.Add wdColorTurquoise, "SectionDividers" ' Turquoise section dividers
 midnightTheme.Add "Midnight", "Name"               ' Theme name
 mThemes.Add midnightTheme, "Midnight"
 
 ' Add Inferno theme - dark red with hot accents
 Dim infernoTheme As New collection
 infernoTheme.Add wdColorDarkRed, "Background"      ' Dark red background
 infernoTheme.Add wdColorOrange, "NormalText"       ' Orange text
 infernoTheme.Add wdColorYellow, "Keywords"         ' Yellow keywords
 infernoTheme.Add wdColorBrown, "Comments"          ' Brown comments
 infernoTheme.Add wdColorLightYellow, "Strings"     ' Light yellow strings
 infernoTheme.Add wdColorWhite, "Numbers"           ' White numbers
 infernoTheme.Add wdColorOrange, "Operators"        ' Orange operators
 infernoTheme.Add wdColorYellow, "SectionDividers"  ' Yellow section dividers
 infernoTheme.Add "Inferno", "Name"                 ' Theme name
 mThemes.Add infernoTheme, "Inferno"
 
 ' Add Toxin theme - green with dark accents
 Dim toxinTheme As New collection
 toxinTheme.Add wdColorDarkGreen, "Background"      ' Dark green background
 toxinTheme.Add wdColorBrightGreen, "NormalText"    ' Bright green text
 toxinTheme.Add wdColorLime, "Keywords"             ' Lime keywords
 toxinTheme.Add wdColorGray40, "Comments"           ' Dark gray comments
 toxinTheme.Add wdColorLightYellow, "Strings"       ' Light yellow strings
 toxinTheme.Add wdColorWhite, "Numbers"             ' White numbers
 toxinTheme.Add wdColorBrightGreen, "Operators"     ' Bright green operators
 toxinTheme.Add wdColorYellow, "SectionDividers"    ' Yellow section dividers
 toxinTheme.Add "Toxin", "Name"                     ' Theme name
 mThemes.Add toxinTheme, "Toxin"
 
 ' Add Neural theme - violet with neon blue accents
 Dim neuralTheme As New collection
 neuralTheme.Add wdColorIndigo, "Background"        ' Indigo background
 neuralTheme.Add wdColorPink, "NormalText"          ' Pink text
 neuralTheme.Add wdColorBrightGreen, "Keywords"     ' Electric blue keywords
 neuralTheme.Add wdColorGray50, "Comments"          ' Gray comments
 neuralTheme.Add wdColorLavender, "Strings"         ' Lavender strings
 neuralTheme.Add wdColorWhite, "Numbers"            ' White numbers
 neuralTheme.Add wdColorPink, "Operators"           ' Pink operators
 neuralTheme.Add wdColorTurquoise, "SectionDividers" ' Turquoise section dividers
 neuralTheme.Add "Neural", "Name"                   ' Theme name
 mThemes.Add neuralTheme, "Neural"
 
 ' Add Shadow theme - black with gray accents
 Dim shadowTheme As New collection
 shadowTheme.Add wdColorBlack, "Background"         ' Black background
 shadowTheme.Add wdColorGray30, "NormalText"        ' Gray text
 shadowTheme.Add wdColorGray25, "Keywords"          ' Light gray keywords
 shadowTheme.Add wdColorGray50, "Comments"          ' Dark gray comments
 shadowTheme.Add wdColorGray25, "Strings"           ' Light gray strings
 shadowTheme.Add wdColorWhite, "Numbers"            ' White numbers
 shadowTheme.Add wdColorGray30, "Operators"         ' Gray operators
 shadowTheme.Add wdColorGray15, "SectionDividers"   ' Very light gray section dividers
 shadowTheme.Add "Shadow", "Name"                   ' Theme name
 mThemes.Add shadowTheme, "Shadow"

 ' Log theme initialization
 SafeLogMessage "ThemeRotator [INFO]: Theme rotator initialized with " & mThemes.count & " venom strains ready for injection"
End Sub

' Helper function to check if a function exists before calling it
Private Function FunctionExists(functionName As String) As Boolean
 On Error Resume Next
 FunctionExists = False
 
 ' Try to get the VBA function info
 Dim dummyVal As Variant
 dummyVal = Application.Run(functionName)
 
 If Err.Number = 0 Or Err.Number = 449 Then
   ' 449 = "Argument not optional" - means function exists but needs arguments
   FunctionExists = True
 End If
 
 On Error GoTo 0
End Function

' Public version of FunctionExists for testing
Public Function SafeFunctionExists(functionName As String) As Boolean
 SafeFunctionExists = FunctionExists(functionName)
End Function

' Check for availability of external modules
Private Sub CheckExternalModuleAvailability()
 On Error Resume Next
 
 ' Clear the collection first
 Set mMissingDependencies = New collection
 
 ' Define key dependencies
 Dim dependencies As Variant
 dependencies = Array("LogMessage", "InitializeThemeManager", "ThemeRotator_Initialize", _
 "EnhancedDividers_CreateSectionDivider", "CodeAnalysis_GetCurrentModuleName")
 
 ' Check each dependency
 Dim i As Long
 Dim missingCount As Long
 Dim depName As String ' Add this to fix the type mismatch
 
 missingCount = 0
  
 For i = LBound(dependencies) To UBound(dependencies)
   ' Convert to String explicitly to avoid ByRef type mismatch
   depName = CStr(dependencies(i))
   
   If Not FunctionExists(depName) Then
     ' Track missing dependency
     On Error Resume Next
     mMissingDependencies.Add depName, depName
     If Err.Number = 0 Then
       missingCount = missingCount + 1
     End If
     On Error GoTo 0
   End If
 Next i
 
 ' Set flag based on results
 mExternalModulesAvailable = (missingCount = 0)
 
 On Error GoTo 0
End Sub

' Safe wrapper for LogMessage - falls back to Debug.Print if LogMessage unavailable
Private Sub SafeLogMessage(message As String, Optional logLevel As String = "INFO")
 On Error Resume Next
 
 If FunctionExists("LogMessage") Then
   Application.Run "LogMessage", message, logLevel
 Else
   ' Fallback to Debug.Print in the immediate window
   Debug.Print format(Now, "yyyy-mm-dd hh:mm:ss") & " [" & logLevel & "] " & message
 End If
 
 On Error GoTo 0
End Sub

' Helper to safely add keywords to collection
Private Sub AddKeywords(keywordsArray As Variant)
 On Error Resume Next
 
 Dim keyword As Variant
 For Each keyword In keywordsArray
   ' Skip duplicates
   mKeywordsList.Add CStr(keyword), CStr(keyword)
   If Err.Number <> 0 Then
     Err.Clear
   End If
 Next keyword
 
 On Error GoTo 0
End Sub

' Helper to safely add operators to collection
Private Sub AddOperators(operatorsArray As Variant)
 On Error Resume Next
 
 Dim operator As Variant
 For Each operator In operatorsArray
   ' Skip duplicates
   mOperatorsList.Add CStr(operator), CStr(operator)
   If Err.Number <> 0 Then
     Err.Clear
   End If
 Next operator
 
 On Error GoTo 0
End Sub

' Set color scheme with custom colors - allows external theme systems to modify colors
Public Sub SetColorScheme(bgColor As Long, textColor As Long, _
 keywordColor As Long, commentColor As Long, _
 stringColor As Long, numberColor As Long, _
 operatorColor As Long, sectionColor As Long)
 ' Update the color constants
 COLOR_BACKGROUND = bgColor
 COLOR_NORMAL_TEXT = textColor
 COLOR_KEYWORDS = keywordColor
 COLOR_COMMENTS = commentColor
 COLOR_STRINGS = stringColor
 COLOR_NUMBERS = numberColor
 COLOR_OPERATORS = operatorColor
 
 ' Update first section color in collection to match
 If Not mSectionColors Is Nothing And mSectionColors.count > 0 Then
   ' Replace the first color
   mSectionColors.Remove 1
   mSectionColors.Add sectionColor, , 1
 End If
 
 SafeLogMessage "Color scheme updated with custom colors"
End Sub

' Update formatter with new theme colors from ThemeRotator using collection-based approach
Public Sub UpdateFormatterWithRotatingThemes()
 On Error GoTo ErrorHandler
 
 ' Skip if external modules aren't available
 If Not mExternalModulesAvailable Then
   Exit Sub
 End If
 
 ' Get current theme from our collection (no Dictionary needed)
 Dim currentTheme As collection
 Set currentTheme = mThemes(mCurrentThemeIndex)
 
 ' Apply the theme colors to module constants
 SetColorScheme _
   currentTheme("Background"), _
   currentTheme("NormalText"), _
   currentTheme("Keywords"), _
   currentTheme("Comments"), _
   currentTheme("Strings"), _
   currentTheme("Numbers"), _
   currentTheme("Operators"), _
   currentTheme("SectionDividers")
 
 ' Apply to active document if applicable - works on both platforms
 On Error Resume Next
 ApplyThemeColors _
   currentTheme("Background"), _
   currentTheme("NormalText"), _
   currentTheme("Keywords"), _
   currentTheme("Comments"), _
   currentTheme("Strings"), _
   currentTheme("Numbers")
 On Error GoTo ErrorHandler
 
 ' Log theme update
 SafeLogMessage "Theme colors updated to " & currentTheme("Name") & " theme"
 
 Exit Sub
 
ErrorHandler:
 ' Log error
 SafeLogMessage "Error updating formatter with rotating themes: " & Err.Number & " - " & Err.description, "ERROR"
End Sub

' Apply theme colors to active document - cross-platform safe
Private Sub ApplyThemeColors(bgColor As Long, textColor As Long, _
 keywordColor As Long, commentColor As Long, _
 stringColor As Long, numberColor As Long)
 On Error GoTo ErrorHandler
 
 ' Format the document using the provided colors
 Dim doc As Document
 Set doc = ThisDocument
 
 ' Split content into lines for processing
 Dim content As String
 content = doc.content.text
 
 ' Create a working document to process the text
 Dim tempDoc As Document
 
 ' Use more robust document creation with error handling
 On Error Resume Next
 Set tempDoc = Documents.Add(Visible:=False)
 If Err.Number <> 0 Then
   SafeLogMessage "Error creating temporary document: " & Err.Number & " - " & Err.description, "ERROR"
   Exit Sub
 End If
 On Error GoTo ErrorHandler
 
 ' Set the content of the temp document
 tempDoc.content.text = content
 
 ' Process in smaller chunks with timeouts for Mac
 Dim paraCount As Long
 paraCount = 0
 
 ' Reset the timer
 mLastProcessTime = Timer
 
 ' Select entire document for common formatting
 With tempDoc.content
   .Font.name = GetPlatformFont("Consolas", "Courier New")
   .Font.Size = 10
   .Font.Color = textColor
   .Shading.BackgroundPatternColor = bgColor
 End With
 
 ' Now process each paragraph with chunking if needed
 For Each para In tempDoc.Paragraphs
   ' Count paragraphs processed
   paraCount = paraCount + 1
   
   ' Basic formatting for this paragraph
   With para.Range
     If Left(Trim(.text), 1) = "'" Then
       .Font.Color = commentColor
     End If
   End With
   
   ' Allow UI to refresh periodically and check timeout
   If paraCount Mod 20 = 0 Then
     DoEvents
     
     ' Check for timeout on Mac
     #If Mac Then
       If Timer - mLastProcessTime > MAX_PROCESSING_TIME Then
         SafeLogMessage "Formatting timeout - completing basic formatting only", "WARNING"
         Exit For
       End If
     #End If
   End If
 Next para
 
 ' Get the formatted content
 Dim formattedText As String
 formattedText = tempDoc.content.text
 
 ' Close the temp document
 On Error Resume Next
 tempDoc.Close SaveChanges:=wdDoNotSaveChanges
 On Error GoTo ErrorHandler
 
 ' Update the original document
 doc.content.text = formattedText
 
 Exit Sub
 
ErrorHandler:
 ' Log error
 SafeLogMessage "Error applying theme colors: " & Err.Number & " - " & Err.description, "ERROR"
 
 ' Close temp document if it exists
 On Error Resume Next
 If Not tempDoc Is Nothing Then tempDoc.Close SaveChanges:=wdDoNotSaveChanges
 On Error GoTo 0
End Sub

' Format a line with custom theme colors - cross-platform compatible
Private Sub FormatCodeLine(lineRange As Range, lineText As String)
 On Error Resume Next
 
 ' Apply background color to entire line
 lineRange.Shading.BackgroundPatternColor = COLOR_BACKGROUND
 
 ' Default text color
 lineRange.Font.Color = COLOR_NORMAL_TEXT
 
 ' Check for comment line
 If Left(Trim(lineText), 1) = "'" Then
   lineRange.Font.Color = COLOR_COMMENTS
   Exit Sub
 End If
 
 ' For Mac, we'll stop here to ensure basic formatting works quickly
 #If Mac Then
   ' On Mac, we'll do simplified processing, but keep the theme colors
   ' Rather than skipping formatting, we're just doing less detailed processing
   Exit Sub
 #End If
 
 ' Additional formatting - only on Windows or smaller files on Mac
 Dim commentPos As Long
 commentPos = InStr(1, lineText, "'")
 
 If commentPos > 0 Then
   ' Format the comment part
   With lineRange.duplicate
     .SetRange lineRange.Start + commentPos - 1, lineRange.End
     .Font.Color = COLOR_COMMENTS
   End With
 End If
 
 ' Get keywords in line and format
 Dim wordStart As Long, wordEnd As Long
 Dim word As String
 Dim i As Long, charIdx As Long
 
 For i = 1 To Len(lineText)
   ' Check if character starts a word
   If IsAlphaNumeric(Mid(lineText, i, 1)) Then
     wordStart = i
     
     ' Find end of word
     For charIdx = i + 1 To Len(lineText)
       If Not IsAlphaNumeric(Mid(lineText, charIdx, 1)) Then
         Exit For
       End If
     Next charIdx
     
     wordEnd = charIdx - 1
     word = Mid(lineText, wordStart, wordEnd - wordStart + 1)
     
     ' Check if it's a keyword
     If IsKeyword(word) Then
       ' Format keyword
       With lineRange.duplicate
         .SetRange lineRange.Start + wordStart - 1, lineRange.Start + wordEnd
         .Font.Color = COLOR_KEYWORDS
       End With
     End If
     
     ' Skip to end of word
     i = wordEnd
   End If
 Next i
End Sub

' Check if a line is a section divider
Private Function IsSectionDivider(line As String) As Boolean
 ' Check for lines with multiple equal signs or other section markers
 If InStr(1, line, "====") > 0 Or _
   InStr(1, line, "----") > 0 Or _
   (InStr(1, line, "'") > 0 And _
   (InStr(1, LCase(line), "module") > 0 Or _
   InStr(1, LCase(line), "section") > 0 Or _
   InStr(1, LCase(line), "class") > 0)) Then
   IsSectionDivider = True
 Else
   IsSectionDivider = False
 End If
End Function

' Get a random color from the section colors collection
Private Function GetRandomSectionColor() As Long
 Dim randomIndex As Long
 randomIndex = Int((mSectionColors.count * Rnd) + 1)
 GetRandomSectionColor = mSectionColors(randomIndex)
End Function

' Check if a string is a VBA keyword
Private Function IsKeyword(word As String) As Boolean
 On Error Resume Next
 Dim dummy As Variant
 dummy = mKeywordsList(word)
 IsKeyword = (Err.Number = 0)
 On Error GoTo 0
End Function

' Check if a character is an operator
Private Function IsOperator(char As String) As Boolean
 On Error Resume Next
 Dim dummy As Variant
 dummy = mOperatorsList(char)
 IsOperator = (Err.Number = 0)
 On Error GoTo 0
End Function

' Check if character is alphanumeric
Private Function IsAlphaNumeric(char As String) As Boolean
 IsAlphaNumeric = (char >= "A" And char <= "Z") Or _
   (char >= "a" And char <= "z") Or _
   (char >= "0" And char <= "9") Or _
   char = "_"
End Function

' Get platform-specific font
Private Function GetPlatformFont(winFont As String, macFont As String) As String
 #If Mac Then
   GetPlatformFont = macFont
 #Else
   GetPlatformFont = winFont
 #End If
End Function

' Enable or disable theme rotation - works on all platforms
Public Sub SetThemeRotation(enabled As Boolean)
 mThemeRotationEnabled = enabled
 
 ' Log setting change
 SafeLogMessage "Theme rotation " & IIf(enabled, "enabled", "disabled")
 
 ' Initialize theme rotator if enabling
 If enabled Then
   ' Reset skip counter
   mThemeSkipCount = 0
   
   ' Rotate theme immediately
   RotateTheme
 End If
End Sub

' Public entry point to trigger theme rotation
Public Sub RotateTheme()
 If Not mIsInitialized Then InitializeCodeFormatter
 
 ' Check if we're on Mac
 #If Mac Then
   ' On Mac, we no longer skip rotation, but we limit frequency
   ' We increment the counter and only skip after several attempts
   mThemeSkipCount = mThemeSkipCount + 1
   
   ' If we've skipped too many times, force a rotation
   If mThemeSkipCount >= MAX_THEME_SKIPS Then
     ' Reset counter
     mThemeSkipCount = 0
   Else
     ' Skip this time but log it
     SafeLogMessage "Theme rotation deferred on Mac for performance", "INFO"
     Exit Sub
   End If
 #End If
 
 ' Rotate to next theme in our collection
 mCurrentThemeIndex = mCurrentThemeIndex + 1
 If mCurrentThemeIndex > mThemes.count Then
   mCurrentThemeIndex = 1
 End If
 
 ' Update with new theme
 UpdateFormatterWithRotatingThemes
 
 ' Log rotation
 SafeLogMessage "Theme rotated to: " & GetCurrentThemeName(), "INFO"
End Sub

' Get current theme name
Public Function GetCurrentThemeName() As String
 On Error Resume Next
 
 ' Check if we're on Mac
 #If Mac Then
   ' Even on Mac, we return the correct theme name
   If mCurrentThemeIndex > 0 And mCurrentThemeIndex <= mThemes.count Then
     GetCurrentThemeName = mThemes(mCurrentThemeIndex)("Name")
   Else
     GetCurrentThemeName = "Default (Mac-optimized)"
   End If
 #Else
   ' On Windows, return from our collection
   If mCurrentThemeIndex > 0 And mCurrentThemeIndex <= mThemes.count Then
     GetCurrentThemeName = mThemes(mCurrentThemeIndex)("Name")
   Else
     GetCurrentThemeName = "Default"
   End If
 #End If
 
 On Error GoTo 0
End Function

' Format code with dark theme - this is the main entry point for formatting
Public Function FormatCodeWithDarkTheme(codeText As String) As String
 On Error GoTo ErrorHandler
 
 ' Ensure formatter is initialized
 If Not mIsInitialized Then InitializeCodeFormatter
 
 ' Check for theme updates if rotation is enabled
 If mThemeRotationEnabled Then
   UpdateFormatterWithRotatingThemes
 End If
 
 ' Check if we need to process in chunks for Mac
 #If Mac Then
   If mIsMac And Len(codeText) > mMaxChunkSize Then
     ' Process in chunks for Mac
     FormatCodeWithDarkTheme = FormatCodeInChunks(codeText)
     Exit Function
   End If
 #End If
 
 ' Document object for working with the content
 Dim doc As Document
 Set doc = ThisDocument
 
 ' Save current selection and content
 Dim savedSel As Range
 Set savedSel = doc.Application.selection.Range
 
 ' Direct formatting approach for small content
 If Len(codeText) < 1000 Then
   FormatCodeWithDarkTheme = DirectFormatCodeWithDarkTheme(codeText)
   Exit Function
 End If
 
 ' Create a temporary document for formatting - with enhanced error handling
 Dim tempDoc As Document
 On Error Resume Next
 Set tempDoc = Documents.Add(Visible:=False)
 
 If Err.Number <> 0 Then
   ' If temp doc creation failed, use direct formatting instead
   SafeLogMessage "Temp document creation failed, using direct formatting", "WARNING"
   FormatCodeWithDarkTheme = DirectFormatCodeWithDarkTheme(codeText)
   Exit Function
 End If
 On Error GoTo ErrorHandler
 
 ' Insert the code text
 tempDoc.content.text = codeText
 
 ' Process the temporary document
 FormatCodeInDocument tempDoc
 
 ' Get the formatted text
 Dim formattedText As String
 formattedText = tempDoc.content.text
 
 ' Close the temporary document without saving
 On Error Resume Next
 tempDoc.Close SaveChanges:=wdDoNotSaveChanges
 On Error GoTo ErrorHandler
 
 ' Return the formatted text
 FormatCodeWithDarkTheme = formattedText
 
 ' Restore selection
 doc.Application.selection.SetRange savedSel.Start, savedSel.End
 
 Exit Function
 
ErrorHandler:
 ' Log error and return original text
 SafeLogMessage "Error in FormatCodeWithDarkTheme: " & Err.Number & " - " & Err.description, "ERROR"
 
 ' Close temp document if it exists
 On Error Resume Next
 If Not tempDoc Is Nothing Then tempDoc.Close SaveChanges:=wdDoNotSaveChanges
 On Error GoTo 0
 
 FormatCodeWithDarkTheme = codeText
End Function

' Direct formatting without temporary document - safer for small content
Private Function DirectFormatCodeWithDarkTheme(codeText As String) As String
 On Error GoTo ErrorHandler
 
 ' Process text directly without document operations
 Dim lines() As String
 lines = Split(codeText, vbCr)
 
 Dim result As String
 result = ""
 
 Dim i As Long
 For i = 0 To UBound(lines)
   ' Process each line
   result = result & lines(i) & vbCr
   
   ' Check for timeout
   If i Mod 50 = 0 Then DoEvents
 Next i
 
 DirectFormatCodeWithDarkTheme = result
 Exit Function
 
ErrorHandler:
 SafeLogMessage "Error in DirectFormatCodeWithDarkTheme: " & Err.Number & " - " & Err.description, "ERROR"
 DirectFormatCodeWithDarkTheme = codeText
End Function

' Mac optimization: Process code in chunks to avoid freezing
Private Function FormatCodeInChunks(codeText As String) As String
 On Error GoTo ErrorHandler
 
 ' Check if already processing a chunk to prevent recursion
 If mIsProcessingChunk Then
   ' Already processing, return as-is to avoid recursion
   FormatCodeInChunks = codeText
   Exit Function
 End If
 
 mIsProcessingChunk = True
 mLastProcessTime = Timer
 
 ' Split the code into lines
 Dim lines() As String
 lines = Split(codeText, vbCr)
 
 ' Work with a string builder approach
 Dim formattedText As String
 formattedText = ""
 
 ' Process in chunks
 Dim startLine As Long
 Dim endLine As Long
 Dim chunkText As String
 
 startLine = 0
 
 Do While startLine <= UBound(lines)
   ' Calculate the end line for this chunk
   endLine = startLine + 50 ' Process 50 lines at a time (increased from 20)
   If endLine > UBound(lines) Then endLine = UBound(lines)
   
   ' Build chunk text
   chunkText = ""
   Dim i As Long
   
   For i = startLine To endLine
     chunkText = chunkText & lines(i) & vbCr
   Next i
   
   ' Format this chunk
   Dim formattedChunk As String
   formattedChunk = DirectFormatCodeWithDarkTheme(chunkText)
   
   ' Append to result
   formattedText = formattedText & formattedChunk
   
   ' Move to next chunk
   startLine = endLine + 1
   
   ' Check if we're taking too long
   If Timer - mLastProcessTime > MAX_PROCESSING_TIME Then
     ' Allow UI to refresh
     DoEvents
     mLastProcessTime = Timer
   End If
 Loop
 
 ' Clean up and return
 mIsProcessingChunk = False
 FormatCodeInChunks = formattedText
 
 Exit Function
 
ErrorHandler:
 ' Log error and return original text
 SafeLogMessage "Error in FormatCodeInChunks: " & Err.Number & " - " & Err.description, "ERROR"
 
 mIsProcessingChunk = False
 FormatCodeInChunks = codeText
End Function

' Format code directly in a document - improved cross-platform approach
Private Sub FormatCodeInDocument(doc As Document)
 On Error GoTo ErrorHandler
 
 ' Variables for processing
 Dim para As Paragraph
 Dim lineText As String
 Dim inModuleHeader As Boolean
 Dim currentSectionColor As Long
 
 ' Generate random seed based on time
 Randomize
 
 ' For Mac, use streamlined approach for large documents
 #If Mac Then
   If doc.content.End - doc.content.Start > 20000 Then
     ' Very large document on Mac - warn user, but process anyway with optimized method
     SafeLogMessage "Large document detected on Mac - using optimized formatting", "WARNING"
   End If
 #End If

 ' Reset the process timer
 mLastProcessTime = Timer
 
 ' Select entire document for processing
 doc.content.Select
 
 ' Set default formatting for the entire document
 With doc.Application.selection
   .Font.name = GetPlatformFont("Consolas", "Courier New")
   .Font.Size = 10
   .Font.Bold = False
   .Font.Italic = False
   .Font.Underline = wdUnderlineNone
   .Font.Color = COLOR_NORMAL_TEXT
   .ParagraphFormat.LineSpacingRule = wdLineSpaceSingle
   .ParagraphFormat.SpaceBefore = 0
   .ParagraphFormat.SpaceAfter = 0
   
   ' Apply black background to entire selection
   .Shading.BackgroundPatternColor = COLOR_BACKGROUND
 End With
 
 ' Now process each paragraph (line) individually for syntax highlighting
 inModuleHeader = False
 currentSectionColor = GetRandomSectionColor()
 
 ' Count paragraphs for periodic refresh
 Dim paraCount As Long
 paraCount = 0
 
 For Each para In doc.Paragraphs
   ' Count paragraphs processed
   paraCount = paraCount + 1
   
   ' Allow UI to refresh periodically
   If paraCount Mod 20 = 0 Then
     DoEvents
     
     ' Check if we're taking too long on Mac
     #If Mac Then
       If Timer - mLastProcessTime > MAX_PROCESSING_TIME Then
         ' Log warning but continue with simpler processing
         SafeLogMessage "Processing timeout - continuing with basic formatting", "WARNING"
         mLastProcessTime = Timer
       End If
     #End If
   End If
   
   ' Get the text of the line
   lineText = para.Range.text
   
   ' Remove paragraph mark at the end
   If Len(lineText) > 0 Then
     If Asc(Right(lineText, 1)) = 13 Or Asc(Right(lineText, 1)) = 10 Then
       lineText = Left(lineText, Len(lineText) - 1)
     End If
   End If
   
   ' Skip empty lines
   If Trim(lineText) = "" Then
     para.Range.Font.Color = COLOR_NORMAL_TEXT
     GoTo NextParagraph
   End If
   
   ' Check if this is a section divider
   If IsSectionDivider(lineText) Then
     ' Get a random color for this section
     currentSectionColor = GetRandomSectionColor()
     inModuleHeader = True
     
     ' Format section divider
     para.Range.Font.Color = currentSectionColor
     para.Range.Font.Bold = True
     
   ElseIf inModuleHeader And Left(Trim(lineText), 1) = "'" Then
     ' Continue formatting header lines
     para.Range.Font.Color = currentSectionColor
     para.Range.Font.Bold = (Trim(lineText) = "'")
     
     ' Check if this is the end of the header
     If Trim(lineText) = "'" Or IsSectionDivider(lineText) Then
       inModuleHeader = False
     End If
   Else
     ' Regular code line
     inModuleHeader = False
     
     ' Format based on content - optimize for Mac if needed
     #If Mac Then
       ' Simpler formatting for Mac
       If Left(Trim(lineText), 1) = "'" Then
         para.Range.Font.Color = COLOR_COMMENTS
       Else
         para.Range.Font.Color = COLOR_NORMAL_TEXT
         
         ' Check for comment at end of line
         Dim commentPos As Long
         commentPos = InStr(1, lineText, "'")
         
         If commentPos > 1 Then
           ' Format comment portion
           Dim commentRange As Range
           Set commentRange = para.Range.duplicate
           commentRange.SetRange para.Range.Start + commentPos - 1, para.Range.End
           commentRange.Font.Color = COLOR_COMMENTS
         End If
       End If
     #Else
       ' Full formatting for Windows
       FormatCodeLine para.Range, lineText
     #End If
   End If

NextParagraph:
 Next para
 
 Exit Sub
 
ErrorHandler:
 SafeLogMessage "Error in FormatCodeInDocument: " & Err.Number & " - " & Err.description, "ERROR"
End Sub

' Format the current selection as code
Public Sub FormatCodeSelection()
 On Error GoTo ErrorHandler
 
 ' Ensure formatter is initialized
 If Not mIsInitialized Then InitializeCodeFormatter
 
 ' Check for theme updates if rotation is enabled
 If mThemeRotationEnabled Then
   UpdateFormatterWithRotatingThemes
 End If
 
 ' Document object for working with the content
 Dim doc As Document
 Set doc = ThisDocument
 
 ' Get the selection
 Dim selRange As Range
 Set selRange = doc.Application.selection.Range
 
 ' Skip if nothing is selected
 If selRange.Start = selRange.End Then
   MsgBox "Please select text to format", vbInformation
   Exit Sub
 End If
 
 ' Store the last process time for timeout checking
 mLastProcessTime = Timer
 
 ' Get the selected text
 Dim selText As String
 selText = selRange.text
 
 ' Format the selected text
 Dim formattedText As String
 formattedText = FormatCodeWithDarkTheme(selText)
 
 ' Replace the selection with formatted text
 selRange.text = formattedText
 
 Exit Sub
 
ErrorHandler:
 ' Log error
 SafeLogMessage "Error in FormatCodeSelection: " & Err.Number & " - " & Err.description, "ERROR"
End Sub

' Format entire document as code
Public Sub FormatEntireDocument()
 On Error GoTo ErrorHandler
 
 ' Ensure formatter is initialized
 If Not mIsInitialized Then InitializeCodeFormatter
 
 ' Document object for working with the content
 Dim doc As Document
 Set doc = ThisDocument
 
 ' Store the last process time for timeout checking
 mLastProcessTime = Timer
 
 ' No "simplified formatting" message on Mac, just optimize behind the scenes
 #If Mac Then
   If mIsMac Then
     ' For large documents on Mac, log an info message instead of a warning
     SafeLogMessage "Optimizing formatting for Mac platform - maintaining full VENOM theme", "INFO"
   End If
 #End If
 
 ' Format directly in document
 FormatCodeInDocument doc
 
 Exit Sub
 
ErrorHandler:
 ' Log error with more details
 Dim errDetails As String
 errDetails = "Error " & Err.Number & ": " & Err.description
 If Err.Number = 0 Then
   errDetails = errDetails & " (This may be due to missing dependencies)"
 End If
 
 SafeLogMessage "Error in FormatEntireDocument: " & errDetails, "ERROR"
End Sub

' Create a section divider with a snarky comment
Public Function CreateSectionDivider(moduleName As String, Optional versionInfo As String = "") As String
 ' Ensure module is initialized
 If Not mIsInitialized Then InitializeCodeFormatter
 
 ' Try to use enhanced dividers if available
 On Error Resume Next
 Dim enhancedDivider As String
 
 ' Try enhanced dividers on both platforms
 If mExternalModulesAvailable Then
   If FunctionExists("EnhancedDividers_CreateSectionDivider") Then
     enhancedDivider = Application.Run("EnhancedDividers_CreateSectionDivider", moduleName, versionInfo)
     
     If Err.Number = 0 And enhancedDivider <> "" Then
       ' Enhanced dividers available and working
       CreateSectionDivider = enhancedDivider
       Exit Function
     End If
   End If
 End If
 On Error GoTo 0
 
 ' Fall back to default implementation if enhanced dividers not available
 ' Get random snarky comment
 Dim snarkyComment As String
 snarkyComment = GetRandomSnarkyComment()
 
 ' Create timestamp and author info
 Dim timestamp As String
 timestamp = format(Now, "yyyy-mm-dd")
 
 Dim authorInfo As String
 authorInfo = "Aaron McCutchins"
 
 ' Get version if not provided
 If versionInfo = "" Then
   versionInfo = "1.0"
 End If
 
 ' Build section divider
 Dim divider As String
 divider = "' ===============================================================" & _
 "==============" & vbCrLf & _
 "' " & moduleName & vbCrLf & _
 "' Version: " & versionInfo & vbCrLf & _
 "' " & snarkyComment & vbCrLf & _
 "' Updated by: " & authorInfo & " on " & timestamp & vbCrLf & _
 "' ===============================================================" & _
 "==============" & vbCrLf
 
 CreateSectionDivider = divider
End Function

' Get random snarky comment for section divider
Private Function GetRandomSnarkyComment() As String
 Dim comments As Variant
 
 ' Define some snarky/humorous comments
 comments = Array( _
   "Code so elegant, it makes other VBA cry.", _
   "60% of the time, it works every time!", _
   "This code does not contain bugs, just random unexpected features.", _
   "Coffee-powered code: handle with caffeine.", _
   "VBA: Making the impossible slightly more possible since 1993.", _
   "If you're reading this, you've gone too deep. Turn back now.", _
   "Warning: Changing this code might cause existential crisis.", _
   "Future me, I apologize for what you're about to debug.", _
   "I wrote this at 3 AM. Judge accordingly.", _
   "Abandon hope all ye who debug here.", _
   "Even the computer is confused by this code.", _
   "This code is like modern art - confusing, yet somehow valuable.", _
   "Don't try to understand this. It's working and that's all that matters.", _
   "If you understand this code, you're qualified for a raise.", _
   "This code is the VBA equivalent of putting on sweatpants - everyone feels better but nobody's impressed.", _
   "Coding in VBA is like trying to paint the Sistine Chapel with crayons.", _
   "More robust than your New Year's resolutions, but that's a low bar.", _
   "This module is the digital equivalent of duct tape and WD-40: if it can't fix it, you're really screwed.", _
   "For best results, read this code after consuming exactly two alcoholic beverages.", _
   "This code maintains cross-platform compatibility and your diminishing will to live." _
 )
 
 ' Get random comment - use same method for all platforms
 Dim randomIndex As Long
 randomIndex = Int((UBound(comments) + 1) * Rnd)
 GetRandomSnarkyComment = comments(randomIndex)
 
 ' Add emoji for Mac - platform detection already built in
 #If Mac Then
   GetRandomSnarkyComment = GetRandomSnarkyComment & " ??"
 #End If
End Function

' Create a continuation marker for carrying on in a new chat
Public Function CreateChatContinuityMarker(completionPercentage As Integer) As String
 ' Try enhanced marker on all platforms for consistency
 On Error Resume Next
 Dim enhancedMarker As String
 
 If mExternalModulesAvailable Then
   If FunctionExists("EnhancedDividers_CreateContinuityMarker") Then
     enhancedMarker = Application.Run("EnhancedDividers_CreateContinuityMarker", completionPercentage)
     
     If Err.Number = 0 And enhancedMarker <> "" Then
       ' Enhanced dividers available and working
       CreateChatContinuityMarker = enhancedMarker
       Exit Function
     End If
   End If
 End If
 On Error GoTo 0
 
 ' Get current module and feature information from analyzer
 Dim currentModule As String
 Dim lastFeature As String
 Dim nextSteps As String
 
 On Error Resume Next
 
 ' Try to get actual module info on all platforms
 If mExternalModulesAvailable Then
   If FunctionExists("CodeAnalysis_GetCurrentModuleName") Then
     currentModule = Application.Run("CodeAnalysis_GetCurrentModuleName")
     lastFeature = Application.Run("CodeAnalysis_GetLastImplementedFeature")
     nextSteps = Application.Run("CodeAnalysis_GetNextSteps")
   End If
 End If
 
 ' Default values if not available
 If Err.Number <> 0 Or Trim(currentModule) = "" Then
   currentModule = "Undetermined - analyze code to identify"
 End If
 
 If Err.Number <> 0 Or Trim(lastFeature) = "" Then
   lastFeature = "Undetermined - analyze code to identify"
 End If
 
 If Err.Number <> 0 Or Trim(nextSteps) = "" Then
   nextSteps = "Continue development on current module and implement remaining features"
 End If
 
 On Error GoTo 0
 
 ' Build the marker
 Dim marker As String
 marker = vbCrLf & vbCrLf & _
 "' ===============================================================" & _
 "==============" & vbCrLf & _
 "' CHAT CONTINUATION MARKER - PROJECT COMPLETION: " & completionPercentage & "%" & vbCrLf & _
 "' ===============================================================" & _
 "==============" & vbCrLf & _
 "' Claude, please pick up exactly where we left off in the previous chat." & vbCrLf & _
 "' The code structure and flow patterns should remain intact." & vbCrLf & _
 "' We are continuing development of the cross-platform VBA solution." & vbCrLf & _
 "' Current module being worked on: " & currentModule & vbCrLf & _
 "' Last implemented feature: " & lastFeature & vbCrLf & _
 "' Next steps: " & nextSteps & vbCrLf & _
 "' ===============================================================" & _
 "==============" & vbCrLf
 
 CreateChatContinuityMarker = marker
End Function

' Get list of detected missing dependencies
Public Function GetMissingDependencies() As String
 Dim result As String
 result = "Missing dependencies:" & vbCrLf & vbCrLf
 
 If Not mIsInitialized Then
   InitializeCodeFormatter
 End If
 
 If mMissingDependencies Is Nothing Then
   result = result & "Dependency tracking not initialized"
   GetMissingDependencies = result
   Exit Function
 End If
 
 If mMissingDependencies.count = 0 Then
   result = result & "No missing dependencies detected - all required modules available"
 Else
   Dim i As Long
   For i = 1 To mMissingDependencies.count
     On Error Resume Next
     result = result & "- " & mMissingDependencies(i) & vbCrLf
     On Error GoTo 0
   Next i
   
   result = result & vbCrLf & "These modules should be added to the project for full functionality."
 End If
 
 GetMissingDependencies = result
End Function

' Check if all modules and dependencies are available
Public Function AreAllModulesAvailable() As Boolean
 If Not mIsInitialized Then
   InitializeCodeFormatter
 End If
 
 AreAllModulesAvailable = mExternalModulesAvailable
End Function

'=============================================================================
' END MODULE: modCodeFormatter
'=============================================================================

‘********************************************************* 
‘‘***************** ‘coVdEeNcOoMde ‘******************     
‘********************************************************* 

'==============================================================
' BEGIN MODULE: ErrorHandler (Standard Module)
'==============================================================
' Error handler for cross-platform VBA with Mac optimizations
' Version: 2.0 Mac-Optimized

Option Explicit

' Error logging options - documenting the suffering
Private Const ENABLE_ERROR_LOGGING As Boolean = True
Private Const MAX_LOG_SIZE As Long = 1000000 ' Maximum log file size in bytes
Private Const LOG_FILENAME As String = "ErrorAutopsy.txt"

' Error handling options - controlling the torture procedure
Private Const SHOW_ERROR_DIALOGS As Boolean = True ' Display error messages to user
Private Const INCLUDE_CALLSTACK As Boolean = True ' Include call stack in error logs

' Last error information - saving the death rattle for posterity
Private m_LastErrorNumber As Long
Private m_LastErrorDescription As String
Private m_LastErrorSource As String
Private m_LastErrorProcedure As String
Private m_LastErrorDateTime As Date
Private m_Initialized As Boolean
Private m_IsHandlingError As Boolean ' Flag to prevent recursive error handling

'===== INITIALIZATION =====
Public Sub InitializeErrorHandler()
    ' Prevent stack overflow by checking initialization flag
    If m_Initialized Then Exit Sub
    
    On Error Resume Next
    Debug.Print "Initializing error handler..."
    
    ' Set flag early to prevent recursion
    m_Initialized = True
    
    ' Reset error handling flag
    m_IsHandlingError = False
    
    ' Clear last error information - wiping the blood from previous kills
    ClearLastError
    
    Debug.Print "Error handler initialization complete"
    
    On Error GoTo 0
End Sub

'===== ERROR HANDLING =====
' Main error handling function - call this from error handlers
Public Sub HandleError(ByVal moduleName As String, ByVal procedureName As String, _
                     ByVal errNumber As Long, ByVal errDescription As String, _
                     Optional ByVal showUser As Boolean = False, _
                     Optional ByVal terminateApp As Boolean = False)
    ' Prevent recursive error handling
    If m_IsHandlingError Then
        Debug.Print "Recursive error handling prevented: " & moduleName & "." & procedureName
        Exit Sub
    End If
    
    On Error Resume Next
    m_IsHandlingError = True
    
    ' Ensure initialization
    If Not m_Initialized Then InitializeErrorHandler
    
    ' Store error information - preserve the exact manner of death
    m_LastErrorNumber = errNumber
    m_LastErrorDescription = errDescription
    m_LastErrorSource = moduleName
    m_LastErrorProcedure = procedureName
    m_LastErrorDateTime = Now
    
    ' Format error message - prepare the autopsy report
    Dim errorMessage As String
    errorMessage = FormatErrorMessage(moduleName, procedureName, errNumber, errDescription)
    
    ' MAC OPTIMIZATION: Always log to debug output first (lightweight)
    Debug.Print "ERROR: " & errorMessage
    
    ' Log the error to file - archive the specimen for study
    If ENABLE_ERROR_LOGGING Then
        LogErrorSafely errorMessage
    End If
    
    ' Display to user if needed - show them the beautiful agony of dying code
    If showUser Or SHOW_ERROR_DIALOGS Then
        ' MAC OPTIMIZATION: Use simple MsgBox instead of custom UI on Mac
        DisplayErrorToUser errorMessage
    End If
    
    ' Terminate application if fatal error - put it out of its misery... or not
    If terminateApp Then
        EndApplication
    End If
    
    m_IsHandlingError = False
    
    On Error GoTo 0
End Sub

' Format error message for display and logging - make suffering look elegant
Private Function FormatErrorMessage(ByVal moduleName As String, ByVal procedureName As String, _
                                 ByVal errNumber As Long, ByVal errDescription As String) As String
    On Error Resume Next
    
    Dim msg As String
    msg = "? Fatal Exception " & errNumber & ": " & errDescription & vbNewLine & _
          "? Infection Source: " & moduleName & vbNewLine & _
          "? Necrotizing Procedure: " & procedureName & vbNewLine & _
          "? Time of Death: " & format(Now, "yyyy-mm-dd hh:mm:ss")
    
    ' Add call stack if enabled - trace the cascade of organ failures
    ' MAC OPTIMIZATION: Skip call stack on Mac for performance
    #If Not Mac Then
        If INCLUDE_CALLSTACK Then
            msg = msg & vbNewLine & "? Autopsy Trail: " & GetCallStack()
        End If
    #End If
    
    FormatErrorMessage = msg
    
    On Error GoTo 0
End Function

' Display error message to user - force them to witness the carnage
Private Sub DisplayErrorToUser(ByVal errorMessage As String)
    On Error Resume Next
    
    ' Show simplified message in UI - hide the most gruesome details
    Dim userMessage As String
    userMessage = "? FATAL Error ?" & vbNewLine & vbNewLine & _
                 m_LastErrorDescription & vbNewLine & vbNewLine & _
                 "This Error has been preserved in the morgue for further study."
    
    ' MAC OPTIMIZATION: Shorter message on Mac
    #If Mac Then
        userMessage = "Error: " & m_LastErrorDescription
    #End If
    
    MsgBox userMessage, vbExclamation, "System Failure"
    
    On Error GoTo 0
End Sub

'===== ERROR LOGGING =====
' Log error to file with safer approach - preserve the corpse for research
Private Sub LogErrorSafely(ByVal errorMessage As String)
    On Error Resume Next
    
    ' MAC OPTIMIZATION: Skip file logging on Mac if very busy
    #If Mac Then
        Static lastLogTime As Date
        ' Only log once per second maximum on Mac to prevent overload
        If DateDiff("s", lastLogTime, Now) < 1 Then
            Debug.Print "Skipping frequent log write on Mac for performance"
            Exit Sub
        End If
        lastLogTime = Now
    #End If
    
    ' Actual logging implementation
    LogError errorMessage
    
    On Error GoTo 0
End Sub

' Log error to file - preserve the corpse for research
Private Sub LogError(ByVal errorMessage As String)
    On Error Resume Next
    
    Dim logPath As String
    Dim fileNum As Integer
    
    ' Get log file path - locate the morgue
    logPath = GetLogFilePath()
    
    ' Check if path is valid
    If logPath = "" Then
        Debug.Print "Invalid log file path"
        Exit Sub
    End If
    
    ' Check log file size and rotate if needed - clear space in the mass grave
    If fileExists(logPath) Then
        If GetFileSize(logPath) > MAX_LOG_SIZE Then
            RotateLogFile logPath
        End If
    End If
    
    ' Write to log file - store the specimen
    fileNum = FreeFile
    Open logPath For Append As #fileNum
    Print #fileNum, String(50, "?")
    Print #fileNum, errorMessage
    Print #fileNum, String(50, "?")
    Print #fileNum, ""
    Close #fileNum
    
    On Error GoTo 0
End Sub

' Get the full path to the log file - locate the mass grave
Private Function GetLogFilePath() As String
    On Error Resume Next
    
    Dim logPath As String
    
    ' Try to use application path first
    If ThisDocument.path <> "" Then
        logPath = ThisDocument.path & GetPathSeparator() & LOG_FILENAME
    Else
        ' Fallback to temp folder - MAC COMPATIBLE
        logPath = GetTempPath() & LOG_FILENAME
    End If
    
    GetLogFilePath = logPath
    
    On Error GoTo 0
End Function

' MAC COMPATIBLE: Get path separator based on platform
Private Function GetPathSeparator() As String
    #If Mac Then
        GetPathSeparator = "/"
    #Else
        GetPathSeparator = "\"
    #End If
End Function

' MAC COMPATIBLE: Get temp folder path
Private Function GetTempPath() As String
    On Error Resume Next
    
    Dim tempPath As String
    
    #If Mac Then
        ' MAC OPTIMIZATION: Use direct path instead of AppleScript
        tempPath = "/private/tmp/"
    #Else
        ' WINDOWS: Use environment variables
        tempPath = Environ$("TEMP")
        If tempPath = "" Then tempPath = Environ$("TMP")
        If tempPath = "" Then tempPath = "C:\Windows\Temp"
        
        ' Ensure trailing backslash
        If Right(tempPath, 1) <> "\" Then tempPath = tempPath & "\"
    #End If
    
    ' Ensure trailing separator
    If Right(tempPath, 1) <> GetPathSeparator() Then
        tempPath = tempPath & GetPathSeparator()
    End If
    
    GetTempPath = tempPath
    
    On Error GoTo 0
End Function

' Check if a file exists - MAC COMPATIBLE
Private Function fileExists(ByVal filePath As String) As Boolean
    On Error Resume Next
    
    #If Mac Then
        ' MAC: Better approach for Mac
        Dim fileNum As Integer
        fileExists = False
        
        If Trim(filePath) = "" Then Exit Function
        
        fileNum = FreeFile
        Open filePath For Input As #fileNum
        If Err.Number = 0 Then
            fileExists = True
            Close #fileNum
        End If
    #Else
        ' WINDOWS: Use Dir function (more reliable than GetAttr)
        fileExists = (Dir(filePath) <> "")
    #End If
    
    On Error GoTo 0
End Function

' Get file size in bytes - MAC COMPATIBLE
Private Function GetFileSize(ByVal filePath As String) As Long
    On Error Resume Next
    
    GetFileSize = 0
    
    ' Use simple file functions that work on both platforms
    If fileExists(filePath) Then
        ' Use universal file size method
        Dim fileNum As Integer
        fileNum = FreeFile
        Open filePath For Input As #fileNum
        GetFileSize = LOF(fileNum)
        Close #fileNum
    End If
    
    On Error GoTo 0
End Function

' Rotate log file (create backup and start new log) - MAC COMPATIBLE
Private Sub RotateLogFile(ByVal logPath As String)
    On Error Resume Next
    
    ' MAC OPTIMIZATION: Simpler approach on Mac
    #If Mac Then
        ' Just delete the log file on Mac for simplicity
        Kill logPath
    #Else
        ' Full rotation on Windows
        Dim backupPath As String
        backupPath = logPath & "." & format(Now, "yyyymmdd_hhmmss") & ".bak"
        
        ' Copy current log to backup - archive the old corpses
        FileCopy logPath, backupPath
        
        ' Delete or truncate original log - clear the slab for fresh victims
        Kill logPath
    #End If
    
    On Error GoTo 0
End Sub

'===== UTILITY FUNCTIONS =====
' Get call stack information - trace the path of destruction
Private Function GetCallStack() As String
    ' Call stack info is not directly available in VBA
    ' This is a placeholder for a more sophisticated implementation
    GetCallStack = "[The sequence of fatal events could not be recovered from the mangled remains]"
End Function

' End application gracefully - administer the final blow
Private Sub EndApplication()
    On Error Resume Next
    
    ' MAC OPTIMIZATION: Simple approach on Mac
    #If Mac Then
        Debug.Print "Application termination requested due to fatal error"
    #Else
        ' Close all open forms - seal all the escape routes
        Dim frm As Object
        For Each frm In VBA.UserForms
            Unload frm
        Next frm
    #End If
    
    On Error GoTo 0
End Sub

'===== ACCESS FUNCTIONS =====
Public Function GetLastErrorNumber() As Long
    GetLastErrorNumber = m_LastErrorNumber
End Function

Public Function GetLastErrorDescription() As String
    GetLastErrorDescription = m_LastErrorDescription
End Function

Public Function GetLastErrorSource() As String
    GetLastErrorSource = m_LastErrorSource
End Function

Public Function GetLastErrorProcedure() As String
    GetLastErrorProcedure = m_LastErrorProcedure
End Function

Public Function GetLastErrorDateTime() As Date
    GetLastErrorDateTime = m_LastErrorDateTime
End Function

Public Sub ClearLastError()
    m_LastErrorNumber = 0
    m_LastErrorDescription = ""
    m_LastErrorSource = ""
    m_LastErrorProcedure = ""
    m_LastErrorDateTime = 0
End Sub

Public Function HasError() As Boolean
    HasError = (m_LastErrorNumber <> 0)
End Function
'==============================================================
' END MODULE: ErrorHandler
'==============================================================

‘********************************************************* 
‘‘***************** ‘coVdEeNcOoMde ‘******************     
‘********************************************************* 

'=============================================================================
' BEGIN MODULE: DynamicUserFormManager (Standard Module)
'=============================================================================
' ******************************************************************************
' *                     DYNAMIC USERFORM MANAGER MODULE                       *
' *                  Mesmerizing Users Before We Strike                       *
' ******************************************************************************
Option Explicit

#If Mac Then
    ' Mac-specific constants for performance optimization
    Private Const MAC_MAX_CONTROLS_PER_BATCH As Long = 10 ' Process controls in smaller batches on Mac
    Private Const MAC_PROCESS_TIMEOUT_MS As Long = 500 ' Timeout for processing (milliseconds)
    Private mLastProcessTime As Double ' Last processing time for timeout detection
    Private mIsMacProcessing As Boolean ' Flag to prevent reentrant processing on Mac
#End If

' Form registry to store control properties - catalog of victim biomarkers
Private m_formRegistry As Object
Private m_formKeysRegistry As Object ' For Mac: Parallel collection to store form names
Private m_isInitialized As Boolean
Private m_darkModeEnabled As Boolean ' Track dark mode state

'===== INITIALIZATION - PREPARING THE PARASITE =====

Public Sub InitializeDynamicUserFormManager()
    On Error Resume Next
    
    If Not m_isInitialized Then
        ' Create cross-platform storage for form registry - host memory mapping
        #If Mac Then
            ' Use Collection for Mac compatibility
            Set m_formRegistry = New collection
            Set m_formKeysRegistry = New collection ' Store keys separately for Mac
        #Else
            ' Use Dictionary for Windows
            Set m_formRegistry = CreateObject("Scripting.Dictionary")
        #End If
        
        m_isInitialized = True
        
        #If Mac Then
            ' Initialize processing timer
            mLastProcessTime = Timer
        #End If
        
        LogMessage "UI parasite initialized - visual cortex infiltration prepared"
    End If
    
    On Error GoTo 0
End Sub

'===== DICTIONARY COMPATIBILITY LAYER - CROSS-PLATFORM INFECTION TOOLS =====

#If Mac Then
    ' Check if key exists in form registry (Mac version)
    Private Function FormExists(formName As String) As Boolean
        On Error Resume Next
        Dim i As Long
        For i = 1 To m_formKeysRegistry.count
            If m_formKeysRegistry(i) = formName Then
                FormExists = True
                Exit Function
            End If
        Next i
        FormExists = False
        On Error GoTo 0
    End Function
    
    ' Add form to registry (Mac version)
    Private Sub AddFormToRegistry(formName As String, formControls As Object)
        On Error Resume Next
        m_formRegistry.Add formControls
        m_formKeysRegistry.Add formName
        On Error GoTo 0
    End Sub
    
    ' Get form controls from registry (Mac version)
    Private Function GetFormControls(formName As String) As Object
        On Error Resume Next
        Dim i As Long
        Set GetFormControls = Nothing
        
        For i = 1 To m_formKeysRegistry.count
            If m_formKeysRegistry(i) = formName Then
                Set GetFormControls = m_formRegistry(i)
                Exit Function
            End If
        Next i
        On Error GoTo 0
    End Function
    
    ' Check if processing timeout occurred
    Private Function ProcessingTimedOut() As Boolean
        If Timer - mLastProcessTime > (MAC_PROCESS_TIMEOUT_MS / 1000) Then
            ProcessingTimedOut = True
        Else
            ProcessingTimedOut = False
        End If
    End Function
    
    ' Reset the processing timer
    Private Sub ResetProcessingTimer()
        mLastProcessTime = Timer
    End Sub
#End If

'===== CONTROL CREATION AND MANAGEMENT - IMPLANTING NEURAL HOOKS =====

' Create controls dynamically with cross-platform compatibility - spawn infectious agents in the host visual cortex
Public Function CreateControl(frm As MSForms.UserForm, _
                             controlType As String, _
                             controlName As String, _
                             Optional Visible As Boolean = True) As MSForms.control
    On Error GoTo ErrorHandler
    
    ' Initialize if needed - verify parasite core is active
    If Not m_isInitialized Then InitializeDynamicUserFormManager
    
    ' Create the control - incubate the parasite
    Set CreateControl = frm.Controls.Add(controlType, controlName, Visible)
    
    ' Process in chunks on Mac with timeout protection
    #If Mac Then
        ' Reset timeout timer
        ResetProcessingTimer
        DoEvents ' Keep UI responsive
    #End If
    
    ' Apply visual style to the new control - inject visual toxin
    If m_darkModeEnabled Then
        ' Use Application.Run for safer cross-module calls on Mac
        #If Mac Then
            On Error Resume Next
            Application.Run "modVisualStyle.ApplyDarkModeControl", CreateControl
            On Error GoTo ErrorHandler
        #Else
            modVisualStyle.ApplyDarkModeControl CreateControl
        #End If
    Else
        #If Mac Then
            On Error Resume Next
            Application.Run "VisualStyle.ApplyLightModeToControl", CreateControl
            On Error GoTo ErrorHandler
        #Else
            VisualStyle.ApplyLightModeToControl CreateControl
        #End If
    End If
    
    ' Apply platform-specific adjustments to the new control - modify host visual receptor properties
    ApplyPlatformSpecificSettings CreateControl
    
    ' Register control for later management - catalogue infected neurons
    RegisterControl frm, CreateControl
    
    LogMessage "Visual parasite agent '" & controlName & "' successfully implanted in host form"
    
    Exit Function
    
ErrorHandler:
    If Not ErrorHandler Is Nothing Then
        On Error Resume Next
        #If Mac Then
            Application.Run "ErrorHandler.HandleError", "DynamicUserFormManager", "CreateControl", _
                                  Err.Number, Err.description
        #Else
            ErrorHandler.HandleError "DynamicUserFormManager", "CreateControl", _
                                  Err.Number, Err.description
        #End If
        On Error GoTo 0
    Else
        Debug.Print "Parasite implantation failed: " & Err.description
    End If
    Set CreateControl = Nothing
End Function

' Register control for management - tag the infected neuron for monitoring
Private Sub RegisterControl(frm As MSForms.UserForm, ctrl As MSForms.control)
    On Error Resume Next
    
    ' Initialize if needed - verify parasite core is active
    If Not m_isInitialized Then InitializeDynamicUserFormManager
    
    ' Create form registry entry if needed - establish neural map for this host
    #If Mac Then
        Dim formControls As Object
        
        If Not FormExists(frm.name) Then
            ' Create new controls collection
            Set formControls = CreateObject("Scripting.Dictionary")
            AddFormToRegistry frm.name, formControls
        Else
            ' Get existing controls collection
            Set formControls = GetFormControls(frm.name)
        End If
        
        ' Add control to registry if it doesn't exist
        If Not formControls.exists(ctrl.name) Then
            Dim controlProps As Object
            Set controlProps = CreateObject("Scripting.Dictionary")
            
            ' Store original dimensions - baseline neural morphology
            controlProps.Add "OriginalLeft", ctrl.Left
            controlProps.Add "OriginalTop", ctrl.Top
            controlProps.Add "OriginalWidth", ctrl.width
            controlProps.Add "OriginalHeight", ctrl.height
            
            formControls.Add ctrl.name, controlProps
        End If
        
        ' Keep UI responsive with DoEvents
        DoEvents
    #Else
        ' Windows implementation
        If Not m_formRegistry.exists(frm.name) Then
            Dim formControls As Object
            Set formControls = CreateObject("Scripting.Dictionary")
            m_formRegistry.Add frm.name, formControls
        End If
        
        ' Add control to registry - record neural connection
        Dim formControls As Object
        Set formControls = m_formRegistry(frm.name)
        
        If Not formControls.exists(ctrl.name) Then
            Dim controlProps As Object
            Set controlProps = CreateObject("Scripting.Dictionary")
            
            ' Store original dimensions - baseline neural morphology
            controlProps.Add "OriginalLeft", ctrl.Left
            controlProps.Add "OriginalTop", ctrl.Top
            controlProps.Add "OriginalWidth", ctrl.width
            controlProps.Add "OriginalHeight", ctrl.height
            
            formControls.Add ctrl.name, controlProps
        End If
    #End If
    
    On Error GoTo 0
End Sub

' Apply platform-specific settings to a control - tailor the neurotoxin to the host visual system
Public Sub ApplyPlatformSpecificSettings(ctrl As MSForms.control)
    #If Mac Then
        ' Mac-specific settings - specialized neurotoxins for Apple nerves
        On Error Resume Next
        
        ' Use Mac-compatible font - lethal font carrier
        If typeName(ctrl.Font) = "StdFont" Then
            ctrl.Font.name = GetPlatformFont("Calibri", "Geneva")
            ctrl.Font.Size = 12
        End If
        
        ' Adjust positioning for Mac - precise toxin delivery point
        ctrl.Top = ctrl.Top + 2
        
        ' Mac-specific colors - visually irresistible neurotoxins
        Select Case typeName(ctrl)
            Case "TextBox", "ComboBox", "ListBox"
                ' Lighter background for inputs - looks harmless
                ctrl.BackColor = MacRGB(255, 255, 255)
            Case "CommandButton"
                ' Use Mac button style colors - camouflage for the trigger
                ctrl.BackColor = MacRGB(240, 240, 240)
            Case "Label"
                ' Mac labels tend to be darker - shadow of impending doom
                ctrl.ForeColor = MacRGB(50, 50, 50)
        End Select
        
        ' Add strategic DoEvents to keep Mac UI responsive
        DoEvents
        
        On Error GoTo 0
    #Else
        ' Windows-specific settings - tailored toxins for Microsoft hosts
        On Error Resume Next
        
        If typeName(ctrl.Font) = "StdFont" Then
            ctrl.Font.name = "Segoe UI"
            ctrl.Font.Size = 9
        End If
        
        ' Windows-specific colors - different strain, same fatal outcome
        Select Case typeName(ctrl)
            Case "TextBox", "ComboBox", "ListBox"
                ' Standard Windows input background - deceptively clean
                ctrl.BackColor = RGB(255, 255, 255)
            Case "CommandButton"
                ' Windows button style - the trigger for pain
                ctrl.BackColor = RGB(240, 240, 240)
        End Select
        
        On Error GoTo 0
    #End If
End Sub

' Cross-platform RGB function for Mac - specialized toxin color formulation
#If Mac Then
    ' Mac RGB function - Mac uses different RGB byte order
    Private Function MacRGB(r As Integer, g As Integer, b As Integer) As Long
        MacRGB = (b * 65536) + (g * 256) + r
    End Function
#End If

' Get platform-specific font - font tailored to the host system
Private Function GetPlatformFont(windowsFont As String, macFont As String) As String
    #If Mac Then
        GetPlatformFont = macFont
    #Else
        GetPlatformFont = windowsFont
    #End If
End Function

'===== FORM POSITIONING AND LAYOUT - VICTIM CONTAINMENT =====

' Position a UserForm in a screen-independent way - locate the optimal point for visual system hijacking
Public Sub PositionUserFormCentered(frm As MSForms.UserForm)
    On Error Resume Next
    
    With frm
        ' Start with center position - central visual field
        .StartUpPosition = 0 ' Manual positioning
        
        ' Center the form on screen - align with host's central vision
        .Left = Application.Left + (Application.width - .width) / 2
        .Top = Application.Top + (Application.height - .height) / 2
        
        ' Make additional adjustments for Mac if needed - different host anatomy
        #If Mac Then
            ' Mac requires extra adjustments due to differences in coordinate system
            If .Top < 0 Then .Top = 20
            If .Left < 0 Then .Left = 20
            DoEvents ' Keep Mac UI responsive
        #End If
    End With
    
    On Error GoTo 0
End Sub

' Adjust Z-Order with cross-platform compatibility - determine which parasite appears in the foreground
Public Sub AdjustZOrder(ctrl As MSForms.control, bringToFront As Boolean)
    On Error Resume Next
    
    #If Mac Then
        ' On Mac, we need different strategies since z-order behaves differently - alternative visual pathway manipulation
        
        ' Strategy 1: Hide and show the control - flicker to trigger attention redirection
        If typeName(ctrl) <> "Frame" And typeName(ctrl) <> "MultiPage" Then
            ctrl.Visible = False
            ' Add a brief delay to ensure refresh
            DelayForMac 0.05 ' Brief delay with UI responsiveness
            ctrl.Visible = True
        End If
        
        ' Keep UI responsive on Mac
        DoEvents
    #Else
        ' On Windows, we can use the ZOrder method - direct visual pathway interception
        If bringToFront Then
            ctrl.ZOrder msoBringToFront
        Else
            ctrl.ZOrder msoSendToBack
        End If
    #End If
    
    On Error GoTo 0
End Sub

' Mac-specific delay with DoEvents to keep UI responsive
#If Mac Then
    Private Sub DelayForMac(seconds As Single)
        Dim startTime As Double
        startTime = Timer
        
        ' Loop with DoEvents for UI responsiveness
        Do While Timer < startTime + seconds
            DoEvents
        Loop
    End Sub
#End If

' Calculate control positions by percentage of form size - precision targeting of visual field regions
Public Function CalcPosition(frm As Object, percentX As Single, percentY As Single) As Variant
    Dim result(1) As Single
    
    result(0) = frm.width * (percentX / 100)  ' Left position - horizontal visual field coordinate
    result(1) = frm.height * (percentY / 100) ' Top position - vertical visual field coordinate
    
    CalcPosition = result
End Function

' Calculate control size by percentage of form size - determine size of visual field occupation
Public Function CalcSize(frm As Object, percentWidth As Single, percentHeight As Single) As Variant
    Dim result(1) As Single
    
    result(0) = frm.width * (percentWidth / 100)   ' Width - horizontal visual spread
    result(1) = frm.height * (percentHeight / 100) ' Height - vertical visual spread
    
    CalcSize = result
End Function

' Handle overlapping controls (alternative to Z-Order) - manage competing visual stimuli
Public Sub ShowOverlappingControl(backgroundCtrl As MSForms.control, foregroundCtrl As MSForms.control)
    #If Mac Then
        ' On Mac, hide the background control completely - eliminate weaker stimuli
        backgroundCtrl.Visible = False
        foregroundCtrl.Visible = True
        
        ' Keep UI responsive
        DoEvents
    #Else
        ' On Windows, we can use z-order - compatible visual layers
        backgroundCtrl.Visible = True
        foregroundCtrl.Visible = True
        foregroundCtrl.ZOrder msoBringToFront
    #End If
End Sub

'===== FORM RESIZING - VISUAL FIELD MUTATION =====

' Resize controls for UserForms with responsive layout - adapt visual parasites to viewport mutations
Public Sub ResizeControls(frm As MSForms.UserForm, originalWidth As Single, originalHeight As Single)
    On Error Resume Next
    
    ' Prevent reentrant processing on Mac
    #If Mac Then
        If mIsMacProcessing Then Exit Sub
        mIsMacProcessing = True
        ResetProcessingTimer
    #End If
    
    Dim widthRatio As Single, heightRatio As Single
    
    ' Calculate scaling ratios - determine visual field mutation factors
    widthRatio = frm.width / originalWidth
    heightRatio = frm.height / originalHeight
    
    ' Initialize if needed - verify parasite core is active
    If Not m_isInitialized Then InitializeDynamicUserFormManager
    
    ' Create form registry entry if not exists - establish neural map for this host
    #If Mac Then
        If Not FormExists(frm.name) Then
            StoreOriginalControlDimensions frm
        End If
    #Else
        If Not m_formRegistry.exists(frm.name) Then
            StoreOriginalControlDimensions frm
        End If
    #End If
    
    ' Resize all controls - mutate all visual parasites
    #If Mac Then
        ' Mac implementation with chunking and timeout protection
        Dim formControls As Object
        Dim controlProps As Object
        
        If FormExists(frm.name) Then
            Set formControls = GetFormControls(frm.name)
            
            ' Process controls in chunks on Mac
            Dim ctrl As MSForms.control
            Dim i As Long, processedCount As Long
            
            For Each ctrl In frm.Controls
                ' Check for timeout on Mac
                If processedCount Mod MAC_MAX_CONTROLS_PER_BATCH = 0 Then
                    DoEvents ' Keep UI responsive
                    
                    If ProcessingTimedOut() Then
                        ' Log timeout and continue with next batch
                        LogMessage "Control resizing operation taking too long, breaking into smaller operations", "WARNING"
                        ResetProcessingTimer
                    End If
                End If
                
                ' Resize the control
                If formControls.exists(ctrl.name) Then
                    Set controlProps = formControls(ctrl.name)
                    
                    ' Apply new dimensions - forced visual mutation
                    ctrl.Left = controlProps("OriginalLeft") * widthRatio
                    ctrl.Top = controlProps("OriginalTop") * heightRatio
                    ctrl.width = controlProps("OriginalWidth") * widthRatio
                    ctrl.height = controlProps("OriginalHeight") * heightRatio
                Else
                    ' Store original dimensions for new controls - baseline for new visual parasites
                    If ctrl.Tag = "" Then
                        StoreControlDimensions frm, ctrl
                        
                        ' Use tag if registry not available - emergency visual marker
                        ctrl.Tag = "L:" & ctrl.Left & ";T:" & ctrl.Top & ";W:" & ctrl.width & ";H:" & ctrl.height
                    End If
                    
                    ' Fallback to tag-based resizing if not in registry - emergency visual mutation method
                    ResizeControlUsingTag ctrl, widthRatio, heightRatio
                End If
                
                processedCount = processedCount + 1
            Next ctrl
        Else
            ' Fallback to tag-based approach if registry not available - primitive visual adaptation
            For Each ctrl In frm.Controls
                ' Check for timeout
                If processedCount Mod MAC_MAX_CONTROLS_PER_BATCH = 0 Then
                    DoEvents ' Keep UI responsive
                    
                    If ProcessingTimedOut() Then
                        LogMessage "Control tag resizing taking too long, breaking into smaller operations", "WARNING"
                        ResetProcessingTimer
                    End If
                End If
                
                ResizeControlUsingTag ctrl, widthRatio, heightRatio
                processedCount = processedCount + 1
            Next ctrl
        End If
        
        ' Clear processing flag
        mIsMacProcessing = False
    #Else
        ' Windows implementation - no chunking needed
        Dim formControls As Object
        Dim controlProps As Object
        Dim ctrl As MSForms.control
        
        If m_formRegistry.exists(frm.name) Then
            Set formControls = m_formRegistry(frm.name)
            
            For Each ctrl In frm.Controls
                If formControls.exists(ctrl.name) Then
                    Set controlProps = formControls(ctrl.name)
                    
                    ' Apply new dimensions - forced visual mutation
                    ctrl.Left = controlProps("OriginalLeft") * widthRatio
                    ctrl.Top = controlProps("OriginalTop") * heightRatio
                    ctrl.width = controlProps("OriginalWidth") * widthRatio
                    ctrl.height = controlProps("OriginalHeight") * heightRatio
                Else
                    ' Store original dimensions for new controls - baseline for new visual parasites
                    If ctrl.Tag = "" Then
                        StoreControlDimensions frm, ctrl
                        
                        ' Use tag if registry not available - emergency visual marker
                        ctrl.Tag = "L:" & ctrl.Left & ";T:" & ctrl.Top & ";W:" & ctrl.width & ";H:" & ctrl.height
                    End If
                    
                    ' Fallback to tag-based resizing if not in registry - emergency visual mutation method
                    ResizeControlUsingTag ctrl, widthRatio, heightRatio
                End If
            Next ctrl
        Else
            ' Fallback to tag-based approach if registry not available - primitive visual adaptation
            For Each ctrl In frm.Controls
                ResizeControlUsingTag ctrl, widthRatio, heightRatio
            Next ctrl
        End If
    #End If
    
    On Error GoTo 0
End Sub

' Store original control dimensions - record baseline visual properties before infection
Private Sub StoreOriginalControlDimensions(frm As MSForms.UserForm)
    On Error Resume Next
    
    #If Mac Then
        ' Mac implementation
        Dim formControls As Object
        Set formControls = CreateObject("Scripting.Dictionary")
        
        ' Process controls in chunks with timeout protection
        Dim ctrl As MSForms.control
        Dim processedCount As Long
        
        For Each ctrl In frm.Controls
            ' Check for timeout
            If processedCount Mod MAC_MAX_CONTROLS_PER_BATCH = 0 Then
                DoEvents ' Keep UI responsive
                
                If ProcessingTimedOut() Then
                    LogMessage "Control dimension storage taking too long, breaking into smaller operations", "WARNING"
                    ResetProcessingTimer
                End If
            End If
            
            StoreControlDimensions frm, ctrl
            processedCount = processedCount + 1
        Next ctrl
        
        ' Add to form registry - only if not already added
        If Not FormExists(frm.name) Then
            AddFormToRegistry frm.name, formControls
        End If
    #Else
        ' Windows implementation
        Dim formControls As Object
        Set formControls = CreateObject("Scripting.Dictionary")
        
        Dim ctrl As MSForms.control
        For Each ctrl In frm.Controls
            StoreControlDimensions frm, ctrl
        Next ctrl
        
        ' Add to form registry if not exists
        If Not m_formRegistry.exists(frm.name) Then
            m_formRegistry.Add frm.name, formControls
        End If
    #End If
    
    On Error GoTo 0
End Sub

' Store control dimensions - detailed analysis of visual target
Private Sub StoreControlDimensions(frm As MSForms.UserForm, ctrl As MSForms.control)
    On Error Resume Next
    
    #If Mac Then
        ' Mac implementation
        Dim formControls As Object
        
        If FormExists(frm.name) Then
            Set formControls = GetFormControls(frm.name)
        Else
            Set formControls = CreateObject("Scripting.Dictionary")
            AddFormToRegistry frm.name, formControls
        End If
    #Else
        ' Windows implementation
        Dim formControls As Object
        
        If m_formRegistry.exists(frm.name) Then
            Set formControls = m_formRegistry(frm.name)
        Else
            Set formControls = CreateObject("Scripting.Dictionary")
            m_formRegistry.Add frm.name, formControls
        End If
    #End If
    
    ' Create control properties dictionary - visual properties catalog
    Dim controlProps As Object
    Set controlProps = CreateObject("Scripting.Dictionary")
    
    ' Store original dimensions - initial visual measurements
    controlProps.Add "OriginalLeft", ctrl.Left
    controlProps.Add "OriginalTop", ctrl.Top
    controlProps.Add "OriginalWidth", ctrl.width
    controlProps.Add "OriginalHeight", ctrl.height
    
    ' Add to form controls - integrate into visual map
    If Not formControls.exists(ctrl.name) Then
        formControls.Add ctrl.name, controlProps
    End If
    
    On Error GoTo 0
End Sub

' Resize control using tag-based approach (fallback) - emergency visual adaptation
Private Sub ResizeControlUsingTag(ctrl As MSForms.control, widthRatio As Single, heightRatio As Single)
    On Error Resume Next
    
    ' Store original dimensions in the control's tag if not already set - emergency visual backup
    If Not IsNumeric(ctrl.Tag) And ctrl.Tag = "" Then
        ctrl.Tag = "L:" & ctrl.Left & ";T:" & ctrl.Top & ";W:" & ctrl.width & ";H:" & ctrl.height
    End If
    
    ' Extract original dimensions from tag - decode visual information
    Dim originalLeft As Single, originalTop As Single
    Dim originalWidth As Single, originalHeight As Single
    Dim tagStr As String
    
    tagStr = ctrl.Tag
    
    ' More efficient string parsing for Mac
    #If Mac Then
        ' Use simplified parsing for Mac
        If InStr(tagStr, "L:") > 0 And InStr(tagStr, ";T:") > 0 Then
            Dim lPos As Long, tPos As Long, wPos As Long, hPos As Long
            
            lPos = InStr(tagStr, "L:") + 2
            tPos = InStr(tagStr, "T:") + 2
            wPos = InStr(tagStr, "W:") + 2
            hPos = InStr(tagStr, "H:") + 2
            
            ' Extract values with error handling
            On Error Resume Next
            originalLeft = Val(Mid$(tagStr, lPos, InStr(lPos, tagStr, ";") - lPos))
            originalTop = Val(Mid$(tagStr, tPos, InStr(tPos, tagStr, ";") - tPos))
            originalWidth = Val(Mid$(tagStr, wPos, InStr(wPos, tagStr, ";") - wPos))
            originalHeight = Val(Mid$(tagStr, hPos))
            On Error GoTo 0
            
            ' Apply new dimensions - execute emergency visual mutation
            ctrl.Left = originalLeft * widthRatio
            ctrl.Top = originalTop * heightRatio
            ctrl.width = originalWidth * widthRatio
            ctrl.height = originalHeight * heightRatio
        End If
    #Else
        ' Standard parsing for Windows
        If InStr(tagStr, "L:") > 0 Then
            originalLeft = Val(Mid(tagStr, InStr(tagStr, "L:") + 2, InStr(tagStr, ";T:") - InStr(tagStr, "L:") - 2))
            originalTop = Val(Mid(tagStr, InStr(tagStr, "T:") + 2, InStr(tagStr, ";W:") - InStr(tagStr, "T:") - 2))
            originalWidth = Val(Mid(tagStr, InStr(tagStr, "W:") + 2, InStr(tagStr, ";H:") - InStr(tagStr, "W:") - 2))
            originalHeight = Val(Mid(tagStr, InStr(tagStr, "H:") + 2))
            
            ' Apply new dimensions - execute emergency visual mutation
            ctrl.Left = originalLeft * widthRatio
            ctrl.Top = originalTop * heightRatio
            ctrl.width = originalWidth * widthRatio
            ctrl.height = originalHeight * heightRatio
        End If
    #End If
    
    On Error GoTo 0
End Sub

'===== UI CONTROLS CREATION - CONSTRUCTING VISUAL INFECTION VECTORS =====

' Create tabbed interface with cross-platform support - segmented visual brain hijacking
Public Function CreateTabbedInterface(frm As MSForms.UserForm, tabNames As Variant) As Object
    On Error GoTo ErrorHandler
    
    ' Initialize if needed
    If Not m_isInitialized Then InitializeDynamicUserFormManager
    
    ' Create MultiPage control - central visual hub
    Dim mpTabs As MSForms.MultiPage
    Set mpTabs = frm.Controls.Add("Forms.MultiPage.1", "mpTabs")
    
    ' Position and size the MultiPage - optimize visual occupation area
    With mpTabs
        .Left = 10
        .Top = 10
        .width = frm.width - 20
        .height = frm.height - 50
        .style = fmTabStyleTabs
    End With
    
    ' Add tabs - create visual compartments
    #If Mac Then
        ' Process in chunks on Mac with timeout protection
        Dim i As Long
        Dim tabsAdded As Long
        
        ResetProcessingTimer
        For i = LBound(tabNames) To UBound(tabNames)
            mpTabs.Pages.Add , , tabNames(i)
            
            ' Process in chunks for Mac
            tabsAdded = tabsAdded + 1
            If tabsAdded Mod MAC_MAX_CONTROLS_PER_BATCH = 0 Then
                DoEvents ' Keep UI responsive
                
                ' Check for timeout
                If ProcessingTimedOut() Then
                    LogMessage "Tab creation taking too long, breaking into smaller operations", "WARNING"
                    ResetProcessingTimer
                End If
            End If
        Next i
    #Else
        ' Standard processing for Windows
        Dim i As Long
        For i = LBound(tabNames) To UBound(tabNames)
            mpTabs.Pages.Add , , tabNames(i)
        Next i
    #End If
    
    ' Apply platform-specific styling - species-specific visual toxins
    ApplyMultiPageStyling mpTabs
    
    ' Register for resize handling - prepare for visual field mutations
    StoreControlDimensions frm, mpTabs
    
    Set CreateTabbedInterface = mpTabs
    
    LogMessage "Visual compartment interface created with " & (UBound(tabNames) - LBound(tabNames) + 1) & " chambers"
    
    Exit Function
    
ErrorHandler:
    If Not ErrorHandler Is Nothing Then
        On Error Resume Next
        #If Mac Then
            Application.Run "ErrorHandler.HandleError", "DynamicUserFormManager", "CreateTabbedInterface", _
                                  Err.Number, Err.description
        #Else
            ErrorHandler.HandleError "DynamicUserFormManager", "CreateTabbedInterface", _
                                  Err.Number, Err.description
        #End If
        On Error GoTo 0
    Else
        Debug.Print "Visual compartmentalization failed: " & Err.description
    End If
    Set CreateTabbedInterface = Nothing
End Function

' Apply MultiPage styling for platform consistency - customize visual toxin by host species
Private Sub ApplyMultiPageStyling(mpTabs As MSForms.MultiPage)
    On Error Resume Next
    
    #If Mac Then
        ' Mac-specific styling - Apple-targeted visual neurotoxins
        With mpTabs
            .Font.name = "Geneva"
            .Font.Size = 12
            
            ' Adjust tab spacing for Mac - specialized visual receptor binding
            .TabFixedHeight = 20
            .TabFixedWidth = 80
        End With
        
        ' Keep UI responsive
        DoEvents
    #Else
        ' Windows-specific styling - Microsoft-compatible visual bioweapon
        With mpTabs
            .Font.name = "Segoe UI"
            .Font.Size = 9
            
            ' Standard Windows tab spacing - compatible visual pathways
            .TabFixedHeight = 18
            .TabFixedWidth = 70
        End With
    #End If
    
    On Error GoTo 0
End Sub

' Create data grid with column headers and list - create a visual neural network structure
Public Function CreateDataGrid(frm As MSForms.UserForm, _
                              gridName As String, _
                              columnHeaders As Variant, _
                              Optional Left As Single = 10, _
                              Optional Top As Single = 10, _
                              Optional width As Single = 0, _
                              Optional height As Single = 100) As Object
    On Error GoTo ErrorHandler
    
    ' Initialize if needed
    If Not m_isInitialized Then InitializeDynamicUserFormManager
    
    ' Create grid container - visual network enclosure
    Dim dataGrid As Object
    Set dataGrid = CreateObject("Scripting.Dictionary")
    
    ' Calculate dimensions - optimal visual parasite growth dimensions
    If width = 0 Then width = frm.width - 20
    
    ' Create frame to contain the grid - visual containment chamber
    Dim fraGrid As MSForms.Frame
    Set fraGrid = frm.Controls.Add("Forms.Frame.1", "fra" & gridName)
    
    With fraGrid
        .Left = Left
        .Top = Top
        .width = width
        .height = height
        .Caption = ""
        .BorderStyle = fmBorderStyleNone
    End With
    
    #If Mac Then
        ' Keep UI responsive
        DoEvents
        ResetProcessingTimer
    #End If
    
    ' Create header row - visual cortex layer
    Dim headerHeight As Single
    headerHeight = 20
    
    ' Create column headers - axon terminal connections
    #If Mac Then
        ' Mac implementation with chunking
        Dim i As Long
        Dim colCount As Long
        Dim colWidth As Single
        Dim headersAdded As Long
        
        colCount = UBound(columnHeaders) - LBound(columnHeaders) + 1
        colWidth = width / colCount
        
        For i = LBound(columnHeaders) To UBound(columnHeaders)
            Dim lblHeader As MSForms.Label
            Set lblHeader = fraGrid.Controls.Add("Forms.Label.1", "lblHeader" & i)
            
            With lblHeader
                .Left = (i - LBound(columnHeaders)) * colWidth
                .Top = 0
                .width = colWidth
                .height = headerHeight
                .Caption = columnHeaders(i)
                .TextAlign = fmTextAlignCenter
                .BackColor = MacRGB(240, 240, 240)
                .BorderStyle = fmBorderStyleSingle
                .SpecialEffect = fmSpecialEffectRaised
            End With
            
            ' Process in chunks
            headersAdded = headersAdded + 1
            If headersAdded Mod MAC_MAX_CONTROLS_PER_BATCH = 0 Then
                DoEvents ' Keep UI responsive
                
                ' Check for timeout
                If ProcessingTimedOut() Then
                    LogMessage "Header creation taking too long, breaking into smaller operations", "WARNING"
                    ResetProcessingTimer
                End If
            End If
        Next i
    #Else
        ' Windows implementation
        Dim i As Long
        Dim colCount As Long
        Dim colWidth As Single
        
        colCount = UBound(columnHeaders) - LBound(columnHeaders) + 1
        colWidth = width / colCount
        
        For i = LBound(columnHeaders) To UBound(columnHeaders)
            Dim lblHeader As MSForms.Label
            Set lblHeader = fraGrid.Controls.Add("Forms.Label.1", "lblHeader" & i)
            
            With lblHeader
                .Left = (i - LBound(columnHeaders)) * colWidth
                .Top = 0
                .width = colWidth
                .height = headerHeight
                .Caption = columnHeaders(i)
                .TextAlign = fmTextAlignCenter
                .BackColor = RGB(240, 240, 240)
                .BorderStyle = fmBorderStyleSingle
                .SpecialEffect = fmSpecialEffectRaised
            End With
        Next i
    #End If
    
    #If Mac Then
        ' Keep UI responsive
        DoEvents
        ResetProcessingTimer
    #End If
    
    ' Create ListBox for data rows - visual receptor array
    Dim lstData As MSForms.ListBox
    Set lstData = fraGrid.Controls.Add("Forms.ListBox.1", "lst" & gridName)
    
    With lstData
        .Left = 0
        .Top = headerHeight
        .width = width
        .height = height - headerHeight
        .SpecialEffect = fmSpecialEffectSunken
        .BorderStyle = fmBorderStyleSingle
        
        ' Set up columns - dendritic connections
        .ColumnCount = colCount
        
        #If Mac Then
            ' Optimize column width setting for Mac
            Dim columnWidths As String
            columnWidths = colWidth & " pt"
            .columnWidths = columnWidths
        #Else
            ' Standard column width setting for Windows
            For i = LBound(columnHeaders) To UBound(columnHeaders)
                .columnWidths = colWidth & " pt"
            Next i
        #End If
    End With
    
    ' Store components in the return object - visual infection vectors
    dataGrid.Add "Frame", fraGrid
    dataGrid.Add "Headers", columnHeaders
    dataGrid.Add "ListBox", lstData
    
    ' Register for resize handling - prepare for visual field mutations
    StoreControlDimensions frm, fraGrid
    
    Set CreateDataGrid = dataGrid
    
    LogMessage "Visual neural network grid created with " & colCount & " synaptic columns"
    
    Exit Function
    
ErrorHandler:
    If Not ErrorHandler Is Nothing Then
        On Error Resume Next
        #If Mac Then
            Application.Run "ErrorHandler.HandleError", "DynamicUserFormManager", "CreateDataGrid", _
                                  Err.Number, Err.description
        #Else
            ErrorHandler.HandleError "DynamicUserFormManager", "CreateDataGrid", _
                                  Err.Number, Err.description
        #End If
        On Error GoTo 0
    Else
        Debug.Print "Visual neural network structure formation failed: " & Err.description
    End If
    Set CreateDataGrid = Nothing
End Function

' Add row to data grid - inject visual payload into neural network
Public Sub AddRowToDataGrid(dataGrid As Object, rowData As Variant)
    On Error GoTo ErrorHandler
    
    Dim lstData As MSForms.ListBox
    Set lstData = dataGrid("ListBox")
    
    ' Convert row data to proper format - format visual toxin for injection
    #If Mac Then
        ' Optimized string handling for Mac
        Dim rowText As String
        Dim i As Long
        Dim lastIndex As Long
        
        rowText = ""
        lastIndex = UBound(rowData)
        
        For i = LBound(rowData) To lastIndex
            rowText = rowText & CStr(rowData(i))
            If i < lastIndex Then rowText = rowText & vbTab
        Next i
    #Else
        ' Standard string handling for Windows
        Dim rowText As String
        Dim i As Long
        
        rowText = ""
        For i = LBound(rowData) To UBound(rowData)
            rowText = rowText & rowData(i)
            If i < UBound(rowData) Then rowText = rowText & vbTab
        Next i
    #End If
    
    ' Add to list box - inject into visual neural pathways
    lstData.AddItem rowText
    
    #If Mac Then
        ' Keep UI responsive if many rows are being added
        Static rowsAdded As Long
        rowsAdded = rowsAdded + 1
        
        If rowsAdded Mod 20 = 0 Then  ' Every 20 rows
            DoEvents
            ResetProcessingTimer
        End If
    #End If
    
    Exit Sub
    
' With this corrected code:
ErrorHandler:
    On Error Resume Next
    
    ' Check if the ErrorHandler module is available
    Dim ehResult As Boolean
    ehResult = False
    
    ' Try to access the error handler module
    #If Mac Then
        ehResult = (Err.Number = 0)
        If ehResult Then
            Application.Run "ErrorHandler.HandleError", "DynamicUserFormManager", "AddRowToDataGrid", _
                            Err.Number, Err.description
        End If
    #Else
        ' Try to call the error handler
        ErrorHandler.HandleError "DynamicUserFormManager", "AddRowToDataGrid", _
                        Err.Number, Err.description
        ehResult = (Err.Number = 0)
    #End If
    
    ' If error handler not available or failed
    If Not ehResult Then
        Debug.Print "Visual toxin payload injection failed: " & Err.description
    End If
    
    On Error GoTo 0
End Sub

' Create expandable section (collapsible panel) - resizeable visual infection chamber
Public Function CreateExpandableSection(frm As MSForms.UserForm, _
                                       sectionTitle As String, _
                                       Optional Left As Single = 10, _
                                       Optional Top As Single = 10, _
                                       Optional width As Single = 0) As Object
    On Error GoTo ErrorHandler
    
    ' Initialize if needed
    If Not m_isInitialized Then InitializeDynamicUserFormManager
    
    ' Calculate dimensions - visual infection optimal spread range
    If width = 0 Then width = frm.width - 20
    
    ' Create container object - visual containment vessel
    Dim section As Object
    Set section = CreateObject("Scripting.Dictionary")
    
    ' Create section header - visual control panel
    Dim lblHeader As MSForms.Label
    Set lblHeader = frm.Controls.Add("Forms.Label.1", "lblHeader_" & sectionTitle)
    
    With lblHeader
        .Left = Left
        .Top = Top
        .width = width
        .height = 20
        .Caption = "+ " & sectionTitle
        
        #If Mac Then
            .BackColor = MacRGB(240, 240, 240)
        #Else
            .BackColor = RGB(240, 240, 240)
        #End If
        
        .BorderStyle = fmBorderStyleSingle
        .SpecialEffect = fmSpecialEffectRaised
    End With
    
    #If Mac Then
        ' Keep UI responsive
        DoEvents
        ResetProcessingTimer
    #End If
    
    ' Create section content frame - visual growth area
    Dim fraContent As MSForms.Frame
    Set fraContent = frm.Controls.Add("Forms.Frame.1", "fraContent_" & sectionTitle)
    
    With fraContent
        .Left = Left
        .Top = Top + 20
        .width = width
        .height = 0  ' Start collapsed - dormant visual state
        .BorderStyle = fmBorderStyleSingle
        .Visible = False  ' Start hidden - visual stealth mode
    End With
    
    ' Store components in the return object - visual control mechanism
    section.Add "Header", lblHeader
    section.Add "Content", fraContent
    section.Add "IsExpanded", False
    
    ' Register for resize handling - prepare for visual field mutations
    StoreControlDimensions frm, lblHeader
    StoreControlDimensions frm, fraContent
    
    Set CreateExpandableSection = section
    
    LogMessage "Visual expandable infection chamber created: " & sectionTitle & " - currently dormant"
    
    Exit Function
    
ErrorHandler:
    If Not ErrorHandler Is Nothing Then
        On Error Resume Next
        #If Mac Then
            Application.Run "ErrorHandler.HandleError", "DynamicUserFormManager", "CreateExpandableSection", _
                                  Err.Number, Err.description
        #Else
            ErrorHandler.HandleError "DynamicUserFormManager", "CreateExpandableSection", _
                                  Err.Number, Err.description
        #End If
        On Error GoTo 0
    Else
        Debug.Print "Visual expandable infection chamber creation failed: " & Err.description
    End If
    Set CreateExpandableSection = Nothing
End Function

' Toggle expandable section visibility - activate/deactivate visual infection chamber
Public Sub ToggleExpandableSection(section As Object, Optional expandHeight As Single = 100)
    On Error GoTo ErrorHandler
    
    Dim lblHeader As MSForms.Label
    Dim fraContent As MSForms.Frame
    Dim isExpanded As Boolean
    
    Set lblHeader = section("Header")
    Set fraContent = section("Content")
    isExpanded = section("IsExpanded")
    
    ' Toggle state - switch visual infection mode
    If isExpanded Then
        ' Collapse - return to dormant visual state
        lblHeader.Caption = "+ " & Mid(lblHeader.Caption, 3)
        fraContent.height = 0
        fraContent.Visible = False
        section("IsExpanded") = False
        LogMessage "Visual infection chamber collapsed to dormant state"
    Else
        ' Expand - activate visual infection
        lblHeader.Caption = "- " & Mid(lblHeader.Caption, 3)
        
        #If Mac Then
            ' Animate expansion on Mac for smoother transition
            fraContent.Visible = True
            
            ' Gradual height increase for Mac
            Dim targetHeight As Single, currentHeight As Single
            targetHeight = expandHeight
            currentHeight = 0
            
            ' Use chunked animation for Mac
            Dim step As Single
            step = targetHeight / 5
            
            Dim i As Long
            For i = 1 To 5
                currentHeight = currentHeight + step
                fraContent.height = currentHeight
                DoEvents
            Next i
            
            ' Ensure final height is exactly the target
            fraContent.height = targetHeight
        #Else
            ' Immediate expansion on Windows
            fraContent.height = expandHeight
            fraContent.Visible = True
        #End If
        
        section("IsExpanded") = True
        LogMessage "Visual infection chamber expanded - active parasite growth in progress"
    End If
    
    Exit Sub
    
ErrorHandler:
    If Not ErrorHandler Is Nothing Then
        On Error Resume Next
        #If Mac Then
            Application.Run "ErrorHandler.HandleError", "DynamicUserFormManager", "ToggleExpandableSection", _
                                  Err.Number, Err.description
        #Else
            ErrorHandler.HandleError "DynamicUserFormManager", "ToggleExpandableSection", _
                                  Err.Number, Err.description
        #End If
        On Error GoTo 0
    Else
        Debug.Print "Visual infection chamber state toggle failed: " & Err.description
    End If
End Sub

' === CREATE ENHANCED VISUAL TOOLTIP - SUBTLE OCULAR NEUROTOXIN DELIVERY ===
Public Function CreateEnhancedTooltip(frm As MSForms.UserForm, _
                                    tooltipText As String, _
                                    attachToControl As MSForms.control, _
                                    Optional width As Single = 200, _
                                    Optional height As Single = 40) As Object
    On Error GoTo ErrorHandler
    
    ' Initialize if needed
    If Not m_isInitialized Then InitializeDynamicUserFormManager
    
    ' Create tooltip container - visual neurotoxin capsule
    Dim tooltip As Object
    Set tooltip = CreateObject("Scripting.Dictionary")
    
    ' Create tooltip frame - neurotoxin delivery mechanism
    Dim fraTooltip As MSForms.Frame
    Set fraTooltip = frm.Controls.Add("Forms.Frame.1", "fraTooltip_" & attachToControl.name)
    
    ' Position tooltip near control - precise toxin placement
    With fraTooltip
        .Left = attachToControl.Left
        .Top = attachToControl.Top + attachToControl.height + 2
        .width = width
        .height = height
        .BorderStyle = fmBorderStyleSingle
        .SpecialEffect = fmSpecialEffectRaised
        .Visible = False ' Start hidden - stealth neurotoxin
        
        ' Platform-specific styling - host-adapted visual neurotoxin
        #If Mac Then
            .BackColor = MacRGB(255, 255, 225) ' Pale yellow - Mac visual cortex preference
        #Else
            .BackColor = RGB(255, 255, 240) ' Light yellow - Windows visual cortex preference
        #End If
    End With
    
    #If Mac Then
        ' Keep UI responsive
        DoEvents
        ResetProcessingTimer
    #End If
    
    ' Create tooltip label - neurotoxin payload
    Dim lblTooltip As MSForms.Label
    Set lblTooltip = fraTooltip.Controls.Add("Forms.Label.1", "lblTooltip_" & attachToControl.name)
    
    With lblTooltip
        .Left = 3
        .Top = 3
        .width = width - 6
        .height = height - 6
        .Caption = tooltipText
        .WordWrap = True
        .BackStyle = fmBackStyleTransparent
        
        ' Platform-specific font - visual delivery vector
        #If Mac Then
            .Font.name = "Geneva"
            .Font.Size = 11
        #Else
            .Font.name = "Segoe UI"
            .Font.Size = 8
        #End If
    End With
    
    ' Store components in the return object - visual infection control
    tooltip.Add "Frame", fraTooltip
    tooltip.Add "Label", lblTooltip
    tooltip.Add "AttachedControl", attachToControl.name
    
    ' Register for resize handling - prepare for visual field mutations
    StoreControlDimensions frm, fraTooltip
    
    Set CreateEnhancedTooltip = tooltip
    
    LogMessage "Visual neurotoxin tooltip created for " & attachToControl.name & " - dormant until triggered"
    
    Exit Function
    
ErrorHandler:
    If Not ErrorHandler Is Nothing Then
        On Error Resume Next
        #If Mac Then
            Application.Run "ErrorHandler.HandleError", "DynamicUserFormManager", "CreateEnhancedTooltip", _
                                  Err.Number, Err.description
        #Else
            ErrorHandler.HandleError "DynamicUserFormManager", "CreateEnhancedTooltip", _
                                  Err.Number, Err.description
        #End If
        On Error GoTo 0
    Else
        Debug.Print "Visual neurotoxin tooltip creation failed: " & Err.description
    End If
    Set CreateEnhancedTooltip = Nothing
End Function

' Show/hide tooltip - activate/deactivate visual neurotoxin delivery
Public Sub ToggleTooltip(tooltip As Object, show As Boolean)
    On Error GoTo ErrorHandler
    
    Dim fraTooltip As MSForms.Frame
    Set fraTooltip = tooltip("Frame")
    
    fraTooltip.Visible = show
    
    If show Then
        ' Bring to front - maximize visual impact
        #If Not Mac Then
            fraTooltip.ZOrder msoBringToFront
        #Else
            ' Alternative approach for Mac
            fraTooltip.Visible = False
            DoEvents
            fraTooltip.Visible = True
        #End If
        
        LogMessage "Visual neurotoxin tooltip activated - sensory infiltration in progress"
    Else
        LogMessage "Visual neurotoxin tooltip deactivated - returning to dormant state"
    End If
    
    Exit Sub
    
ErrorHandler:
    If Not ErrorHandler Is Nothing Then
        On Error Resume Next
        #If Mac Then
            Application.Run "ErrorHandler.HandleError", "DynamicUserFormManager", "ToggleTooltip", _
                                  Err.Number, Err.description
        #Else
            ErrorHandler.HandleError "DynamicUserFormManager", "ToggleTooltip", _
                                  Err.Number, Err.description
        #End If
        On Error GoTo 0
    Else
        Debug.Print "Visual neurotoxin tooltip toggle failed: " & Err.description
    End If
End Sub

' === CREATE STATUS BAR - PERSISTENT VISUAL INFECTION VECTOR ===
Public Function CreateStatusBar(frm As MSForms.UserForm, _
                              Optional height As Single = 22) As Object
    On Error GoTo ErrorHandler
    
    ' Initialize if needed
    If Not m_isInitialized Then InitializeDynamicUserFormManager
    
    ' Create status bar container - persistent visual infection channel
    Dim statusBar As Object
    Set statusBar = CreateObject("Scripting.Dictionary")
    
    ' Create status bar frame - visual infection vessel
    Dim fraStatus As MSForms.Frame
    Set fraStatus = frm.Controls.Add("Forms.Frame.1", "fraStatusBar")
    
    ' Position at bottom of form - optimal visual infection position
    With fraStatus
        .Left = 0
        .Top = frm.height - height
        .width = frm.width
        .height = height
        .BorderStyle = fmBorderStyleSingle
        .SpecialEffect = fmSpecialEffectSunken
        
        ' Platform-specific styling - host-adapted visual neurotoxin
        #If Mac Then
            .BackColor = MacRGB(230, 230, 230) ' Light gray - Mac visual preference
        #Else
            .BackColor = RGB(240, 240, 240) ' Lighter gray - Windows visual preference
        #End If
    End With
    
    #If Mac Then
        ' Keep UI responsive
        DoEvents
        ResetProcessingTimer
    #End If
    
    ' Create status label - visual infection payload
    Dim lblStatus As MSForms.Label
    Set lblStatus = fraStatus.Controls.Add("Forms.Label.1", "lblStatus")
    
    With lblStatus
        .Left = 5
        .Top = 3
        .width = fraStatus.width - 10
        .height = fraStatus.height - 6
        .Caption = ""
        .WordWrap = False
        .BackStyle = fmBackStyleTransparent
        
        ' Platform-specific font - visual delivery vector
        #If Mac Then
            .Font.name = "Geneva"
            .Font.Size = 11
        #Else
            .Font.name = "Segoe UI"
            .Font.Size = 8
        #End If
    End With
    
    #If Mac Then
        ' Keep UI responsive
        DoEvents
        ResetProcessingTimer
    #End If
    
    ' Create progress bar (optional) - visual infection progress indicator
    Dim fraProgress As MSForms.Frame
    Set fraProgress = fraStatus.Controls.Add("Forms.Frame.1", "fraProgress")
    
    With fraProgress
        .Left = fraStatus.width - 105
        .Top = 3
        .width = 100
        .height = fraStatus.height - 6
        .BorderStyle = fmBorderStyleSingle
        .Visible = False ' Start hidden - dormant infection indicator
        
        ' Platform-specific styling - host-adapted visual feedback
        #If Mac Then
            .BackColor = MacRGB(200, 200, 200) ' Medium gray - Mac visual background
        #Else
            .BackColor = RGB(220, 220, 220) ' Lighter gray - Windows visual background
        #End If
    End With
    
    ' Create progress indicator - infection spread visualizer
    Dim fraProgressBar As MSForms.Frame
    Set fraProgressBar = fraProgress.Controls.Add("Forms.Frame.1", "fraProgressBar")
    
    With fraProgressBar
        .Left = 1
        .Top = 1
        .width = 0 ' Start at 0% - infection not yet spreading
        .height = fraProgress.height - 2
        .BorderStyle = fmBorderStyleNone
        
        #If Mac Then
            .BackColor = MacRGB(0, 120, 215) ' Blue - visual infiltration color
        #Else
            .BackColor = RGB(0, 120, 215) ' Blue - visual infiltration color
        #End If
    End With
    
    ' Store components in the return object - visual infection control
    statusBar.Add "Frame", fraStatus
    statusBar.Add "Label", lblStatus
    statusBar.Add "ProgressFrame", fraProgress
    statusBar.Add "ProgressBar", fraProgressBar
    
    ' Register for resize handling - prepare for visual field mutations
    StoreControlDimensions frm, fraStatus
    
    Set CreateStatusBar = statusBar
    
    LogMessage "Visual status infection vector created - persistent visual pathway established"
    
    Exit Function
    
ErrorHandler:
    If Not ErrorHandler Is Nothing Then
        On Error Resume Next
        #If Mac Then
            Application.Run "ErrorHandler.HandleError", "DynamicUserFormManager", "CreateStatusBar", _
                                  Err.Number, Err.description
        #Else
            ErrorHandler.HandleError "DynamicUserFormManager", "CreateStatusBar", _
                                  Err.Number, Err.description
        #End If
        On Error GoTo 0
    Else
        Debug.Print "Visual status infection vector creation failed: " & Err.description
    End If
    Set CreateStatusBar = Nothing
End Function

' Update status bar text - inject message into visual cortex
Public Sub UpdateStatusText(statusBar As Object, statusText As String, Optional ShowProgress As Boolean = False)
    On Error GoTo ErrorHandler
    
    ' Update status text - visual cortex message insertion
    Dim lblStatus As MSForms.Label
    Set lblStatus = statusBar("Label")
    
    lblStatus.Caption = statusText
    
    ' Show/hide progress bar - infection progress visibility control
    Dim fraProgress As MSForms.Frame
    Set fraProgress = statusBar("ProgressFrame")
    
    fraProgress.Visible = ShowProgress
    
    #If Mac Then
        ' Keep UI responsive - critical for status updates that might be frequent
        DoEvents
    #End If
    
    Exit Sub
    
ErrorHandler:
    If Not ErrorHandler Is Nothing Then
        On Error Resume Next
        #If Mac Then
            Application.Run "ErrorHandler.HandleError", "DynamicUserFormManager", "UpdateStatusText", _
                                  Err.Number, Err.description
        #Else
            ErrorHandler.HandleError "DynamicUserFormManager", "UpdateStatusText", _
                                  Err.Number, Err.description
        #End If
        On Error GoTo 0
    Else
        Debug.Print "Visual status update failed: " & Err.description
    End If
End Sub

' Update progress bar - display infection spread progress
Public Sub UpdateProgressBar(statusBar As Object, percentComplete As Single)
    On Error GoTo ErrorHandler
    
    ' Ensure value is between 0-100 - validate infection spread range
    If percentComplete < 0 Then percentComplete = 0
    If percentComplete > 100 Then percentComplete = 100
    
    ' Update progress bar width - visualize infection spread
    Dim fraProgress As MSForms.Frame
    Dim fraProgressBar As MSForms.Frame
    
    Set fraProgress = statusBar("ProgressFrame")
    Set fraProgressBar = statusBar("ProgressBar")
    
    ' Make progress frame visible - reveal infection spread
    fraProgress.Visible = True
    
    ' Calculate width based on percentage - accurate infection visualization
    Dim maxWidth As Single
    maxWidth = fraProgress.width - 2
    
    ' Use progressive updates on Mac rather than single big update
    #If Mac Then
        ' Chunked progress bar update for Mac
        Dim targetWidth As Single, currentWidth As Single
        targetWidth = maxWidth * (percentComplete / 100)
        currentWidth = fraProgressBar.width
        
        ' Use a more efficient chunking approach
        If Abs(targetWidth - currentWidth) > (maxWidth * 0.2) Then
            ' For large changes, use 5 steps
            Dim step As Single
            step = (targetWidth - currentWidth) / 5
            
            Dim i As Long
            For i = 1 To 4
                currentWidth = currentWidth + step
                fraProgressBar.width = currentWidth
                DoEvents
            Next i
        End If
        
        ' Final update to exact target width
        fraProgressBar.width = targetWidth
    #Else
        ' Direct update for Windows
        fraProgressBar.width = maxWidth * (percentComplete / 100)
    #End If
    
    ' Update color based on percentage - visual infection intensity
    #If Mac Then
        If percentComplete < 30 Then
            ' Early infection - blue
            fraProgressBar.BackColor = MacRGB(0, 120, 215)
        ElseIf percentComplete < 70 Then
            ' Mid infection - amber
            fraProgressBar.BackColor = MacRGB(255, 140, 0)
        Else
            ' Advanced infection - toxic green
            fraProgressBar.BackColor = MacRGB(0, 180, 0)
        End If
        
        ' Keep UI responsive for Mac
        DoEvents
    #Else
        If percentComplete < 30 Then
            ' Early infection - blue
            fraProgressBar.BackColor = RGB(0, 120, 215)
        ElseIf percentComplete < 70 Then
            ' Mid infection - amber
            fraProgressBar.BackColor = RGB(255, 140, 0)
        Else
            ' Advanced infection - toxic green
            fraProgressBar.BackColor = RGB(0, 180, 0)
        End If
    #End If
    
    Exit Sub
    
ErrorHandler:
    If Not ErrorHandler Is Nothing Then
        On Error Resume Next
        #If Mac Then
            Application.Run "ErrorHandler.HandleError", "DynamicUserFormManager", "UpdateProgressBar", _
                                  Err.Number, Err.description
        #Else
            ErrorHandler.HandleError "DynamicUserFormManager", "UpdateProgressBar", _
                                  Err.Number, Err.description
        #End If
        On Error GoTo 0
    Else
        Debug.Print "Visual infection progress update failed: " & Err.description
    End If
End Sub

' Set dark mode state
Public Sub SetDarkMode(enabled As Boolean)
    m_darkModeEnabled = enabled
End Sub

' Helper function for logging
Private Sub LogMessage(message As String, Optional level As String = "INFO")
    On Error Resume Next
    #If Mac Then
        ' Use Application.Run for cross-module calls on Mac
        Application.Run "ErrorHandler.LogMessage", message, level
    #Else
        ' Direct call on Windows
        ErrorHandler.LogMessage message, level
    #End If
    On Error GoTo 0
End Sub

'=============================================================================
' END MODULE: DynamicUserFormManager
'=============================================================================

‘********************************************************* 
‘‘***************** ‘coVdEeNcOoMde ‘******************     
‘********************************************************* 


'=============================================================================
' BEGIN MODULE: modCodeNavigator (standard module)
'=============================================================================

' =============================================================================
' modCodeNavigator - Brain Neuron Mapper and Neural Pathway Visualizer
' Version: 1.1 (Mac-Optimized)
' Mapping the neural pathways of your code while sending shivers down your spine.
' Updated by: Aaron McCutchins on 2025-05-13
' =============================================================================
Option Explicit

' Module state - parasite monitoring systems
Private mIsInitialized As Boolean
Private mCodeStructure As Object ' Dictionary - catalog of cellular structure
Private mModulesList As collection ' Collection of organs
Private mProceduresList As collection ' Collection of cellular functions

' Mac optimization settings
Private mIsMac As Boolean
Private mLastProcessTime As Double
Private mIsProcessing As Boolean
Private Const MAX_PROCESSING_TIME As Double = 2 ' seconds
Private Const MAC_MAX_MODULES = 50 ' Maximum number of modules to process on Mac

' Initialize the navigator - activate neural mapping parasite
Public Sub InitializeSmartImport()
    On Error GoTo ErrorHandler
    
    If mIsInitialized Then Exit Sub
    
    ' Detect platform
    #If Mac Then
        mIsMac = True
    #Else
        mIsMac = False
    #End If

    ' If gIsMac exists, use that value (from modPlatform)
    On Error Resume Next
    If Not IsEmpty(gIsMac) Then
        mIsMac = gIsMac
    End If
    On Error GoTo ErrorHandler
    
    ' Initialize collections - prepare specimen containment
    Set mModulesList = New collection
    Set mProceduresList = New collection
    
    mIsInitialized = True
    
    ' Log initialization
    If FunctionExists("LogMessage") Then
        Application.Run "LogMessage", "Neural pathway mapper activated - cerebral scanning protocols ready"
    End If
    
    Exit Sub
    
ErrorHandler:
    ' Log the error
    If FunctionExists("LogMessage") Then
        Application.Run "LogMessage", "Error initializing neural pathway mapper: " & Err.Number & " - " & Err.description, "ERROR"
    End If
    
    ' Ensure we still mark as initialized to prevent repeated attempts
    mIsInitialized = True
End Sub

' Helper function to check if a function exists
Private Function FunctionExists(functionName As String) As Boolean
    On Error Resume Next
    FunctionExists = False
    
    ' Try to get the VBA function info
    Dim dummyVal As Variant
    dummyVal = Application.Run(functionName)
    
    If Err.Number = 0 Or Err.Number = 449 Then
        ' 449 = "Argument not optional" - means function exists but needs arguments
        FunctionExists = True
    End If
    
    On Error GoTo 0
End Function

' Show navigation dialog - display neural network visualization
Public Sub ShowNavigationDialog(codeText As String)
    On Error GoTo ErrorHandler
    
    ' Initialize if needed - ensure parasite is attached
    If Not mIsInitialized Then InitializeSmartImport
    
    ' Clear processing flag
    mIsProcessing = False
    
    ' Analyze code structure - perform full neural scan
    ' Mac performance optimization - use different approach
    If mIsMac Then
        ' For Mac, use a simplified analysis approach
        If FunctionExists("CodeAnalysis.AnalyzeCodeStructureMac") Then
            Set mCodeStructure = Application.Run("CodeAnalysis.AnalyzeCodeStructureMac", codeText)
        Else
            ' Fallback to regular analysis but with a timeout
            AnalyzeWithTimeout codeText
        End If
    Else
        ' Windows - use full analysis
        If FunctionExists("CodeAnalysis.AnalyzeCodeStructure") Then
            Set mCodeStructure = Application.Run("CodeAnalysis.AnalyzeCodeStructure", codeText)
        Else
            ' Fallback message
            If FunctionExists("DynamicUserFormManager.ShowMessage") Then
                Application.Run "DynamicUserFormManager.ShowMessage", "Code analysis function not available", "Neural Mapping Error", vbExclamation
            End If
            Exit Sub
        End If
    End If
    
    ' Check if analysis was successful
    If mCodeStructure Is Nothing Then
        If FunctionExists("DynamicUserFormManager.ShowMessage") Then
            Application.Run "DynamicUserFormManager.ShowMessage", "Neural scan failed to produce results", "Neural Mapping Error", vbExclamation
        End If
        Exit Sub
    End If
    
    ' Extract module and procedure information - identify key neural clusters
    ExtractNavigationData
    
    ' Show the navigation UI - display neural imaging results
    If mIsMac Then
        ShowNavigationDialogMac
    Else
        ShowNavigationDialogWindows
    End If
    
    Exit Sub
    
ErrorHandler:
    ' Use safer error handling that doesn't depend on ErrorHandler module
    If FunctionExists("LogMessage") Then
        Application.Run "LogMessage", "Error in ShowNavigationDialog: " & Err.Number & " - " & Err.description, "ERROR"
    End If
    
    If FunctionExists("DynamicUserFormManager.ShowMessage") Then
        Application.Run "DynamicUserFormManager.ShowMessage", "Neural scan failure: " & Err.description, "Cerebral Mapping Error", vbExclamation
    End If
End Sub

' Analyze code with timeout protection for Mac
Private Sub AnalyzeWithTimeout(codeText As String)
    On Error GoTo ErrorHandler
    
    ' Set processing flag and timer
    mIsProcessing = True
    mLastProcessTime = Timer
    
    ' Try to analyze with timeout protection
    If FunctionExists("CodeAnalysis.AnalyzeCodeStructure") Then
        Set mCodeStructure = Application.Run("CodeAnalysis.AnalyzeCodeStructure", codeText)
        
        ' Check if we took too long
        If Timer - mLastProcessTime > MAX_PROCESSING_TIME Then
            ' Create a simplified code structure
            CreateSimplifiedCodeStructure codeText
        End If
    Else
        ' Create a simplified code structure as fallback
        CreateSimplifiedCodeStructure codeText
    End If
    
    ' Reset processing flag
    mIsProcessing = False
    
    Exit Sub
    
ErrorHandler:
    ' Reset processing flag
    mIsProcessing = False
    
    ' Create simplified structure as fallback
    On Error Resume Next
    CreateSimplifiedCodeStructure codeText
    On Error GoTo 0
    
    If FunctionExists("LogMessage") Then
        Application.Run "LogMessage", "Error in AnalyzeWithTimeout: " & Err.Number & " - " & Err.description, "ERROR"
    End If
End Sub

' Create a simplified code structure for Mac fallback
Private Sub CreateSimplifiedCodeStructure(codeText As String)
    On Error Resume Next
    
    ' Create a basic structure that won't crash on Mac
    Dim simpleStruct As Object
    
    ' Use regular Dictionary on Windows, custom one on Mac
    #If Mac Then
        ' For Mac, create a simple structure without Dictionary
        Dim lineCount As Long
        lineCount = CountLines(codeText)
        
        ' Create pseudo-Dictionary using Collection
        Set simpleStruct = CreateObject("System.Collections.ArrayList")
        
        ' Add basic properties
        simpleStruct.Add "LineCount=" & lineCount
        simpleStruct.Add "ModuleCount=1"
        simpleStruct.Add "ProcedureCount=0"
        
        ' Create a modules collection
        Dim modulesCollection As New collection
        
        ' Add a dummy module
        Dim moduleInfo As New collection
        moduleInfo.Add "Unknown Module"
        moduleInfo.Add "Standard Module"
        modulesCollection.Add moduleInfo
        
        ' Add modules to structure
    simpleStruct.Add "Modules", modulesCollection
    #Else
        ' On Windows, use regular Dictionary
        Set simpleStruct = CreateObject("Scripting.Dictionary")
        
        Dim lineCount As Long
        lineCount = CountLines(codeText)
        
        ' Add basic properties
        simpleStruct.Add "LineCount", lineCount
        simpleStruct.Add "ModuleCount", 1
        simpleStruct.Add "ProcedureCount", 0
        
        ' Create a modules collection
        Dim modulesCollection As New collection
        
        ' Add a dummy module
        Dim moduleDict As Object
        Set moduleDict = CreateObject("Scripting.Dictionary")
        moduleDict.Add "Name", "Unknown Module"
        moduleDict.Add "Type", "Standard Module"
        
        ' Add empty procedures collection
        Dim procsCollection As New collection
        moduleDict.Add "Procedures", procsCollection
        
        modulesCollection.Add moduleDict
        
        ' Add modules to structure
        simpleStruct.Add "Modules", modulesCollection
    #End If
    
    ' Set the code structure
    Set mCodeStructure = simpleStruct
End Sub

' Count lines in a text string
Private Function CountLines(text As String) As Long
    Dim i As Long, count As Long
    
    ' Count line breaks
    count = 1 ' Start with 1 for the last line
    
    For i = 1 To Len(text)
        If Mid(text, i, 1) = vbCr Or Mid(text, i, 1) = vbLf Then
            count = count + 1
            
            ' Skip extra CR/LF in CRLF sequence
            If i < Len(text) Then
                If Mid(text, i, 1) = vbCr And Mid(text, i + 1, 1) = vbLf Then
                    i = i + 1
                End If
            End If
        End If
        
        ' Add timeout protection for very long strings
        If i Mod 1000 = 0 Then
            DoEvents
        End If
    Next i
    
    CountLines = count
End Function

' Extract module and procedure information - catalog neural clusters
Private Sub ExtractNavigationData()
    On Error GoTo ErrorHandler
    
    ' Clear existing collections - purge previous neural scans
    Set mModulesList = New collection
    Set mProceduresList = New collection
    
    ' For Mac, simplify the extraction process
    If mIsMac Then
        ExtractNavigationDataMac
        Exit Sub
    End If
    
    ' Get modules collection - primary brain lobes
    Dim modules As collection
    
    ' Handle possible Dictionary or Collection
    If TypeOf mCodeStructure Is Dictionary Then
        Set modules = mCodeStructure("Modules")
    ElseIf TypeOf mCodeStructure Is collection Then
        ' Search for the modules collection
        Dim key As Variant
        For Each key In mCodeStructure
    
            If Left(key, 8) = "Modules=" Then
                    Set modules = Mid(key, 9)
                    Exit For
                End If
            End If
        Next key
    End If
    
    ' Check if we found modules
    If modules Is Nothing Then
        ' Create an empty collection
        Set modules = New collection
    End If
    
    ' Set processing flag and timer
    mIsProcessing = True
    mLastProcessTime = Timer
    
    ' Process each module - map each cerebral region
    Dim i As Long, j As Long
    Dim currentModule As Object ' Could be Dictionary or other
    
    For i = 1 To modules.count
        ' Check if we need to add a timeout
        If i Mod 5 = 0 Then
            DoEvents
            
            ' Check if we've been processing too long
            If Timer - mLastProcessTime > MAX_PROCESSING_TIME Then
                ' Log timeout warning
                If FunctionExists("LogMessage") Then
                    Application.Run "LogMessage", "Neural mapping timeout - processed " & i & " of " & modules.count & " modules", "WARNING"
                End If
                Exit For
            End If
        End If
        
        ' Get current module
        Set currentModule = modules(i)
        
        ' Add module to list - catalog brain region
        mModulesList.Add currentModule
        
        ' Process procedures in this module - map cellular functions
        Dim procs As collection
        
        ' Handle possible Dictionary or standard object
        If TypeOf currentModule Is Dictionary Then
            Set procs = currentModule("Procedures")
        ElseIf IsObject(currentModule) Then
            ' Try to get procedures using Collection
            On Error Resume Next
            Set procs = currentModule(2) ' Assume procedures are in 3rd position
            If Err.Number <> 0 Then
                Set procs = New collection ' Empty if not found
            End If
            On Error GoTo ErrorHandler
        Else
            Set procs = New collection ' Empty if not a proper object
        End If
        
        ' Process procedures
        For j = 1 To procs.count
            Dim proc As Object
            Set proc = procs(j)
            
            ' Add module reference to procedure - establish neural connection
            If TypeOf proc Is Dictionary Then
                proc("ModuleRef") = i
            End If
            
            ' Add to procedures list - add to cellular catalog
            mProceduresList.Add proc
        Next j
    Next i
    
    ' Reset processing flag
    mIsProcessing = False
    
    Exit Sub
    
ErrorHandler:
    ' Reset processing flag
    mIsProcessing = False
    
    If FunctionExists("LogMessage") Then
        Application.Run "LogMessage", "Neural mapping failure: " & Err.Number & " - " & Err.description, "ERROR"
    End If
    
    ' Ensure we have valid collections even after an error
    If mModulesList Is Nothing Then Set mModulesList = New collection
    If mProceduresList Is Nothing Then Set mProceduresList = New collection
End Sub

' Mac-optimized version of ExtractNavigationData
Private Sub ExtractNavigationDataMac()
    On Error GoTo ErrorHandler
    
    ' For Mac, use a simplified approach that's less resource-intensive
    Dim modules As collection
    
    ' Handle possible Dictionary or Collection
    If TypeOf mCodeStructure Is Dictionary Then
        On Error Resume Next
        Set modules = mCodeStructure("Modules")
        If Err.Number <> 0 Then
            Set modules = New collection
        End If
        On Error GoTo ErrorHandler
    ElseIf TypeOf mCodeStructure Is collection Then
        ' Search for the modules collection
        Dim key As Variant
        For Each key In mCodeStructure
            'If TypeOf key Is String Then
                If Left(key, 8) = "Modules=" Then
                    Set modules = Mid(key, 9)
                    Exit For
                End If
            End If
        Next key
        
        If modules Is Nothing Then
            Set modules = New collection
        End If
    Else
        ' Create an empty collection
        Set modules = New collection
    End If
    
    ' Set processing flag and timer
    mIsProcessing = True
    mLastProcessTime = Timer
    
    ' Process modules with a limit for Mac
    Dim moduleLimit As Long
    moduleLimit = MAC_MAX_MODULES
    If modules.count < moduleLimit Then moduleLimit = modules.count
    
    Dim i As Long, j As Long
    
    For i = 1 To moduleLimit
        ' Add periodic DoEvents
        If i Mod 2 = 0 Then DoEvents
        
        ' Get current module (handle both Dictionary and Collection)
        Dim currentModule As Object
        Set currentModule = modules(i)
        
        ' Add module to our list
        mModulesList.Add currentModule
        
        ' Only process a few procedures per module on Mac
        Dim procs As collection
        
        ' Handle possible Dictionary or standard object
        If TypeOf currentModule Is Dictionary Then
            On Error Resume Next
            Set procs = currentModule("Procedures")
            If Err.Number <> 0 Then
                Set procs = New collection
            End If
            On Error GoTo ErrorHandler
        ElseIf IsObject(currentModule) Then
            ' Try to get procedures using Collection
            On Error Resume Next
            Set procs = currentModule(2) ' Assume procedures are in 3rd position
            If Err.Number <> 0 Then
                Set procs = New collection ' Empty if not found
            End If
            On Error GoTo ErrorHandler
        Else
            Set procs = New collection ' Empty if not a proper object
        End If
        
        ' Process limited procedures on Mac
        Dim procLimit As Long
        procLimit = 10  ' Only process 10 procedures per module on Mac
        If procs.count < procLimit Then procLimit = procs.count
        
        For j = 1 To procLimit
            Dim proc As Object
            Set proc = procs(j)
            
            ' Add module reference to procedure if possible
            If TypeOf proc Is Dictionary Then
                On Error Resume Next
                proc("ModuleRef") = i
                On Error GoTo ErrorHandler
            End If
            
            ' Add to procedures list
            mProceduresList.Add proc
        Next j
    Next i
    
    ' Reset processing flag
    mIsProcessing = False
    
    Exit Sub
    
ErrorHandler:
    ' Reset processing flag
    mIsProcessing = False
    
    If FunctionExists("LogMessage") Then
        Application.Run "LogMessage", "Mac neural mapping failure: " & Err.Number & " - " & Err.description, "ERROR"
    End If
    
    ' Ensure we have valid collections even after an error
    If mModulesList Is Nothing Then Set mModulesList = New collection
    If mProceduresList Is Nothing Then Set mProceduresList = New collection
End Sub

' Show navigation dialog on Windows - present neural map to Windows hosts
Private Sub ShowNavigationDialogWindows()
    On Error GoTo ErrorHandler
    
    ' Create dialog as document content - generate neural visualization
    Dim dialogContent As String
    dialogContent = GenerateNavigationContent()
    
    ' Show in document - display neural map to the host
    If FunctionExists("DynamicUserFormManager.ShowRichTextDialog") Then
        Application.Run "DynamicUserFormManager.ShowRichTextDialog", dialogContent, "Neural Pathway Navigator", 700, 500
    Else
        ' Fallback to displaying in the document
        ThisDocument.content.text = dialogContent
    End If
    
    Exit Sub
    
ErrorHandler:
    ' Use safer error handling
    If FunctionExists("LogMessage") Then
        Application.Run "LogMessage", "Error in ShowNavigationDialogWindows: " & Err.Number & " - " & Err.description, "ERROR"
    End If
End Sub

' Show navigation dialog on Mac - present neural map to Mac hosts
Private Sub ShowNavigationDialogMac()
    On Error GoTo ErrorHandler
    
    #If Mac Then
        ' Similar to Windows but with Mac UI adjustments - host-specific neural interface
        Dim dialogContent As String
        dialogContent = GenerateNavigationContentMac() ' Use Mac-optimized content generation
        
        ' Show in document - display neural map to Mac host
        If FunctionExists("DynamicUserFormManager.ShowRichTextDialog") Then
            Application.Run "DynamicUserFormManager.ShowRichTextDialog", dialogContent, "Neural Pathway Navigator", 700, 500
        Else
            ' Fallback to displaying in the document
            ThisDocument.content.text = dialogContent
        End If
    #End If
    
    Exit Sub
    
ErrorHandler:
    ' Use safer error handling
    If FunctionExists("LogMessage") Then
        Application.Run "LogMessage", "Error in ShowNavigationDialogMac: " & Err.Number & " - " & Err.description, "ERROR"
    End If
End Sub

' Generate navigation content - create neural pathway visualization
Private Function GenerateNavigationContent() As String
    On Error GoTo ErrorHandler
    
    ' For Mac, use the simplified version
    If mIsMac Then
        GenerateNavigationContent = GenerateNavigationContentMac()
        Exit Function
    End If
    
    Dim content As String
    Dim i As Long, j As Long ' Loop counters - scanning indices
    
    ' Set processing flag and timer
    mIsProcessing = True
    mLastProcessTime = Timer
    
    ' Create header - cerebral map title
    content = "• NEURAL STRUCTURE NAVIGATOR •" & vbCrLf & vbCrLf
    
    ' Add code statistics - host vital statistics
    content = content & "Neural Tissue Analysis:" & vbCrLf
    
    ' Handle possible Dictionary or Collection
    Dim lineCount As String, ModuleCount As String, procCount As String
    
    If TypeOf mCodeStructure Is Dictionary Then
        On Error Resume Next
        lineCount = mCodeStructure("LineCount")
        ModuleCount = mCodeStructure("ModuleCount")
        procCount = mCodeStructure("ProcedureCount")
        On Error GoTo ErrorHandler
    Else
        ' Try to extract from Collection
        On Error Resume Next
        For i = 1 To mCodeStructure.count
            Dim item As Variant
            item = mCodeStructure(i)
            
            'If TypeOf item Is String Then '**** These lines throughout this module are yielding syntax errors "expected sub or object required."
                If Left(item, 10) = "LineCount=" Then
                    lineCount = Mid(item, 11)
                ElseIf Left(item, 12) = "ModuleCount=" Then
                    ModuleCount = Mid(item, 13)
                ElseIf Left(item, 16) = "ProcedureCount=" Then
                    procCount = Mid(item, 17)
                End If
            End If
        Next i
        On Error GoTo ErrorHandler
    End If
    
    ' Add stats to content
    content = content & "- Total Neural Connections: " & lineCount & vbCrLf
    content = content & "- Brain Regions: " & ModuleCount & vbCrLf
    content = content & "- Neural Functions: " & procCount & vbCrLf & vbCrLf
    
    ' Add modules section - cerebral regions catalog
    content = content & "CEREBRAL REGIONS:" & vbCrLf
    content = content & String(50, "-") & vbCrLf
    
    ' List modules - identify all brain regions
    For i = 1 To mModulesList.count
        ' Add a DoEvents periodically to keep UI responsive
        If i Mod 5 = 0 Then
            DoEvents
            
            ' Check if we've been processing too long
            If Timer - mLastProcessTime > MAX_PROCESSING_TIME Then
                content = content & vbCrLf & "[Processing timeout - not all modules displayed]" & vbCrLf
                Exit For
            End If
        End If
        
        Dim module As Object
        Set module = mModulesList(i)
        
        ' Handle different module types (Dictionary or Collection)
        Dim moduleName As String, moduleType As String
        
        If TypeOf module Is Dictionary Then
            On Error Resume Next
            moduleName = module("Name")
            moduleType = module("Type")
            On Error GoTo 0
        ElseIf IsObject(module) Then
            ' Assume Collection structure
            On Error Resume Next
            moduleName = module(1)
            moduleType = module(2)
            On Error GoTo 0
        End If
        
        ' Default values if not found
        If moduleName = "" Then moduleName = "Unknown Module " & i
        If moduleType = "" Then moduleType = "Unknown Type"
        
        content = content & i & ". " & moduleName & " (" & moduleType & ")" & vbCrLf
        
        ' List procedures in this module - cellular functions in region
        Dim procs As collection
        
        If TypeOf module Is Dictionary Then
            On Error Resume Next
            Set procs = module("Procedures")
            On Error GoTo 0
        ElseIf IsObject(module) Then
            ' Try to get procedures using Collection
            On Error Resume Next
            Set procs = module(3) ' Assume procedures in position 3
            On Error GoTo 0
        End If
        
        ' If procedures not found, create empty collection
        If procs Is Nothing Then Set procs = New collection
        
        If procs.count > 0 Then
            ' List procedures with a limit for performance
            Dim procLimit As Long
            procLimit = 50 ' Limit to 50 procedures per module
            If procs.count < procLimit Then procLimit = procs.count
            
            For j = 1 To procLimit
                Dim proc As Object
                Set proc = procs(j)
                
                ' Handle different procedure types (Dictionary or Collection)
                Dim procName As String, procType As String
                
                If TypeOf proc Is Dictionary Then
                    On Error Resume Next
                    procName = proc("Name")
                    procType = proc("Type")
                    On Error GoTo 0
                ElseIf IsObject(proc) Then
                    ' Assume Collection structure
                    On Error Resume Next
                    procName = proc(1)
                    procType = proc(2)
                    On Error GoTo 0
                End If
                
                ' Default values if not found
                If procName = "" Then procName = "Unknown Procedure " & j
                If procType = "" Then procType = "Sub"
                
                content = content & "   " & j & ". " & procType & " " & procName
                
                ' Add error handling status - immune response capability
                If HasErrorHandling(proc) Then
                    content = content & " ?" ' Has error handling - immune system active
                Else
                    content = content & " ?" ' No error handling - vulnerable to infection
                End If
                
                content = content & vbCrLf
            Next j
            
            ' Add indicator if not all procedures shown
            If procs.count > procLimit Then
                content = content & "   [" & (procs.count - procLimit) & " more procedures not shown]" & vbCrLf
            End If
        Else
            content = content & "   (No neural functions detected)" & vbCrLf
        End If
        
        content = content & vbCrLf
    Next i
    
    ' Add procedure types section - neural function classification
    content = content & "NEURAL FUNCTION TYPES:" & vbCrLf
    content = content & String(50, "-") & vbCrLf
    
    ' Count procedure types - classify neural functions
    Dim subCount As Long, functionCount As Long, propertyCount As Long
    subCount = 0
    functionCount = 0
    propertyCount = 0
    
    ' Limit to prevent freezing
    Dim countLimit As Long
    countLimit = 100 ' Only count up to 100 procedures
    If mProceduresList.count < countLimit Then countLimit = mProceduresList.count
    
    For i = 1 To countLimit
        Dim procType As String
        
        Dim procObj As Object
        Set procObj = mProceduresList(i)
        
        If TypeOf procObj Is Dictionary Then
            procType = procObj("Type")
        ElseIf IsObject(procObj) Then
            ' Get type from second position in collection
            On Error Resume Next
            procType = procObj(2)
            On Error GoTo 0
        End If
        
        If procType = "Sub" Then
            subCount = subCount + 1
        ElseIf procType = "Function" Then
            functionCount = functionCount + 1
        ElseIf Left(procType, 8) = "Property" Then
            propertyCount = propertyCount + 1
        End If
    Next i
    
    content = content & "- Motor Neurons (Subs): " & subCount & vbCrLf
    content = content & "- Sensory Neurons (Functions): " & functionCount & vbCrLf
    content = content & "- Interneurons (Properties): " & propertyCount & vbCrLf & vbCrLf
    
    ' Add module relationships (dependencies) - neural pathway connections
    content = content & "NEURAL PATHWAY CONNECTIONS:" & vbCrLf
    content = content & String(50, "-") & vbCrLf
    
    ' Generate dependencies with timeout protection
    Dim startTime As Double
    startTime = Timer
    
    content = content & GenerateModuleDependencies(True) & vbCrLf & vbCrLf
    
    ' Add navigation instructions - neural navigation protocols
    content = content & "NEURAL NAVIGATION PROTOCOLS:" & vbCrLf
    content = content & String(50, "-") & vbCrLf
    content = content & "To navigate to a specific neural region or function:" & vbCrLf
    content = content & "1. Enter the region number to jump to a brain region" & vbCrLf
    content = content & "2. Enter R:F (e.g., 2:3) to jump to function F in region R" & vbCrLf
    content = content & "3. Click on a neural function to select it" & vbCrLf & vbCrLf
    
    ' Add input box for navigation - neural targeting system
    content = content & "Enter neural target coordinates: [                ]" & vbCrLf
    
    ' Add done button - terminate neural scan
    content = content & vbCrLf & "[   NEURAL SCAN COMPLETE   ]"
    
    ' Reset processing flag
    mIsProcessing = False
    
    GenerateNavigationContent = content
    
    Exit Function
    
ErrorHandler:
    ' Reset processing flag
    mIsProcessing = False
    
    If FunctionExists("LogMessage") Then
        Application.Run "LogMessage", "Error in GenerateNavigationContent: " & Err.Number & " - " & Err.description, "ERROR"
    End If
    
    ' Return a simple error message
    GenerateNavigationContent = "Neural pathway visualization generation failed." & vbCrLf & _
                              "Error: " & Err.description & vbCrLf & vbCrLf & _
                              "[   NEURAL SCAN INCOMPLETE   ]"
End Function

' Mac-optimized version of GenerateNavigationContent with full functionality
Private Function GenerateNavigationContentMac() As String
    On Error GoTo ErrorHandler
    
    Dim content As String
    
    ' Set processing flag and timer
    mIsProcessing = True
    mLastProcessTime = Timer
    
    ' Create header - with same details as Windows version
    content = "• NEURAL STRUCTURE NAVIGATOR •" & vbCrLf & vbCrLf
    
    ' Add full statistics
    content = content & "Neural Tissue Analysis:" & vbCrLf
    content = content & "- Total Neural Connections: " & GetStructureValue("LineCount", "0") & vbCrLf
    content = content & "- Brain Regions: " & GetStructureValue("ModuleCount", "0") & vbCrLf
    content = content & "- Neural Functions: " & GetStructureValue("ProcedureCount", "0") & vbCrLf & vbCrLf
    
    ' Add modules section - cerebral regions catalog
    content = content & "CEREBRAL REGIONS:" & vbCrLf
    content = content & String(50, "-") & vbCrLf
    
    ' Process modules in chunks with timeout protection
    Dim ModuleCount As Long
    ModuleCount = mModulesList.count
    
    Dim i As Long, j As Long
    Dim chunkStart As Long, chunkEnd As Long
    Dim chunkSize As Long
    
    chunkSize = 5 ' Process 5 modules at a time
    chunkStart = 1
    
    Do While chunkStart <= ModuleCount
        ' Define chunk end
        chunkEnd = chunkStart + chunkSize - 1
        If chunkEnd > ModuleCount Then chunkEnd = ModuleCount
        
        ' Process this chunk of modules
        For i = chunkStart To chunkEnd
            DoEvents ' Keep UI responsive
            
            Dim module As Object
            Set module = mModulesList(i)
            
            ' Extract module info
            Dim moduleName As String, moduleType As String
            
            If TypeOf module Is Dictionary Then
                On Error Resume Next
                moduleName = module("Name")
                moduleType = module("Type")
                On Error GoTo 0
            ElseIf IsObject(module) Then
                On Error Resume Next
                moduleName = module(1)
                moduleType = module(2)
                On Error GoTo 0
            End If
            
            ' Default values if not found
            If moduleName = "" Then moduleName = "Unknown Module " & i
            If moduleType = "" Then moduleType = "Unknown Type"
            
            content = content & i & ". " & moduleName & " (" & moduleType & ")" & vbCrLf
            
            ' List procedures in this module
            Dim procs As collection
            
            If TypeOf module Is Dictionary Then
                On Error Resume Next
                Set procs = module("Procedures")
                On Error GoTo 0
            ElseIf IsObject(module) Then
                On Error Resume Next
                Set procs = module(3) ' Assume procedures at position 3
                On Error GoTo 0
            End If
            
            ' If no procedures, create empty collection
            If procs Is Nothing Then Set procs = New collection
            
            ' Process procedures in smaller chunks
            Dim procCount As Long
            procCount = procs.count
            
            If procCount > 0 Then
                ' Process procedures in chunks
                Dim procChunkSize As Long
                procChunkSize = 5 ' Show 5 procedures per chunk
                
                For j = 1 To procCount
                    ' Break if taking too long
                    If j > 15 And Timer - mLastProcessTime > MAX_PROCESSING_TIME / 2 Then
                        content = content & "   [More procedures not shown due to timeout]" & vbCrLf
                        Exit For
                    End If
                    
                    If j Mod procChunkSize = 0 Then DoEvents ' Keep UI responsive
                    
                    Dim proc As Object
                    Set proc = procs(j)
                    
                    ' Extract procedure info
                    Dim procName As String, procType As String
                    
                    If TypeOf proc Is Dictionary Then
                        On Error Resume Next
                        procName = proc("Name")
                        procType = proc("Type")
                        On Error GoTo 0
                    ElseIf IsObject(proc) Then
                        On Error Resume Next
                        procName = proc(1)
                        procType = proc(2)
                        On Error GoTo 0
                    End If
                    
                    ' Default values if not found
                    If procName = "" Then procName = "Unknown Procedure " & j
                    If procType = "" Then procType = "Sub"
                    
                    content = content & "   " & j & ". " & procType & " " & procName
                    
                    ' Add error handling status
                    If HasErrorHandling(proc) Then
                        content = content & " ?" ' Has error handling
                    Else
                        content = content & " ?" ' No error handling
                    End If
                    
                    content = content & vbCrLf
                Next j
                
                ' Show message if more procedures exist
                If procCount > 15 Then
                    content = content & "   [" & (procCount - 15) & " more functions not shown]" & vbCrLf
                End If
            Else
                content = content & "   (No neural functions detected)" & vbCrLf
            End If
            
            content = content & vbCrLf
        Next i
        
        ' Check if we need to refresh UI
        If Timer - mLastProcessTime > MAX_PROCESSING_TIME / 2 Then
            DoEvents
            mLastProcessTime = Timer
        End If
        
        ' Move to next chunk
        chunkStart = chunkEnd + 1
    Loop
    
    ' Add procedure types section with full counts
    content = content & "NEURAL FUNCTION TYPES:" & vbCrLf
    content = content & String(50, "-") & vbCrLf
    
    ' Count procedure types with chunking
    Dim subCount As Long, functionCount As Long, propertyCount As Long
    subCount = 0
    functionCount = 0
    propertyCount = 0
    
    ' Count in chunks
    Dim procTotal As Long, procChunkStart As Long, procChunkEnd As Long
    procTotal = mProceduresList.count
    procChunkStart = 1
    procChunkSize = 20 ' Count 20 at a time
    
    Do While procChunkStart <= procTotal
        ' Define chunk end
        procChunkEnd = procChunkStart + procChunkSize - 1
        If procChunkEnd > procTotal Then procChunkEnd = procTotal
        
        ' Process this chunk
        For i = procChunkStart To procChunkEnd
            Dim procObj As Object
            Set procObj = mProceduresList(i)
            
            Dim pType As String
            
            If TypeOf procObj Is Dictionary Then
                On Error Resume Next
                pType = procObj("Type")
                On Error GoTo 0
            ElseIf IsObject(procObj) Then
                On Error Resume Next
                pType = procObj(2)
                On Error GoTo 0
            End If
            
            If pType = "Sub" Then
                subCount = subCount + 1
            ElseIf pType = "Function" Then
                functionCount = functionCount + 1
            ElseIf Left(pType, 8) = "Property" Then
                propertyCount = propertyCount + 1
            End If
        Next i
        
        ' Check if we need to refresh UI
        If Timer - mLastProcessTime > MAX_PROCESSING_TIME / 2 Then
            DoEvents
            mLastProcessTime = Timer
        End If
        
        ' Move to next chunk
        procChunkStart = procChunkEnd + 1
    Loop
    
    ' Add counts to output
    content = content & "- Motor Neurons (Subs): " & subCount & vbCrLf
    content = content & "- Sensory Neurons (Functions): " & functionCount & vbCrLf
    content = content & "- Interneurons (Properties): " & propertyCount & vbCrLf & vbCrLf
    
    ' Add module relationships section
    content = content & "NEURAL PATHWAY CONNECTIONS:" & vbCrLf
    content = content & String(50, "-") & vbCrLf
    
    ' Generate dependencies with chunking and timeout protection
    content = content & GenerateModuleDependencies(True) & vbCrLf & vbCrLf
    
    ' Add navigation instructions
    content = content & "NEURAL NAVIGATION PROTOCOLS:" & vbCrLf
    content = content & String(50, "-") & vbCrLf
    content = content & "To navigate to a specific neural region or function:" & vbCrLf
    content = content & "1. Enter the region number to jump to a brain region" & vbCrLf
    content = content & "2. Enter R:F (e.g., 2:3) to jump to function F in region R" & vbCrLf
    content = content & "3. Click on a neural function to select it" & vbCrLf & vbCrLf
    
    ' Add input box for navigation
    content = content & "Enter neural target coordinates: [                ]" & vbCrLf
    
    ' Add done button
    content = content & vbCrLf & "[   NEURAL SCAN COMPLETE   ]"
    
    ' Reset processing flag
    mIsProcessing = False
    
    GenerateNavigationContentMac = content
    
    Exit Function
    
ErrorHandler:
    ' Reset processing flag
    mIsProcessing = False
    
    If FunctionExists("LogMessage") Then
        Application.Run "LogMessage", "Error in GenerateNavigationContentMac: " & Err.Number & " - " & Err.description, "ERROR"
    End If
    
    ' Return a simple error message
    GenerateNavigationContentMac = "Neural pathway visualization error." & vbCrLf & _
                                 "Error: " & Err.description & vbCrLf & vbCrLf & _
                                 "[   NEURAL SCAN INCOMPLETE   ]"
End Function
' Helper function to get value from code structure
Private Function GetStructureValue(key As String, defaultValue As String) As String
    On Error Resume Next
    
    If TypeOf mCodeStructure Is Dictionary Then
        ' Try to get from Dictionary
        GetStructureValue = mCodeStructure(key)
    ElseIf TypeOf mCodeStructure Is collection Then
        ' Try to get from Collection
        Dim i As Long
        For i = 1 To mCodeStructure.count
            If TypeOf mCodeStructure(i) Is String Then
                Dim itemStr As String
                itemStr = mCodeStructure(i)
                
                ' Check if this item starts with our key followed by equals sign
                If Left(itemStr, Len(key) + 1) = key & "=" Then
                    GetStructureValue = Mid(itemStr, Len(key) + 2)
                    Exit Function
                End If
            End If
        Next i
    End If
    
    ' Check if we found anything
    If Err.Number <> 0 Or GetStructureValue = "" Then
        GetStructureValue = defaultValue
    End If
    
    On Error GoTo 0
End Function
' Check if procedure has error handling - detect immune system presence
Private Function HasErrorHandling(proc As Object) As Boolean
    On Error Resume Next
    
    ' Look for error handling patterns in procedure body
    Dim body As String
    
    If TypeOf proc Is Dictionary Then
        body = proc("Body")
    ElseIf IsObject(proc) Then
        ' Try to get body from collection
        body = proc(3) ' Assume body is in position 3
    End If
    
    If Err.Number <> 0 Or body = "" Then
        HasErrorHandling = False
        Exit Function
    End If
    
    On Error GoTo 0
    
    ' Check for common error handling patterns
    If InStr(1, body, "On Error", vbTextCompare) > 0 Or _
       InStr(1, body, "ErrorHandler", vbTextCompare) > 0 Or _
       InStr(1, body, "Err.", vbTextCompare) > 0 Then
        HasErrorHandling = True
    Else
        HasErrorHandling = False
    End If
End Function

' Generate module dependencies diagram - map neural pathway connections
Private Function GenerateModuleDependencies(Optional fullAnalysis As Boolean = True) As String
    On Error GoTo ErrorHandler
    
    Dim result As String
    Dim i As Long, j As Long ' Loop counters - scanning indices
    
    ' Set processing flag and timer
    mIsProcessing = True
    mLastProcessTime = Timer
    
    ' Determine module limit based on platform and analysis type
    Dim moduleLimit As Long
    
    If mIsMac Or Not fullAnalysis Then
        moduleLimit = 5 ' Limited analysis for Mac or simple mode
    Else
        moduleLimit = 10 ' More modules for Windows
    End If
    
    If mModulesList.count < moduleLimit Then moduleLimit = mModulesList.count
    
    ' Simple ASCII dependency chart - basic neural pathway map
    For i = 1 To moduleLimit
        ' Add a DoEvents periodically
        If i Mod 2 = 0 Then DoEvents
        
        ' Check for timeout
        If Timer - mLastProcessTime > MAX_PROCESSING_TIME Then
            result = result & "[Processing timeout - remaining dependencies not shown]" & vbCrLf
            Exit For
        End If
        
        Dim module As Object
        Set module = mModulesList(i)
        
        ' Extract module name
        Dim moduleName As String
        
        If TypeOf module Is Dictionary Then
            On Error Resume Next
            moduleName = module("Name")
            On Error GoTo 0
        ElseIf IsObject(module) Then
            ' Assume Collection structure
            On Error Resume Next
            moduleName = module(1)
            On Error GoTo 0
        End If
        
        ' Default value if not found
        If moduleName = "" Then moduleName = "Unknown Module " & i
        
        result = result & moduleName & vbCrLf
        
        ' Find dependencies - trace neural connections
        Dim dependencies As collection
        Set dependencies = FindDependencies(module)
        
        ' Limit dependencies shown
        Dim depLimit As Long
        depLimit = 3 ' Show up to 3 dependencies per module
        
        If dependencies.count < depLimit Then depLimit = dependencies.count
        
        ' Show dependencies - display neural pathways
        For j = 1 To depLimit
            result = result & "  ? " & dependencies(j) & vbCrLf
        Next j
        
        ' Show count if more dependencies exist
        If dependencies.count > depLimit Then
            result = result & "  [" & (dependencies.count - depLimit) & " more connections not shown]" & vbCrLf
        End If
        
        result = result & vbCrLf
    Next i
    
    ' Show count if more modules exist
    If mModulesList.count > moduleLimit Then
        result = result & "[" & (mModulesList.count - moduleLimit) & " more regions not shown]" & vbCrLf
    End If
    
    ' Reset processing flag
    mIsProcessing = False
    
    GenerateModuleDependencies = result
    
    Exit Function
    
ErrorHandler:
    ' Reset processing flag
    mIsProcessing = False
    
    If FunctionExists("LogMessage") Then
        Application.Run "LogMessage", "Error in GenerateModuleDependencies: " & Err.Number & " - " & Err.description, "ERROR"
    End If
    
    ' Return a simple message
    GenerateModuleDependencies = "[Error generating neural pathway connections]" & vbCrLf
End Function

' Find module dependencies - trace neural connections with full analysis
Private Function FindDependencies(module As Object) As collection
    On Error GoTo ErrorHandler
    
    Dim dependencies As New collection
    Dim i As Long, j As Long ' Loop counters
    Dim startTime As Double
    startTime = Timer
    
    ' Extract module name
    Dim moduleName As String
    
    If TypeOf module Is Dictionary Then
        moduleName = module("Name")
    ElseIf IsObject(module) Then
        ' Assume Collection structure
        moduleName = module(1)
    End If
    
    ' Default value if not found
    If moduleName = "" Then moduleName = "Unknown Module"
    
    ' Full dependency analysis implementation
    ' Process all modules to find dependencies through code analysis
    For i = 1 To mModulesList.count
        ' Check timeout periodically
        If i Mod 5 = 0 Then
            DoEvents
            
            ' Check if processing for too long, but don't exit - just refresh UI
            If Timer - startTime > MAX_PROCESSING_TIME / 2 Then
                DoEvents
                startTime = Timer
            End If
        End If
        
        Dim depModule As Object
        Set depModule = mModulesList(i)
        
        Dim depName As String
        
        If TypeOf depModule Is Dictionary Then
            On Error Resume Next
            depName = depModule("Name")
            On Error GoTo ErrorHandler
        ElseIf IsObject(depModule) Then
            ' Assume Collection structure
            On Error Resume Next
            depName = depModule(1)
            On Error GoTo ErrorHandler
        End If
        
        ' Skip self-references
        If depName = moduleName Then GoTo NextModule
        
        ' Analyze if this module depends on the current dep module
        If DependsOn(module, depModule) Then
            On Error Resume Next
            dependencies.Add depName
            On Error GoTo 0
        End If
        
        ' Analyze if this module has procedural calls to the target module
        If HasProceduralCalls(module, depModule) Then
            On Error Resume Next
            dependencies.Add depName
            On Error GoTo 0
        End If
        
        ' Check for interface implementations
        If ImplementsInterface(module, depModule) Then
            On Error Resume Next
            dependencies.Add depName
            On Error GoTo 0
        End If
        
NextModule:
    Next i
    
    Set FindDependencies = dependencies
    
    Exit Function
    
ErrorHandler:
    ' Create a valid collection on error
    If dependencies Is Nothing Then Set dependencies = New collection
    Set FindDependencies = dependencies
    
    If FunctionExists("LogMessage") Then
        Application.Run "LogMessage", "Error in FindDependencies: " & Err.Number & " - " & Err.description, "ERROR"
    End If
End Function

' Determine if one module depends on another through code analysis
Private Function DependsOn(sourceModule As Object, targetModule As Object) As Boolean
    On Error GoTo ErrorHandler
    
    DependsOn = False
    
    ' Get module names
    Dim sourceName As String, targetName As String
    
    If TypeOf sourceModule Is Dictionary Then
        On Error Resume Next
        sourceName = sourceModule("Name")
        On Error GoTo 0
    ElseIf IsObject(sourceModule) Then
        On Error Resume Next
        sourceName = sourceModule(1)
        On Error GoTo 0
    End If
    
    If TypeOf targetModule Is Dictionary Then
        On Error Resume Next
        targetName = targetModule("Name")
        On Error GoTo 0
    ElseIf IsObject(targetModule) Then
        On Error Resume Next
        targetName = targetModule(1)
        On Error GoTo 0
    End If
    
    ' Default values if not found
    If sourceName = "" Then sourceName = "Unknown"
    If targetName = "" Then targetName = "Unknown"
    
    ' Check for procedures in source module
    Dim procs As collection
    
    If TypeOf sourceModule Is Dictionary Then
        On Error Resume Next
        Set procs = sourceModule("Procedures")
        On Error GoTo 0
    ElseIf IsObject(sourceModule) Then
        On Error Resume Next
        Set procs = sourceModule(3) ' Assume procedures at position 3
        On Error GoTo 0
    End If
    
    ' If no procedures, can't determine dependencies
    If procs Is Nothing Then
        Set procs = New collection
    End If
    
    ' Get the module body if available
    Dim moduleBody As String
    
    If TypeOf sourceModule Is Dictionary Then
        On Error Resume Next
        moduleBody = sourceModule("Body")
        On Error GoTo 0
    End If
    
    ' Check module-level dependencies in the module body
    If moduleBody <> "" Then
        ' Check for imports at module level
        If InStr(1, moduleBody, "As " & targetName, vbTextCompare) > 0 Then
            DependsOn = True
            Exit Function
        End If
        
        ' Check for New object creation
        If InStr(1, moduleBody, "New " & targetName, vbTextCompare) > 0 Then
            DependsOn = True
            Exit Function
        End If
        
        ' Check for CreateObject calls that might reference the module
        If InStr(1, moduleBody, "CreateObject") > 0 And InStr(1, moduleBody, targetName, vbTextCompare) > 0 Then
            DependsOn = True
            Exit Function
        End If
    End If
    
    ' Process each procedure's body to search for references to target module
    Dim i As Long
    For i = 1 To procs.count
        Dim proc As Object
        Set proc = procs(i)
        
        ' Get procedure body
        Dim body As String
        
        If TypeOf proc Is Dictionary Then
            On Error Resume Next
            body = proc("Body")
            On Error GoTo 0
        ElseIf IsObject(proc) Then
            On Error Resume Next
            body = proc(3) ' Assume body at position 3
            On Error GoTo 0
        End If
        
        If body <> "" Then
            ' Look for references to target module in the procedure body
            ' Check for direct references to target module
            If InStr(1, body, targetName & ".", vbTextCompare) > 0 Then
                DependsOn = True
                Exit Function
            End If
            
            ' Check for imports/references
            If InStr(1, body, "Set " & targetName, vbTextCompare) > 0 Then
                DependsOn = True
                Exit Function
            End If
            
            ' Check for variable declarations
            If InStr(1, body, "As " & targetName, vbTextCompare) > 0 Then
                DependsOn = True
                Exit Function
            End If
            
            ' Check for New object creation
            If InStr(1, body, "New " & targetName, vbTextCompare) > 0 Then
                DependsOn = True
                Exit Function
            End If
            
            ' Check for Application.Run calls that might reference the module
            If InStr(1, body, "Application.Run") > 0 And InStr(1, body, targetName, vbTextCompare) > 0 Then
                DependsOn = True
                Exit Function
            End If
            
            ' Check for CreateObject calls that might reference the module
            If InStr(1, body, "CreateObject") > 0 And InStr(1, body, targetName, vbTextCompare) > 0 Then
                DependsOn = True
                Exit Function
            End If
            
            ' Check for GetObject calls that might reference the module
            If InStr(1, body, "GetObject") > 0 And InStr(1, body, targetName, vbTextCompare) > 0 Then
                DependsOn = True
                Exit Function
            End If
            
            ' Check for Implements statements
            If InStr(1, body, "Implements " & targetName, vbTextCompare) > 0 Then
                DependsOn = True
                Exit Function
            End If
        End If
        
        ' Add a DoEvents periodically for responsiveness on Mac
        If i Mod 10 = 0 Then
            DoEvents
        End If
    Next i
    
    Exit Function
    
ErrorHandler:
    DependsOn = False
    
    If FunctionExists("LogMessage") Then
        Application.Run "LogMessage", "Error in DependsOn: " & Err.Number & " - " & Err.description, "ERROR"
    End If
End Function

' Check if source module has procedure calls to target module
Private Function HasProceduralCalls(sourceModule As Object, targetModule As Object) As Boolean
    On Error GoTo ErrorHandler
    
    HasProceduralCalls = False
    
    ' Get module names
    Dim sourceName As String, targetName As String
    
    If TypeOf sourceModule Is Dictionary Then
        On Error Resume Next
        sourceName = sourceModule("Name")
        On Error GoTo 0
    ElseIf IsObject(sourceModule) Then
        On Error Resume Next
        sourceName = sourceModule(1)
        On Error GoTo 0
    End If
    
    If TypeOf targetModule Is Dictionary Then
        On Error Resume Next
        targetName = targetModule("Name")
        On Error GoTo 0
    End If
    
    ' Get procedures in source module
    Dim sourceProcs As collection
    
    If TypeOf sourceModule Is Dictionary Then
        On Error Resume Next
        Set sourceProcs = sourceModule("Procedures")
        On Error GoTo 0
    End If
    
    If sourceProcs Is Nothing Then Set sourceProcs = New collection
    
    ' Get procedures in target module
    Dim targetProcs As collection
    
    If TypeOf targetModule Is Dictionary Then
        On Error Resume Next
        Set targetProcs = targetModule("Procedures")
        On Error GoTo 0
    End If
    
    If targetProcs Is Nothing Then Set targetProcs = New collection
    
    ' Check each source procedure for calls to target procedures
    Dim i As Long, j As Long
    
    For i = 1 To sourceProcs.count
        Dim sourceProc As Object
        Set sourceProc = sourceProcs(i)
        
        Dim sourceBody As String
        
        If TypeOf sourceProc Is Dictionary Then
            On Error Resume Next
            sourceBody = sourceProc("Body")
            On Error GoTo 0
        End If
        
        If sourceBody = "" Then GoTo NextSourceProc
        
        ' Check against each target procedure
        For j = 1 To targetProcs.count
            Dim targetProc As Object
            Set targetProc = targetProcs(j)
            
            Dim targetProcName As String
            
            If TypeOf targetProc Is Dictionary Then
                On Error Resume Next
                targetProcName = targetProc("Name")
                On Error GoTo 0
            End If
            
            If targetProcName <> "" Then
                ' Check for direct procedure calls
                If InStr(1, sourceBody, targetProcName & "(", vbTextCompare) > 0 Then
                    HasProceduralCalls = True
                    Exit Function
                End If
                
                ' Check for calls through the module
                If InStr(1, sourceBody, targetName & "." & targetProcName, vbTextCompare) > 0 Then
                    HasProceduralCalls = True
                    Exit Function
                End If
                
                ' Check for Application.Run calls
                If InStr(1, sourceBody, "Application.Run") > 0 And _
                   (InStr(1, sourceBody, """" & targetProcName & """", vbTextCompare) > 0 Or _
                    InStr(1, sourceBody, """" & targetName & "." & targetProcName & """", vbTextCompare) > 0) Then
                    HasProceduralCalls = True
                    Exit Function
                End If
            End If
        Next j
        
NextSourceProc:
        ' Add a DoEvents periodically
        If i Mod 5 = 0 Then
            DoEvents
        End If
    Next i
    
    Exit Function
    
ErrorHandler:
    HasProceduralCalls = False
End Function

' Check if source module implements interfaces from target module
Private Function ImplementsInterface(sourceModule As Object, targetModule As Object) As Boolean
    On Error GoTo ErrorHandler
    
    ImplementsInterface = False
    
    ' Get module names
    Dim sourceName As String, targetName As String
    
    If TypeOf sourceModule Is Dictionary Then
        On Error Resume Next
        sourceName = sourceModule("Name")
        On Error GoTo 0
    ElseIf IsObject(sourceModule) Then
        On Error Resume Next
        sourceName = sourceModule(1)
        On Error GoTo 0
    End If
    
    If TypeOf targetModule Is Dictionary Then
        On Error Resume Next
        targetName = targetModule("Name")
        On Error GoTo 0
    End If
    
    ' Get module body if available
    Dim sourceBody As String
    
    If TypeOf sourceModule Is Dictionary Then
        On Error Resume Next
        sourceBody = sourceModule("Body")
        On Error GoTo 0
    End If
    
    ' Check for Implements statements at module level
    If sourceBody <> "" Then
        If InStr(1, sourceBody, "Implements " & targetName, vbTextCompare) > 0 Then
            ImplementsInterface = True
            Exit Function
        End If
    End If
    
    Exit Function
    
ErrorHandler:
    ImplementsInterface = False
End Function


' Navigate to a specific module - focus on specific brain region
Public Sub NavigateToModule(moduleIndex As Long)
    On Error GoTo ErrorHandler
    
    ' Validate module index - verify brain region exists
    If moduleIndex < 1 Or moduleIndex > mModulesList.count Then
        If FunctionExists("DynamicUserFormManager.ShowMessage") Then
            Application.Run "DynamicUserFormManager.ShowMessage", "Invalid neural region index. Please enter a number between 1 and " & _
                     mModulesList.count, "Neural Navigation Error", vbExclamation
        End If
        Exit Sub
    End If
    
    ' Get module info - get brain region coordinates
    Dim module As Object
    Set module = mModulesList(moduleIndex)
    
    ' Extract module name
    Dim moduleName As String
    
    If TypeOf module Is Dictionary Then
        On Error Resume Next
        moduleName = module("Name")
        On Error GoTo 0
    ElseIf IsObject(module) Then
        ' Assume Collection structure
        On Error Resume Next
        moduleName = module(1)
        On Error GoTo 0
    End If
    
    ' Default value if not found
    If moduleName = "" Then moduleName = "Unknown Module " & moduleIndex
    
    ' Find module in document - locate brain region in patient
    FindModuleInDocument moduleName
    
    Exit Sub
    
ErrorHandler:
    ' Use safer error handling
    If FunctionExists("LogMessage") Then
        Application.Run "LogMessage", "Error in NavigateToModule: " & Err.Number & " - " & Err.description, "ERROR"
    End If
End Sub

' Navigate to a specific procedure - focus on specific neural function
Public Sub NavigateToProcedure(moduleIndex As Long, procIndex As Long)
    On Error GoTo ErrorHandler
    
    ' Validate module index - verify brain region exists
    If moduleIndex < 1 Or moduleIndex > mModulesList.count Then
        If FunctionExists("DynamicUserFormManager.ShowMessage") Then
            Application.Run "DynamicUserFormManager.ShowMessage", "Invalid neural region index. Please enter a region number between 1 and " & _
                     mModulesList.count, "Neural Navigation Error", vbExclamation
        End If
        Exit Sub
    End If
    
    ' Get module info - get brain region data
    Dim module As Object
    Set module = mModulesList(moduleIndex)
    
    ' Get procedures in module - get neural functions in region
    Dim procs As collection
    
    If TypeOf module Is Dictionary Then
        On Error Resume Next
        Set procs = module("Procedures")
        On Error GoTo 0
    ElseIf IsObject(module) Then
        ' Assume Collection structure
        On Error Resume Next
        Set procs = module(3) ' Assume procedures in position 3
        On Error GoTo 0
    End If
    
    ' Create empty collection if not found
    If procs Is Nothing Then Set procs = New collection
    
    ' Validate procedure index - verify neural function exists
    If procIndex < 1 Or procIndex > procs.count Then
        If FunctionExists("DynamicUserFormManager.ShowMessage") Then
            Application.Run "DynamicUserFormManager.ShowMessage", "Invalid neural function index. Please enter a function number between 1 and " & _
                     procs.count, "Neural Navigation Error", vbExclamation
        End If
        Exit Sub
    End If
    
    ' Get procedure info - get neural function data
    Dim proc As Object
    Set proc = procs(procIndex)
    
    ' Extract module and procedure names
    Dim moduleName As String, procName As String, procType As String
    
    If TypeOf module Is Dictionary Then
        On Error Resume Next
        moduleName = module("Name")
        On Error GoTo 0
    ElseIf IsObject(module) Then
        ' Assume Collection structure
        On Error Resume Next
        moduleName = module(1)
        On Error GoTo 0
    End If
    
    If TypeOf proc Is Dictionary Then
        On Error Resume Next
        procName = proc("Name")
        procType = proc("Type")
        On Error GoTo 0
    ElseIf IsObject(proc) Then
        ' Assume Collection structure
        On Error Resume Next
        procName = proc(1)
        procType = proc(2)
        On Error GoTo 0
    End If
    
    ' Default values if not found
    If moduleName = "" Then moduleName = "Unknown Module " & moduleIndex
    If procName = "" Then procName = "Unknown Procedure " & procIndex
    If procType = "" Then procType = "Sub"
    
    ' Find procedure in document - locate neural function in patient
    FindProcedureInDocument moduleName, procName, procType
    
    Exit Sub
    
ErrorHandler:
    ' Use safer error handling
    If FunctionExists("LogMessage") Then
        Application.Run "LogMessage", "Error in NavigateToProcedure: " & Err.Number & " - " & Err.description, "ERROR"
    End If
End Sub

' Find a module in the document - locate brain region in host tissue
Private Sub FindModuleInDocument(moduleName As String)
    On Error GoTo ErrorHandler
    
    ' Skip if moduleName is empty
    If Trim(moduleName) = "" Then
        Exit Sub
    End If
    
    ' For Mac, use a simpler search approach
    If mIsMac Then
        FindModuleInDocumentMac moduleName
        Exit Sub
    End If
    
    ' Look for module header - locate brain region marker
    Dim modulePattern As String
    modulePattern = "' " & moduleName
    
    ' Find pattern in document - scan host tissue
    Dim foundPos As Long
    
    ' Convert to search range - define search parameters
    Dim docRange As Object
    Set docRange = ThisDocument.content
    
    ' Set up search - configure neural scanner
    With docRange.Find
        .text = modulePattern
        .Forward = True
        .Wrap = wdFindStop
        .format = False
        .MatchCase = False
        .MatchWholeWord = False
        .MatchWildcards = False
        .MatchSoundsLike = False
        .MatchAllWordForms = False
        
        If .Execute Then
            ' Found it - select the module header - brain region identified
            docRange.Select
            
            ' Display message - report brain region location
            If FunctionExists("DynamicUserFormManager.ShowStatusMessage") Then
                Application.Run "DynamicUserFormManager.ShowStatusMessage", "Neural region '" & moduleName & "' located", True
                
                ' Non-blocking wait - instead of Application.Wait which blocks UI
                Dim startTime As Double
                startTime = Timer
                
                Do While Timer < startTime + 2
                    DoEvents ' Allow UI to remain responsive
                    
                    ' Break if processing interrupted
                    If Not mIsProcessing Then Exit Do
                Loop
                
                Application.Run "DynamicUserFormManager.ShowStatusMessage", "", False
            End If
        Else
            If FunctionExists("DynamicUserFormManager.ShowMessage") Then
                Application.Run "DynamicUserFormManager.ShowMessage", "Neural region '" & moduleName & "' not found in host tissue", _
                         "Neural Navigation Error", vbExclamation
            End If
        End If
    End With
    
    Exit Sub
    
ErrorHandler:
    ' Use safer error handling
    If FunctionExists("LogMessage") Then
        Application.Run "LogMessage", "Error in FindModuleInDocument: " & Err.Number & " - " & Err.description, "ERROR"
    End If
End Sub

' Mac-optimized module finder
Private Sub FindModuleInDocumentMac(moduleName As String)
    On Error GoTo ErrorHandler
    
    #If Mac Then
        ' Skip if moduleName is empty
        If Trim(moduleName) = "" Then
            Exit Sub
        End If
        
        ' Look for module header with a simpler pattern
        Dim modulePattern As String
        modulePattern = moduleName
        
        ' Use simplified search for Mac that's less likely to freeze
        Dim doc As Document
        Set doc = ThisDocument
        
        ' Split content into paragraphs for faster processing
        Dim content As String
        content = GetDocumentText()
        
        ' Search for the module name in the content
        Dim pos As Long
        pos = InStr(1, content, modulePattern, vbTextCompare)
        
        If pos > 0 Then
            ' Found it - select that position
            doc.Range(Start:=pos - 1, End:=pos + Len(modulePattern)).Select
            
            ' Display message
            If FunctionExists("DynamicUserFormManager.ShowStatusMessage") Then
                Application.Run "DynamicUserFormManager.ShowStatusMessage", "Neural region '" & moduleName & "' located", True
                
                ' Non-blocking wait
                Dim startTime As Double
                startTime = Timer
                
                Do While Timer < startTime + 1 ' Shorter wait on Mac
                    DoEvents
                    
                    ' Break if processing interrupted
                    If Not mIsProcessing Then Exit Do
                Loop
                
                Application.Run "DynamicUserFormManager.ShowStatusMessage", "", False
            End If
        Else
            If FunctionExists("DynamicUserFormManager.ShowMessage") Then
                Application.Run "DynamicUserFormManager.ShowMessage", "Neural region '" & moduleName & "' not found", _
                         "Neural Navigation Error", vbExclamation
            End If
        End If
    #End If
    
    Exit Sub
    
ErrorHandler:
    ' Use safer error handling
    If FunctionExists("LogMessage") Then
        Application.Run "LogMessage", "Error in FindModuleInDocumentMac: " & Err.Number & " - " & Err.description, "ERROR"
    End If
End Sub

' Find a procedure in the document - locate neural function in host tissue
Private Sub FindProcedureInDocument(moduleName As String, procName As String, procType As String)
    On Error GoTo ErrorHandler
    
    ' For Mac, use a simpler search approach
    If mIsMac Then
        FindProcedureInDocumentMac moduleName, procName, procType
        Exit Sub
    End If
    
    ' Get document content - access host organism
    Dim content As String
    content = GetDocumentText()
    
    ' First find the module - first locate brain region
    FindModuleInDocument moduleName
    
    ' Then look for procedure - then locate neural function
    Dim procPattern As String
    procPattern = procType & " " & procName
    
    ' Convert to search range - define search parameters
    Dim docRange As Object
    Set docRange = ThisDocument.content
    
    ' Set up search - configure neural scanner
    With docRange.Find
        .text = procPattern
        .Forward = True
        .Wrap = wdFindStop
        .format = False
        .MatchCase = False
        .MatchWholeWord = False
        .MatchWildcards = False
        .MatchSoundsLike = False
        .MatchAllWordForms = False
        
        If .Execute Then
            ' Found it - select the procedure declaration - neural function identified
            docRange.Select
            
            ' Display message - report neural function location
            If FunctionExists("DynamicUserFormManager.ShowStatusMessage") Then
                Application.Run "DynamicUserFormManager.ShowStatusMessage", "Neural function '" & procName & "' located", True
                
                ' Non-blocking wait - instead of Application.Wait which blocks UI
                Dim startTime As Double
                startTime = Timer
                
                Do While Timer < startTime + 2
                    DoEvents ' Allow UI to remain responsive
                    
                    ' Break if processing interrupted
                    If Not mIsProcessing Then Exit Do
                Loop
                
                Application.Run "DynamicUserFormManager.ShowStatusMessage", "", False
            End If
        Else
            If FunctionExists("DynamicUserFormManager.ShowMessage") Then
                Application.Run "DynamicUserFormManager.ShowMessage", "Neural function '" & procName & "' not found in region '" & moduleName & "'", _
                         "Neural Navigation Error", vbExclamation
            End If
        End If
    End With
    
    Exit Sub
    
ErrorHandler:
    ' Use safer error handling
    If FunctionExists("LogMessage") Then
        Application.Run "LogMessage", "Error in FindProcedureInDocument: " & Err.Number & " - " & Err.description, "ERROR"
    End If
End Sub

' Mac-optimized procedure finder
Private Sub FindProcedureInDocumentMac(moduleName As String, procName As String, procType As String)
    On Error GoTo ErrorHandler
    
    #If Mac Then
        ' Skip if procedure name is empty
        If Trim(procName) = "" Then
            Exit Sub
        End If
        
        ' Look for procedure pattern
        Dim procPattern As String
        procPattern = procType & " " & procName
        
        ' Use simplified search for Mac that's less likely to freeze
        Dim doc As Document
        Set doc = ThisDocument
        
        ' First try to find the module
        FindModuleInDocumentMac moduleName
        
        ' Get content for searching
        Dim content As String
        content = GetDocumentText()
        
        ' Search for the procedure name in the content
        Dim pos As Long
        pos = InStr(1, content, procPattern, vbTextCompare)
        
        If pos > 0 Then
            ' Found it - select that position
            doc.Range(Start:=pos - 1, End:=pos + Len(procPattern)).Select
            
            ' Display message
            If FunctionExists("DynamicUserFormManager.ShowStatusMessage") Then
                Application.Run "DynamicUserFormManager.ShowStatusMessage", "Neural function '" & procName & "' located", True
                
                ' Non-blocking wait
                Dim startTime As Double
                startTime = Timer
                
                Do While Timer < startTime + 1 ' Shorter wait on Mac
                    DoEvents
                    
                    ' Break if processing interrupted
                    If Not mIsProcessing Then Exit Do
                Loop
                
                Application.Run "DynamicUserFormManager.ShowStatusMessage", "", False
            End If
        Else
            If FunctionExists("DynamicUserFormManager.ShowMessage") Then
                Application.Run "DynamicUserFormManager.ShowMessage", "Neural function '" & procName & "' not found", _
                         "Neural Navigation Error", vbExclamation
            End If
        End If
    #End If
    
    Exit Sub
    
ErrorHandler:
    ' Use safer error handling
    If FunctionExists("LogMessage") Then
        Application.Run "LogMessage", "Error in FindProcedureInDocumentMac: " & Err.Number & " - " & Err.description, "ERROR"
    End If
End Sub

' Generate a concept map - create brain architecture visualization
Public Function GenerateConceptMap() As String
    On Error GoTo ErrorHandler
    
    ' For Mac, use simpler version to avoid freezing
    If mIsMac Then
        GenerateConceptMap = GenerateConceptMapMac()
        Exit Function
    End If
    
    Dim result As String
    Dim i As Long, j As Long ' Loop counters - scanning indices
    
    ' Create header - cerebral map title
    result = "NEURAL CONCEPT MAP" & vbCrLf & String(50, "=") & vbCrLf & vbCrLf
    
    ' Set processing flag and timer
    mIsProcessing = True
    mLastProcessTime = Timer
    
    ' Limit modules to prevent freezing
    Dim moduleLimit As Long
    moduleLimit = 10 ' Only process 10 modules
    
    If mModulesList.count < moduleLimit Then moduleLimit = mModulesList.count
    
    ' Generate simplified concept map - basic brain architecture visualization
    For i = 1 To moduleLimit
        ' Add a DoEvents periodically
        If i Mod 2 = 0 Then DoEvents
        
        ' Check for timeout
        If Timer - mLastProcessTime > MAX_PROCESSING_TIME Then
            result = result & vbCrLf & "[Processing timeout - remaining concept map not generated]" & vbCrLf
            Exit For
        End If
        
        Dim module As Object
        Set module = mModulesList(i)
        
        ' Extract module name
        Dim moduleName As String
        
        If TypeOf module Is Dictionary Then
            On Error Resume Next
            moduleName = module("Name")
            On Error GoTo 0
        ElseIf IsObject(module) Then
            ' Assume Collection structure
            On Error Resume Next
            moduleName = module(1)
            On Error GoTo 0
        End If
        
        ' Default value if not found
        If moduleName = "" Then moduleName = "Unknown Module " & i
        
        ' Get module description based on name - brain region functional description
        Dim description As String
        description = GetModuleDescription(moduleName)
        
        ' Add module with description - document brain region function
        result = result & "[ " & moduleName & " ]" & vbCrLf
        result = result & "  " & description & vbCrLf & vbCrLf
        
        ' Find dependencies - trace neural pathways
        Dim dependencies As collection
        Set dependencies = FindDependencies(module)
        
        ' Limit dependencies to prevent freezing
        Dim depLimit As Long
        depLimit = 3 ' Only show 3 dependencies per module
        
        If dependencies.count < depLimit Then depLimit = dependencies.count
        
        ' Show dependencies - display neural connections
        For j = 1 To depLimit
            result = result & "  ? " & dependencies(j) & vbCrLf
        Next j
        
        ' Show message if more dependencies exist
        If dependencies.count > depLimit Then
            result = result & "  [" & (dependencies.count - depLimit) & " more connections not shown]" & vbCrLf
        End If
        
        result = result & vbCrLf
    Next i
    
    ' Show message if more modules exist
    If mModulesList.count > moduleLimit Then
        result = result & "[" & (mModulesList.count - moduleLimit) & " more regions not shown]" & vbCrLf
    End If
    
    ' Reset processing flag
    mIsProcessing = False
    
    GenerateConceptMap = result
    
    Exit Function
    
ErrorHandler:
    ' Reset processing flag
    mIsProcessing = False
    
    If FunctionExists("LogMessage") Then
        Application.Run "LogMessage", "Error in GenerateConceptMap: " & Err.Number & " - " & Err.description, "ERROR"
    End If
    
    ' Return a simple error message
    GenerateConceptMap = "Neural concept map generation failed." & vbCrLf & _
                       "Error: " & Err.description
End Function

' Mac-optimized concept map generator
Private Function GenerateConceptMapMac() As String
    On Error GoTo ErrorHandler
    
    Dim result As String
    
    ' Create simplified header
    result = "NEURAL CONCEPT MAP (Mac Optimized)" & vbCrLf & String(30, "=") & vbCrLf & vbCrLf
    
    ' Set processing flag and timer
    mIsProcessing = True
    mLastProcessTime = Timer
    
    ' Limit modules for Mac
    Dim moduleLimit As Long
    moduleLimit = 5 ' Only process 5 modules on Mac
    
    If mModulesList.count < moduleLimit Then moduleLimit = mModulesList.count
    
    ' Generate very simplified concept map
    Dim i As Long
    For i = 1 To moduleLimit
        ' Add a DoEvents periodically
        If i Mod 2 = 0 Then DoEvents
        
        ' Extract module name
        Dim moduleName As String
        
        If TypeOf mModulesList(i) Is Dictionary Then
            On Error Resume Next
            moduleName = mModulesList(i)("Name")
            On Error GoTo 0
        ElseIf IsObject(mModulesList(i)) Then
            ' Assume Collection structure
            On Error Resume Next
            moduleName = mModulesList(i)(1)
            On Error GoTo 0
        End If
        
        ' Default value if not found
        If moduleName = "" Then moduleName = "Unknown Module " & i
        
        ' Get module description
        Dim description As String
        description = GetModuleDescription(moduleName)
        
        ' Add to result
        result = result & "[ " & moduleName & " ]" & vbCrLf
        result = result & "  " & description & vbCrLf & vbCrLf
    Next i
    
    ' Show message if more modules exist
    If mModulesList.count > moduleLimit Then
        result = result & "[" & (mModulesList.count - moduleLimit) & " more regions not shown]" & vbCrLf
    End If
    
    ' Reset processing flag
    mIsProcessing = False
    
    GenerateConceptMapMac = result
    
    Exit Function
    
ErrorHandler:
    ' Reset processing flag
    mIsProcessing = False
    
    If FunctionExists("LogMessage") Then
        Application.Run "LogMessage", "Error in GenerateConceptMapMac: " & Err.Number & " - " & Err.description, "ERROR"
    End If
    
    ' Return a simple error message
    GenerateConceptMapMac = "Neural concept map generation failed on Mac." & vbCrLf & _
                          "Error: " & Err.description
End Function

' Get a description for a module based on its name - deduce brain region function
Private Function GetModuleDescription(moduleName As String) As String
    ' Generate a description based on module name - infer neural function from name
    Dim lowerName As String
    lowerName = LCase(moduleName)
    
    If InStr(lowerName, "main") > 0 Then
        GetModuleDescription = "Central nervous system controller - primary infection vector"
    ElseIf InStr(lowerName, "platform") > 0 Then
        GetModuleDescription = "Host species detection and cross-platform infection capabilities"
    ElseIf InStr(lowerName, "file") > 0 Then
        GetModuleDescription = "File system operations - external tissue penetration"
    ElseIf InStr(lowerName, "ui") > 0 Then
        GetModuleDescription = "User interface functions - sensory manipulation and deception"
    ElseIf InStr(lowerName, "error") > 0 Then
        GetModuleDescription = "Error handling - immunosuppression and resistance management"
    ElseIf InStr(lowerName, "format") > 0 Or InStr(lowerName, "theme") > 0 Then
        GetModuleDescription = "Visual formatting - camouflage and aesthetic neurotoxins"
    ElseIf InStr(lowerName, "regex") > 0 Then
        GetModuleDescription = "Pattern matching - genetic sequencing and manipulation"
    ElseIf InStr(lowerName, "navigat") > 0 Then
        GetModuleDescription = "Neural pathway mapping and cerebral visualization"
    ElseIf InStr(lowerName, "health") > 0 Or InStr(lowerName, "analy") > 0 Then
        GetModuleDescription = "Code quality analysis - parasite health monitoring"
    ElseIf InStr(lowerName, "templat") > 0 Then
        GetModuleDescription = "Template engine - genetic cloning and reproduction"
    ElseIf InStr(lowerName, "export") > 0 Or InStr(lowerName, "document") > 0 Then
        GetModuleDescription = "Document generation - external parasite propagation"
    Else
        GetModuleDescription = "Utility functions - specialized infection tools"
    End If
End Function

' Helper function to get document text - access host tissues
Private Function GetDocumentText() As String
    On Error Resume Next
    GetDocumentText = ThisDocument.content.text
    If Err.Number <> 0 Then
        GetDocumentText = ""
    End If
    On Error GoTo 0
End Function

'=============================================================================
' END MODULE: modCodeNavigator
'=============================================================================

‘********************************************************* 
‘‘***************** ‘coVdEeNcOoMde ‘******************     
‘********************************************************* 
'=============================================================================
' BEGIN MODULE: modGeneSplicer (standard module)
'=============================================================================
' =============================================================================
' modGeneSplicer - Genetic Code Restructuring and DNA Optimization
' Version: 2.1 Mac-Optimized
' This code doesn't contain bugs, just spontaneous genetic mutations of unknown origin.
' Updated by: Aaron McCutchins on 2025-05-13
' =============================================================================
Option Explicit

' Module state - parasite genetic manipulation controls
Private mSuggestions As collection ' Collection of genetic splicing suggestions
Private mIsInitialized As Boolean ' Has the parasite attached to the host?
Private mIsMac As Boolean ' Is this a Mac host?

' Mac optimization settings
Private mLastProcessTime As Double
Private mIsProcessing As Boolean
Private Const MAX_PROCESSING_TIME As Double = 3 ' seconds for timeout protection
Private Const MAC_CHUNK_SIZE As Long = 5000 ' characters to process at once on Mac

' Initialize the gene splicer - activate genetic manipulation parasite
Public Sub InitializeGeneSplicer()
    On Error GoTo ErrorHandler
    
    If mIsInitialized Then Exit Sub
    
    ' Detect platform
    #If Mac Then
        mIsMac = True
    #Else
        mIsMac = False
    #End If
    
    ' If gIsMac exists, use that value (from modPlatform)
    On Error Resume Next
    If Not IsEmpty(gIsMac) Then
        mIsMac = gIsMac
    End If
    On Error GoTo ErrorHandler
    
    Set mSuggestions = New collection
    
    mIsInitialized = True
    
    ' Log initialization
    If FunctionExists("LogMessage") Then
        Application.Run "LogMessage", "Genetic splicing apparatus initialized - DNA manipulation protocols ready"
    End If
    
    Exit Sub
    
ErrorHandler:
    ' Ensure we initialize even with errors
    mIsInitialized = True
    
    ' Log error
    If FunctionExists("LogMessage") Then
        Application.Run "LogMessage", "Error initializing genetic splicing apparatus: " & Err.Number & " - " & Err.description, "ERROR"
    End If
End Sub

' Helper function to check if a function exists
Private Function FunctionExists(functionName As String) As Boolean
    On Error Resume Next
    FunctionExists = False
    
    ' Try to get the VBA function info
    Dim dummyVal As Variant
    dummyVal = Application.Run(functionName)
    
    If Err.Number = 0 Or Err.Number = 449 Then
        ' 449 = "Argument not optional" - means function exists but needs arguments
        FunctionExists = True
    End If
    
    On Error GoTo 0
End Function

' Organize code into logical modules - restructure host DNA for optimal infection
Public Function OrganizeCode(codeText As String) As String
    On Error GoTo ErrorHandler
    
    ' Reset processing flags
    mIsProcessing = False
    mLastProcessTime = Timer
    
    ' Ensure we're initialized - verify parasite attachment
    If Not mIsInitialized Then InitializeGeneSplicer
    
    ' On Mac, check if the code is too large to process all at once
    If mIsMac And Len(codeText) > 50000 Then
        If FunctionExists("LogMessage") Then
            Application.Run "LogMessage", "Large code detected on Mac - using chunked processing strategy", "INFO"
        End If
        
        ' Use simplified approach for very large code on Mac
        Dim organizedCodeMac As String
        organizedCodeMac = OrganizeCodeMac(codeText)
        OrganizeCode = organizedCodeMac
        Exit Function
    End If
    
    mIsProcessing = True
    
    ' First, analyze the code to get structure info - perform genetic sequencing
    Dim codeInfo As Object
    
    If FunctionExists("CodeAnalysis.AnalyzeCodeStructure") Then
        ' Use timeout protection for analysis
        mLastProcessTime = Timer
        
        On Error Resume Next
        Set codeInfo = Application.Run("CodeAnalysis.AnalyzeCodeStructure", codeText)
        
        ' Check for timeout or errors
        If Err.Number <> 0 Or Timer - mLastProcessTime > MAX_PROCESSING_TIME Then
            ' Fall back to simplified analysis
            Err.Clear
            Set codeInfo = CreateSimpleCodeAnalysis(codeText)
        End If
        On Error GoTo ErrorHandler
    Else
        ' CodeAnalysis not available, create a simple structure
        Set codeInfo = CreateSimpleCodeAnalysis(codeText)
    End If
    
    ' Check if code info exists and has valid data
    If codeInfo Is Nothing Then
        Set codeInfo = CreateSimpleCodeAnalysis(codeText)
    End If
    
    ' Create a record for the new organized code - prepare genetic restructuring blueprint
    Dim organizedCode As String
    
    ' Check if we need to organize the code - assess genetic complexity
    Dim ModuleCount As Long
    
    On Error Resume Next
    If TypeOf codeInfo Is Dictionary Then
        ModuleCount = codeInfo("ModuleCount")
    Else
        ModuleCount = 1
    End If
    On Error GoTo ErrorHandler
    
    If ModuleCount <= 1 Then
        ' Either already organized or too little code to organize - simple genetic structure
        If FunctionExists("LogMessage") Then
            Application.Run "LogMessage", "Host DNA not complex enough to require full genetic restructuring"
        End If
        organizedCode = SuggestModuleStructure(codeText, codeInfo)
    Else
        ' Code already has multiple modules - complex genetic structure
        If FunctionExists("LogMessage") Then
            Application.Run "LogMessage", "Host DNA already has " & ModuleCount & " chromosomal regions, preserving genetic structure"
        End If
        organizedCode = codeText
    End If
    
    ' Fix common issues - repair genetic defects
    mLastProcessTime = Timer ' Reset timer
    organizedCode = FixCommonIssues(organizedCode)
    
    ' Reset processing flag
    mIsProcessing = False
    
    ' Return organized code - return restructured genetic material
    OrganizeCode = organizedCode
    
    Exit Function
    
ErrorHandler:
    ' Reset processing flag
    mIsProcessing = False
    
    ' Log error
    If FunctionExists("LogMessage") Then
        Application.Run "LogMessage", "Genetic restructuring failure: " & Err.Number & " - " & Err.description, "ERROR"
    End If
    
    If FunctionExists("ErrorHandler.HandleError") Then
        Application.Run "ErrorHandler.HandleError", "modGeneSplicer", "OrganizeCode", Err.Number, Err.description
    End If
    
    OrganizeCode = codeText ' Return original in case of error - revert to original genetic structure
End Function

' Mac-optimized version of OrganizeCode
Private Function OrganizeCodeMac(codeText As String) As String
    On Error GoTo ErrorHandler
    
    mIsProcessing = True
    
    ' First, fix common issues that don't require full analysis
    Dim result As String
    result = codeText
    
    ' Fix line endings
    result = Replace(result, vbCr, "")
    result = Replace(result, vbLf, vbCrLf)
    
    ' Remove duplicate blank lines
    Do While InStr(1, result, vbCrLf & vbCrLf & vbCrLf) > 0
        result = Replace(result, vbCrLf & vbCrLf & vbCrLf, vbCrLf & vbCrLf)
        
        ' Check if we should refresh UI
        If Timer - mLastProcessTime > MAX_PROCESSING_TIME / 2 Then
            DoEvents
            mLastProcessTime = Timer
        End If
    Loop
    
    ' Ensure Option Explicit is present in all modules
    If InStr(1, result, "Option Explicit", vbTextCompare) = 0 Then
        ' Add Option Explicit - use optimized version
        result = AddOptionExplicitMac(result)
    End If
    
    ' Process in smaller chunks if needed for error handling enhancement
    If Len(result) > 50000 Then
        ' For very large files, skip procedure enhancement on Mac
        If FunctionExists("LogMessage") Then
            Application.Run "LogMessage", "Large code detected on Mac - skipping procedure enhancement", "INFO"
        End If
    Else
        ' Try to selectively enhance error handling in a Mac-friendly way
        result = EnhanceProceduresMac(result)
    End If
    
    ' Reset processing flag
    mIsProcessing = False
    
    OrganizeCodeMac = result
    
    Exit Function
    
ErrorHandler:
    ' Reset processing flag
    mIsProcessing = False
    
    ' Log error
    If FunctionExists("LogMessage") Then
        Application.Run "LogMessage", "Mac genetic restructuring failure: " & Err.Number & " - " & Err.description, "ERROR"
    End If
    
    OrganizeCodeMac = codeText ' Return original in case of error
End Function

' Create a simple code analysis when full analysis is not available
Private Function CreateSimpleCodeAnalysis(codeText As String) As Object
    On Error Resume Next
    
    ' Create a Dictionary to hold code analysis
    #If Mac Then
        ' For Mac, we need to create something that can handle modules
        Dim simpleAnalysis As Object
        Set simpleAnalysis = CreateObject("Scripting.Dictionary")
        
        ' Add basic info
        simpleAnalysis.Add "LineCount", CountLines(codeText)
        simpleAnalysis.Add "ModuleCount", 1
        
        ' Count procedures
        Dim procCount As Long
        procCount = CountProcedures(codeText)
        simpleAnalysis.Add "ProcedureCount", procCount
        
        ' Create procedures collection
        Dim procedures As New collection
        
        ' Try to extract procedures
        Dim lines As Variant
        lines = Split(codeText, vbCrLf)
        
        Dim i As Long
        Dim inProc As Boolean
        Dim procStartLine As Long
        Dim procType As String
        Dim procName As String
        Dim procBody As String
        
        inProc = False
        
        For i = 0 To UBound(lines)
            ' Check for procedure start
            If Not inProc And IsProcedureStart(lines(i)) Then
                inProc = True
                procStartLine = i
                
                ' Extract procedure type and name
                ExtractProcInfo lines(i), procType, procName
            
            ' Check for procedure end
            ElseIf inProc And IsProcedureEnd(lines(i)) Then
                inProc = False
                
                ' Extract procedure body
                procBody = JoinLines(lines, procStartLine, i)
                
                ' Create procedure dictionary
                Dim procDict As Object
                Set procDict = CreateObject("Scripting.Dictionary")
                procDict.Add "Type", procType
                procDict.Add "Name", procName
                procDict.Add "Body", procBody
                
                ' Add to procedures collection
                procedures.Add procDict
                
                ' Refresh UI occasionally
                If i Mod 100 = 0 Then DoEvents
            End If
        Next i
        
        ' Add procedures to analysis
        simpleAnalysis.Add "Procedures", procedures
        
        ' Create modules collection with one module
        Dim modules As New collection
        Dim moduleDict As Object
        Set moduleDict = CreateObject("Scripting.Dictionary")
        
        moduleDict.Add "Name", "Main"
        moduleDict.Add "Type", "Standard Module"
        moduleDict.Add "Procedures", procedures
        
        modules.Add moduleDict
        simpleAnalysis.Add "Modules", modules
        
        Set CreateSimpleCodeAnalysis = simpleAnalysis
    #Else
        ' For Windows, use regular Dictionary
        Dim simpleAnalysis As Object
        Set simpleAnalysis = CreateObject("Scripting.Dictionary")
        
        ' Add basic info
        simpleAnalysis.Add "LineCount", CountLines(codeText)
        simpleAnalysis.Add "ModuleCount", 1
        
        ' Count procedures
        Dim procCount As Long
        procCount = CountProcedures(codeText)
        simpleAnalysis.Add "ProcedureCount", procCount
        
        ' Create procedures collection
        Dim procedures As New collection
        
        ' Try to extract procedures
        Dim lines As Variant
        lines = Split(codeText, vbCrLf)
        
        Dim i As Long
        Dim inProc As Boolean
        Dim procStartLine As Long
        Dim procType As String
        Dim procName As String
        Dim procBody As String
        
        inProc = False
        
        For i = 0 To UBound(lines)
            ' Check for procedure start
            If Not inProc And IsProcedureStart(lines(i)) Then
                inProc = True
                procStartLine = i
                
                ' Extract procedure type and name
                ExtractProcInfo lines(i), procType, procName
            
            ' Check for procedure end
            ElseIf inProc And IsProcedureEnd(lines(i)) Then
                inProc = False
                
                ' Extract procedure body
                procBody = JoinLines(lines, procStartLine, i)
                
                ' Create procedure dictionary
                Dim procDict As Object
                Set procDict = CreateObject("Scripting.Dictionary")
                procDict.Add "Type", procType
                procDict.Add "Name", procName
                procDict.Add "Body", procBody
                
                ' Add to procedures collection
                procedures.Add procDict
            End If
        Next i
        
        ' Add procedures to analysis
        simpleAnalysis.Add "Procedures", procedures
        
        ' Create modules collection with one module
        Dim modules As New collection
        Dim moduleDict As Object
        Set moduleDict = CreateObject("Scripting.Dictionary")
        
        moduleDict.Add "Name", "Main"
        moduleDict.Add "Type", "Standard Module"
        moduleDict.Add "Procedures", procedures
        
        modules.Add moduleDict
        simpleAnalysis.Add "Modules", modules
        
        Set CreateSimpleCodeAnalysis = simpleAnalysis
    #End If
    
    On Error GoTo 0
End Function

' Count lines in a text string
Private Function CountLines(text As String) As Long
    Dim i As Long, count As Long
    
    ' Count line breaks
    count = 1 ' Start with 1 for the last line
    
    For i = 1 To Len(text)
        If Mid(text, i, 1) = vbCr Or Mid(text, i, 1) = vbLf Then
            count = count + 1
            
            ' Skip extra CR/LF in CRLF sequence
            If i < Len(text) Then
                If Mid(text, i, 1) = vbCr And Mid(text, i + 1, 1) = vbLf Then
                    i = i + 1
                End If
            End If
        End If
        
        ' Add timeout protection for very long strings
        If i Mod 1000 = 0 Then
            DoEvents
        End If
    Next i
    
    CountLines = count
End Function

' Count procedures in text
Private Function CountProcedures(text As String) As Long
    Dim lines As Variant
    Dim i As Long
    Dim count As Long
    
    count = 0
    lines = Split(text, vbCrLf)
    
    For i = 0 To UBound(lines)
        If IsProcedureStart(lines(i)) Then
            count = count + 1
        End If
        
        ' Add timeout protection
        If i Mod 100 = 0 Then
            DoEvents
        End If
    Next i
    
    CountProcedures = count
End Function

' Extract procedure type and name from a line
Private Sub ExtractProcInfo(line As Variant, ByRef procType As String, ByRef procName As String)
    Dim trimLine As String
    trimLine = Trim(line)
    
    ' Find procedure type
    If InStr(1, trimLine, "Sub ", vbTextCompare) > 0 Then
        procType = "Sub"
    ElseIf InStr(1, trimLine, "Function ", vbTextCompare) > 0 Then
        procType = "Function"
    ElseIf InStr(1, trimLine, "Property Get ", vbTextCompare) > 0 Then
        procType = "PropertyGet"
    ElseIf InStr(1, trimLine, "Property Let ", vbTextCompare) > 0 Then
        procType = "PropertyLet"
    ElseIf InStr(1, trimLine, "Property Set ", vbTextCompare) > 0 Then
        procType = "PropertySet"
    Else
        procType = "Unknown"
    End If
    
    ' Extract name
    Dim nameStart As Long
    Dim nameEnd As Long
    
    nameStart = InStr(1, trimLine, procType, vbTextCompare) + Len(procType) + 1
    nameEnd = InStr(nameStart, trimLine, "(")
    
    If nameEnd = 0 Then nameEnd = Len(trimLine) + 1
    
    procName = Trim(Mid(trimLine, nameStart, nameEnd - nameStart))
End Sub

' Join lines to create a procedure body
Private Function JoinLines(lines As Variant, startLine As Long, endLine As Long) As String
    Dim i As Long
    Dim result As String
    
    result = ""
    
    For i = startLine To endLine
        result = result & lines(i) & vbCrLf
    Next i
    
    JoinLines = result
End Function

' Suggest module structure for unorganized code - create genetic restructuring plan
Private Function SuggestModuleStructure(codeText As String, codeInfo As Object) As String
    On Error GoTo ErrorHandler
    
    ' For Mac, use simpler approach for large code
    If mIsMac And Len(codeText) > 30000 Then
        SuggestModuleStructure = codeText
        Exit Function
    End If
    
    Dim procedures As collection ' Cellular functions
    Dim moduleSuggestions As Object ' Suggested chromosomal groupings
    Dim newCode As String ' Restructured genetic code
    
    ' Get procedure collection - catalog cellular functions
    On Error Resume Next
    If TypeOf codeInfo Is Dictionary Then
        Set procedures = codeInfo("Procedures")
    Else
        ' Create empty collection
        Set procedures = New collection
    End If
    On Error GoTo ErrorHandler
    
    ' Make sure procedures is not Nothing
    If procedures Is Nothing Then Set procedures = New collection
    
    ' Set processing flag and reset timer
    mIsProcessing = True
    mLastProcessTime = Timer
    
    ' Group procedures into suggested modules - identify optimal genetic clusters
    Set moduleSuggestions = GroupProceduresIntoModules(procedures)
    
    ' Create the organized code structure - build optimized genetic sequence
    newCode = BuildOrganizedCode(codeText, procedures, moduleSuggestions)
    
    ' Reset processing flag
    mIsProcessing = False
    
    SuggestModuleStructure = newCode
    
    Exit Function
    
ErrorHandler:
    ' Reset processing flag
    mIsProcessing = False
    
    ' Log error
    If FunctionExists("LogMessage") Then
        Application.Run "LogMessage", "Genetic restructuring plan creation failed: " & Err.Number & " - " & Err.description, "ERROR"
    End If
    
    If FunctionExists("ErrorHandler.HandleError") Then
        Application.Run "ErrorHandler.HandleError", "modGeneSplicer", "SuggestModuleStructure", Err.Number, Err.description
    End If
    
    SuggestModuleStructure = codeText ' Return original in case of error - abort genetic restructuring
End Function

' Group procedures into logical modules - identify optimal chromosomal regions
Private Function GroupProceduresIntoModules(procedures As collection) As Object
    On Error GoTo ErrorHandler
    
    ' Create a Dictionary to hold module suggestions
    Dim moduleSuggestions As Object
    Set moduleSuggestions = CreateObject("Scripting.Dictionary")
    
    ' Create common module categories - primary chromosomal regions
    On Error Resume Next
    moduleSuggestions.Add "Main", New collection ' Central nervous system
    moduleSuggestions.Add "FileSystem", New collection ' External tissue interface
    moduleSuggestions.Add "UI", New collection ' Sensory organ interface
    moduleSuggestions.Add "Utilities", New collection ' Support functions
    moduleSuggestions.Add "Platform", New collection ' Environmental adaptation
    On Error GoTo ErrorHandler
    
    ' Categorize procedures by name and content - genetic classification by function
    Dim i As Long
    Dim proc As Object
    Dim body As String
    Dim moduleKey As String
    
    For i = 1 To procedures.count
        ' Add periodic UI refresh
        If i Mod 5 = 0 Then
            DoEvents
            
            ' Check for timeout
            If Timer - mLastProcessTime > MAX_PROCESSING_TIME Then
                If FunctionExists("LogMessage") Then
                    Application.Run "LogMessage", "Genetic classification timeout after processing " & i & " of " & procedures.count & " cells", "WARNING"
                End If
                Exit For
            End If
        End If
        
        Set proc = procedures(i)
        
        ' Default chromosomal region
        moduleKey = "Main"
        
        ' Extract procedure body safely
        On Error Resume Next
        If TypeOf proc Is Dictionary Then
            body = LCase(proc("Body"))
        Else
            body = ""
        End If
        On Error GoTo ErrorHandler
        
        ' Determine best module based on procedure characteristics - analyze genetic markers
        
        ' Check procedure name for clues - examine genetic nomenclature
        Dim procName As String
        
        On Error Resume Next
        If TypeOf proc Is Dictionary Then
            procName = LCase(proc("Name"))
        Else
            procName = "unknown"
        End If
        On Error GoTo ErrorHandler
        
        ' File-related procedures - external tissue interface cells
        If InStr(1, procName, "file") > 0 Or _
           InStr(1, procName, "folder") > 0 Or _
           InStr(1, procName, "directory") > 0 Or _
           InStr(1, procName, "path") > 0 Then
            moduleKey = "FileSystem"
            
        ' UI-related procedures - sensory organ interface cells
        ElseIf InStr(1, procName, "show") > 0 Or _
               InStr(1, procName, "display") > 0 Or _
               InStr(1, procName, "message") > 0 Or _
               InStr(1, procName, "dialog") > 0 Or _
               InStr(1, procName, "form") > 0 Then
            moduleKey = "UI"
            
        ' Platform-related procedures - environmental adaptation cells
        ElseIf InStr(1, procName, "platform") > 0 Or _
               InStr(1, procName, "mac") > 0 Or _
               InStr(1, procName, "win") > 0 Or _
               InStr(1, procName, "os") > 0 Then
            moduleKey = "Platform"
            
        ' Utility procedures (check content) - support function cells
        ElseIf TypeOf proc Is Dictionary Then
            On Error Resume Next
            If proc("Type") = "Function" And Not _
               (InStr(1, body, "msgbox") > 0 Or _
                InStr(1, body, "filesystemobject") > 0) Then
                moduleKey = "Utilities"
            End If
            On Error GoTo ErrorHandler
        End If
        
        ' Also check procedure content for clues - analyze cellular behavior
        If moduleKey = "Main" Then
            ' File operations in body - external tissue interaction
            If InStr(1, body, "open ") > 0 Or _
               InStr(1, body, "close #") > 0 Or _
               InStr(1, body, "filesystemobject") > 0 Or _
               InStr(1, body, "mkdir") > 0 Then
                moduleKey = "FileSystem"
                
            ' UI operations in body - sensory organ stimulation
            ElseIf InStr(1, body, "msgbox") > 0 Or _
                   InStr(1, body, "inputbox") > 0 Or _
                   InStr(1, body, "userform") > 0 Then
                moduleKey = "UI"
                
            ' Platform checks in body - environmental sensing
            ElseIf InStr(1, body, "#if mac") > 0 Or _
                   InStr(1, body, "macscript") > 0 Or _
                   InStr(1, body, "application.operatingsystem") > 0 Then
                moduleKey = "Platform"
            End If
        End If
        
        ' Add to appropriate module collection - assign to chromosomal region
        On Error Resume Next
        If moduleSuggestions.exists(moduleKey) Then
            moduleSuggestions(moduleKey).Add proc
        Else
            ' Create new collection if key doesn't exist
            Set moduleSuggestions(moduleKey) = New collection
            moduleSuggestions(moduleKey).Add proc
        End If
        On Error GoTo ErrorHandler
    Next i
    
    ' Clean up empty modules - remove empty chromosomal regions
    Dim keys As Variant
    keys = moduleSuggestions.keys
    
    For i = 0 To UBound(keys)
        moduleKey = keys(i)
        
        On Error Resume Next
        If moduleSuggestions(moduleKey).count = 0 Then
            moduleSuggestions.Remove moduleKey
        End If
        On Error GoTo ErrorHandler
    Next i
    
    ' If Main and Utilities both exist and Main is small, merge them - optimize genetic structure
    On Error Resume Next
    If moduleSuggestions.exists("Main") And moduleSuggestions.exists("Utilities") Then
        If moduleSuggestions("Main").count <= 2 Then
            ' Merge Main into Utilities - combine chromosomal regions
            For i = 1 To moduleSuggestions("Main").count
                moduleSuggestions("Utilities").Add moduleSuggestions("Main")(i)
            Next i
            moduleSuggestions.Remove "Main"
        End If
    End If
    On Error GoTo ErrorHandler
    
    Set GroupProceduresIntoModules = moduleSuggestions
    
    Exit Function
    
ErrorHandler:
    If FunctionExists("LogMessage") Then
        Application.Run "LogMessage", "Chromosomal grouping failure: " & Err.Number & " - " & Err.description, "ERROR"
    End If
    
    If FunctionExists("ErrorHandler.HandleError") Then
        Application.Run "ErrorHandler.HandleError", "modGeneSplicer", "GroupProceduresIntoModules", Err.Number, Err.description
    End If
    
    ' Return simple dictionary with all procedures in Main - fallback to single-chromosome organism
    Set moduleSuggestions = CreateObject("Scripting.Dictionary")
    
    On Error Resume Next
    moduleSuggestions.Add "Main", procedures
    On Error GoTo 0
    
    Set GroupProceduresIntoModules = moduleSuggestions
End Function

' Build organized code structure - create restructured genetic sequence
Private Function BuildOrganizedCode(codeText As String, procedures As collection, _
                                  moduleSuggestions As Object) As String
    On Error GoTo ErrorHandler
    
    Dim result As String
    Dim moduleKeys As Variant
    Dim i As Long, j As Long
    Dim moduleKey As String
    Dim moduleProcs As collection
    Dim proc As Object
    
    ' Start with empty result - fresh genetic template
    result = ""
    
    ' Get module keys - chromosomal region identifiers
    moduleKeys = moduleSuggestions.keys
    
    ' Process each module - construct each chromosomal region
    For i = 0 To UBound(moduleKeys)
        ' Add periodic UI refresh
        If i Mod 2 = 0 Then
            DoEvents
            
            ' Check for timeout
            If Timer - mLastProcessTime > MAX_PROCESSING_TIME Then
                ' Add note about timeout
                result = result & vbCrLf & "' Note: Code organization was interrupted due to timeout" & vbCrLf
                If FunctionExists("LogMessage") Then
                    Application.Run "LogMessage", "Genetic sequence assembly timeout", "WARNING"
                End If
                Exit For
            End If
        End If
        
        moduleKey = moduleKeys(i)
        
        On Error Resume Next
        Set moduleProcs = moduleSuggestions(moduleKey)
        On Error GoTo ErrorHandler
        
        ' Skip empty modules - ignore empty chromosomal regions
        If moduleProcs Is Nothing Or moduleProcs.count = 0 Then GoTo NextModule
        
        ' Add module header - create chromosomal marker
        Dim sectionDivider As String
        
        ' Try to use CodeFormatter if available
        On Error Resume Next
        If FunctionExists("CodeFormatter.CreateSectionDivider") Then
            sectionDivider = Application.Run("CodeFormatter.CreateSectionDivider", GetModuleNameWithPrefix(moduleKey))
        Else
            ' Fallback to simple divider
            sectionDivider = "' =============================================================================" & vbCrLf & _
                            "' " & GetModuleNameWithPrefix(moduleKey) & vbCrLf & _
                            "' ============================================================================="
        End If
        On Error GoTo ErrorHandler
        
        result = result & sectionDivider & vbCrLf
        
        ' Add Option Explicit - genetic validation marker
        result = result & "Option Explicit" & vbCrLf & vbCrLf
        
        ' Add module-level declarations if needed - chromosomal-level variables
        result = result & GetModuleLevelDeclarations(moduleKey) & vbCrLf
        
        ' Add procedures - add cellular functions
        For j = 1 To moduleProcs.count
            ' Add periodic UI refresh for long modules
            If j Mod 10 = 0 Then
                DoEvents
                
                ' Check for timeout
                If Timer - mLastProcessTime > MAX_PROCESSING_TIME Then
                    ' Add note about timeout
                    result = result & vbCrLf & "' Note: Module organization was interrupted due to timeout" & vbCrLf
                    Exit For
                End If
            End If
            
            Set proc = moduleProcs(j)
            
            On Error Resume Next
            Dim procBody As String
            If TypeOf proc Is Dictionary Then
                procBody = proc("Body")
                
                ' Also get name and type for enhancement
                Dim procName As String, procType As String
                procName = proc("Name")
                procType = proc("Type")
                
                ' Add procedure with any needed modifications - enhanced cellular function
                result = result & EnhanceProcedure(procBody, procName, procType) & vbCrLf & vbCrLf
            Else
                ' If not a Dictionary, just add a placeholder
                result = result & "' Procedure data not available" & vbCrLf & vbCrLf
            End If
            On Error GoTo ErrorHandler
        Next j
        
NextModule:
    Next i
    
    BuildOrganizedCode = result
    
    Exit Function
    
ErrorHandler:
    If FunctionExists("LogMessage") Then
        Application.Run "LogMessage", "Genetic sequence assembly failure: " & Err.Number & " - " & Err.description, "ERROR"
    End If
    
    If FunctionExists("ErrorHandler.HandleError") Then
        Application.Run "ErrorHandler.HandleError", "modGeneSplicer", "BuildOrganizedCode", Err.Number, Err.description
    End If
    
    BuildOrganizedCode = codeText ' Return original in case of error - abort genetic restructuring
End Function

' Get module name with proper prefix - generate chromosomal region name
Private Function GetModuleNameWithPrefix(moduleKey As String) As String
    Dim prefix As String
    prefix = "mod"
    
    ' Adjust prefix for special module types - specialized chromosomal nomenclature
    If moduleKey = "UI" Then
        prefix = "modUI"
    ElseIf moduleKey = "FileSystem" Then
        prefix = "modFileSystem"
    ElseIf moduleKey = "Platform" Then
        prefix = "modPlatform"
    ElseIf moduleKey = "Utilities" Then
        prefix = "modUtils"
    ElseIf moduleKey = "Main" Then
        prefix = "modMain"
    Else
        prefix = "mod" & moduleKey
    End If
    
    GetModuleNameWithPrefix = prefix
End Function

' Get module-level declarations - generate chromosomal-level variables
Private Function GetModuleLevelDeclarations(moduleKey As String) As String
    Dim result As String
    result = ""
    
    ' Add appropriate declarations based on module type - chromosomal-specific genetic markers
    Select Case moduleKey
        Case "Main" ' Central nervous system variables
            result = "' Global configuration object - parasite genome container" & vbCrLf & _
                     "Public gConfig As Object" & vbCrLf & vbCrLf
            
        Case "Platform" ' Environmental adaptation variables
            result = "' Platform detection globals - host species identification markers" & vbCrLf & _
                     "Public gIsMac As Boolean          ' Is this a Mac host?" & vbCrLf & _
                     "Public gIsWin As Boolean          ' Is this a Windows victim?" & vbCrLf & _
                     "Public gPlatformName As String    ' Host species name (""Mac"" or ""Windows"")" & vbCrLf & _
                     "Public gPathSeparator As String   ' Cellular membrane structure (""/"" or ""\"")" & vbCrLf & _
                     "Public gLineBreak As String       ' Respiratory pattern (vbLf or vbCrLf)" & vbCrLf & vbCrLf
            
        Case "FileSystem" ' External tissue interface variables
            result = "' File system caching - external tissue mapping cache" & vbCrLf & _
                     "Private mFolderCache As Object ' Dictionary for tissue location cache" & vbCrLf & vbCrLf
            
        Case "UI" ' Sensory interface variables
            result = "' UI constants - visual neurotoxin parameters" & vbCrLf & _
                     "Private Const DEFAULT_TITLE As String = ""Cross-Platform Neural Interface""" & vbCrLf & vbCrLf
    End Select
    
    GetModuleLevelDeclarations = result
End Function

' Enhance procedure with error handling and comments - add cellular defense mechanisms
Private Function EnhanceProcedure(procBody As String, procName As String, procType As String) As String
    On Error GoTo ErrorHandler
    
    ' For Mac, limit the size of procedures to enhance
    If mIsMac And Len(procBody) > 2000 Then
        ' Skip enhancement for large procedures on Mac
        EnhanceProcedure = procBody
        Exit Function
    End If
    
    Dim result As String
    Dim HasErrorHandling As Boolean
    
    ' Check if procedure already has error handling - verify existing immune system
    HasErrorHandling = ContainsErrorHandling(procBody)
    
    ' If already has error handling, just return original - preserve existing immune system
    If HasErrorHandling Then
        result = procBody
    Else
        ' Add error handling if procedure is substantial - add immune response to complex cells
        If Len(procBody) > 200 Then
            result = AddErrorHandling(procBody, procName, procType)
        Else
            result = procBody
        End If
    End If
    
    EnhanceProcedure = result
    
    Exit Function
    
ErrorHandler:
    If FunctionExists("LogMessage") Then
        Application.Run "LogMessage", "Cellular enhancement failure: " & Err.Number & " - " & Err.description, "ERROR"
    End If
    
    If FunctionExists("ErrorHandler.HandleError") Then
        Application.Run "ErrorHandler.HandleError", "modGeneSplicer", "EnhanceProcedure", Err.Number, Err.description
    End If
    
    EnhanceProcedure = procBody ' Return original in case of error
End Function

' Enhanced version for Mac to process procedures in a code file
Private Function EnhanceProceduresMac(codeText As String) As String
    On Error GoTo ErrorHandler
    
    Dim result As String
    Dim lines As Variant
    Dim i As Long
    Dim inProc As Boolean
    Dim procStartLine As Long
    Dim currentProcType As String
    Dim currentProcName As String
    
    ' Split code into lines
    lines = Split(codeText, vbCrLf)
    
    ' Process each line to find procedures
    result = ""
    inProc = False
    
    For i = 0 To UBound(lines)
        ' Add periodic UI refresh
        If i Mod 100 = 0 Then
            DoEvents
            
            ' Check for timeout
            If Timer - mLastProcessTime > MAX_PROCESSING_TIME Then
                ' Just return what we've processed so far plus remaining original
                For j = i To UBound(lines)
                    result = result & lines(j) & vbCrLf
                Next j
                
                If FunctionExists("LogMessage") Then
                    Application.Run "LogMessage", "Procedure enhancement timeout after " & i & " lines", "WARNING"
                End If
                
                EnhanceProceduresMac = result
                Exit Function
            End If
        End If
        
        ' Check for procedure start
        If Not inProc And IsProcedureStart(lines(i)) Then
            inProc = True
            procStartLine = i
            
            ' Extract procedure type and name
            ExtractProcInfo lines(i), currentProcType, currentProcName
            
            ' Add line to result
            result = result & lines(i) & vbCrLf
            
        ' Check for procedure end
        ElseIf inProc And IsProcedureEnd(lines(i)) Then
            inProc = False
            
            ' Collect procedure lines
            Dim procBody As String
            procBody = JoinLines(lines, procStartLine, i)
            
            ' Check if procedure needs enhancement
            If Not ContainsErrorHandling(procBody) And Len(procBody) > 200 Then
                ' Enhance procedure
                Dim enhancedProc As String
                enhancedProc = AddErrorHandling(procBody, currentProcName, currentProcType)
                
                ' Extract lines after enhancement
                Dim enhancedLines As Variant
                enhancedLines = Split(enhancedProc, vbCrLf)
                
                ' Remove the original procedure lines we've already added
                Dim adjustedResult As String
                adjustedResult = Left(result, Len(result) - Len(lines(procStartLine) & vbCrLf))
                
                ' Add the enhanced procedure
                For j = 0 To UBound(enhancedLines)
                    adjustedResult = adjustedResult & enhancedLines(j) & vbCrLf
                Next j
                
                result = adjustedResult
            Else
                ' Just add the end line if no enhancement
                result = result & lines(i) & vbCrLf
            End If
            
        Else
            ' Just add the line
            result = result & lines(i) & vbCrLf
        End If
    Next i
    
    EnhanceProceduresMac = result
    
    Exit Function
    
ErrorHandler:
    If FunctionExists("LogMessage") Then
        Application.Run "LogMessage", "Mac procedure enhancement failure: " & Err.Number & " - " & Err.description, "ERROR"
    End If
    
    EnhanceProceduresMac = codeText ' Return original in case of error
End Function

' Check if procedure body contains error handling - detect immune system
Private Function ContainsErrorHandling(body As String) As Boolean
    Dim lowerBody As String
    lowerBody = LCase(body)
    
    ' Check for common error handling patterns - identify immune system markers
    ContainsErrorHandling = (InStr(1, lowerBody, "on error") > 0 Or _
                            InStr(1, lowerBody, "errorhandler") > 0 Or _
                            InStr(1, lowerBody, "err.") > 0)
End Function

' Add error handling to a procedure - implant immune system
Private Function AddErrorHandling(procBody As String, procName As String, procType As String) As String
    On Error GoTo ErrorHandler
    
    Dim result As String
    Dim lines As Variant
    Dim procedureLine As String
    Dim procedureEnd As String
    Dim bodyContent As String
    Dim i As Long
    
    ' Split into lines - dissect cellular structure
    lines = Split(procBody, vbCrLf)
    
    ' Find procedure start and end - locate cell boundaries
    procedureLine = lines(0)
    procedureEnd = "End " & procType
    
    ' Extract body content (everything between start and end) - isolate cell contents
    bodyContent = ""
    
    ' Process each line with timeout protection
    Dim processLimit As Long
    processLimit = UBound(lines) - 1
    
    ' For Mac, limit processing to avoid freezing
    If mIsMac And processLimit > 100 Then
        processLimit = 100
    End If
    
    For i = 1 To processLimit
        If Trim(lines(i)) <> procedureEnd Then
            bodyContent = bodyContent & lines(i) & vbCrLf
        End If
        
        ' Add periodic UI refresh for long procedures
        If i Mod 20 = 0 Then DoEvents
    Next i
    
    ' Check if it's a function that returns a value - identify output cells
    Dim returnsValue As Boolean
    returnsValue = (procType = "Function" Or procType = "PropertyGet")
    
    ' Build new procedure with error handling - rebuild cell with immune system
    result = procedureLine & vbCrLf & _
             "    On Error GoTo ErrorHandler" & vbCrLf & vbCrLf & _
             bodyContent
    
    ' Add appropriate exit statement - orderly cell termination
    If returnsValue Then
        result = result & "    Exit " & procType & vbCrLf & vbCrLf
    Else
        result = result & "    Exit " & procType & vbCrLf & vbCrLf
    End If
    
    ' Add error handler - add immune response system
    result = result & "ErrorHandler:" & vbCrLf
    
    ' Module-specific error handling - specialized immune responses
    If InStr(1, procName, "File") > 0 Or InStr(1, procName, "Directory") > 0 Then
        ' File-related error - external tissue interface failure
        result = result & "    LogMessage ""External tissue interface failure in " & procName & ": "" & Err.Number & "" - "" & Err.Description, ""ERROR""" & vbCrLf
    ElseIf InStr(1, LCase(procBody), "msgbox") > 0 Or InStr(1, LCase(procBody), "userform") > 0 Then
        ' UI-related error - sensory system failure
        result = result & "    MsgBox ""Sensory system failure in " & procName & ": "" & Err.Description, vbExclamation" & vbCrLf
    Else
        ' General error - standard immune response
        result = result & "    If FunctionExists(""ErrorHandler.HandleError"") Then" & vbCrLf
        result = result & "        Application.Run ""ErrorHandler.HandleError"", ""modGeneSplicer"", """ & procName & """, Err.Number, Err.Description" & vbCrLf
        result = result & "    End If" & vbCrLf
    End If
    
    ' Add appropriate return value for functions - cellular output on failure
    If returnsValue Then
        ' Try to guess the default return value type - default cellular output
        Dim defaultValue As String
        
        If InStr(1, LCase(procBody), "as boolean") > 0 Then
            defaultValue = "False"
        ElseIf InStr(1, LCase(procBody), "as string") > 0 Then
            defaultValue = """"
        ElseIf InStr(1, LCase(procBody), "as long") > 0 Or InStr(1, LCase(procBody), "as integer") > 0 Then
            defaultValue = "0"
        ElseIf InStr(1, LCase(procBody), "as double") > 0 Or InStr(1, LCase(procBody), "as single") > 0 Then
            defaultValue = "0"
        ElseIf InStr(1, LCase(procBody), "as date") > 0 Then
            defaultValue = "#1/1/1900#"
        ElseIf InStr(1, LCase(procBody), "as object") > 0 Or InStr(1, LCase(procBody), "as collection") > 0 Then
            defaultValue = "Nothing"
        Else
            defaultValue = "Null"
        End If
        
        result = result & "    " & procName & " = " & defaultValue & vbCrLf
    End If
    
    ' End the procedure - close cell membrane
    result = result & "End " & procType
    
    AddErrorHandling = result
    
    Exit Function
    
ErrorHandler:
    If FunctionExists("LogMessage") Then
        Application.Run "LogMessage", "Immune system implantation failure: " & Err.Number & " - " & Err.description, "ERROR"
    End If
    
    If FunctionExists("ErrorHandler.HandleError") Then
        Application.Run "ErrorHandler.HandleError", "modGeneSplicer", "AddErrorHandling", Err.Number, Err.description
    End If
    
    AddErrorHandling = procBody ' Return original in case of error - abort immune system implantation
End Function

' Fix common code issues - repair genetic defects
Private Function FixCommonIssues(codeText As String) As String
    On Error GoTo ErrorHandler
    
    Dim result As String
    result = codeText
    
    ' Reset timer for long operation
    mLastProcessTime = Timer
    
    ' 1. Ensure Option Explicit is present - ensure genetic validation markers
    If InStr(1, result, "Option Explicit", vbTextCompare) = 0 Then
        ' Add Option Explicit at the top of each module section - add genetic validation to each chromosome
        result = AddOptionExplicit(result)
    End If
    
    ' Allow UI to refresh
    DoEvents
    
    ' 2. Fix common formatting issues - repair structural genetic damage
    result = FixCommonFormattingIssues(result)
    
    ' Allow UI to refresh
    DoEvents
    
    ' 3. Fix platform-specific issues - repair host-specific genetic adaptations
    result = FixPlatformSpecificIssues(result)
    
    FixCommonIssues = result
    
    Exit Function
    
ErrorHandler:
    If FunctionExists("LogMessage") Then
        Application.Run "LogMessage", "Genetic repair failure: " & Err.Number & " - " & Err.description, "ERROR"
    End If
    
    If FunctionExists("ErrorHandler.HandleError") Then
        Application.Run "ErrorHandler.HandleError", "modGeneSplicer", "FixCommonIssues", Err.Number, Err.description
    End If
    
    FixCommonIssues = codeText ' Return original in case of error - abort genetic repair
End Function

' Mac-optimized Option Explicit adder
Private Function AddOptionExplicitMac(codeText As String) As String
    On Error GoTo ErrorHandler
    
    Dim result As String
    result = codeText
    
    ' For very small files, just prepend Option Explicit
    If Len(result) < 1000 Then
        If InStr(1, result, "Option Explicit", vbTextCompare) = 0 Then
            result = "Option Explicit" & vbCrLf & vbCrLf & result
        End If
        AddOptionExplicitMac = result
        Exit Function
    End If
    
    ' Try to find each module header pattern
    Dim headerPattern As String
    headerPattern = "' ========="
    
    ' Find first instance
    Dim headerPos As Long
    headerPos = InStr(1, result, headerPattern)
    
    ' If no headers found, just add at the beginning
    If headerPos = 0 Then
        If InStr(1, result, "Option Explicit", vbTextCompare) = 0 Then
            result = "Option Explicit" & vbCrLf & vbCrLf & result
        End If
        AddOptionExplicitMac = result
        Exit Function
    End If
    
    ' Process in small chunks
    Dim chunkStart As Long
    chunkStart = 1
    
    Do While headerPos > 0
        ' Find the end of header section
        Dim NextLine As Long
        NextLine = InStr(headerPos, result, vbCrLf)
        
        If NextLine = 0 Then Exit Do
        
        ' Find next non-comment line
        Dim endOfHeader As Long
        endOfHeader = NextLine
        
        ' Look for up to 10 lines to find end of header
        Dim lineCount As Long
        lineCount = 0
        
        Do
            endOfHeader = InStr(endOfHeader + 2, result, vbCrLf)
            If endOfHeader = 0 Then Exit Do
            
            lineCount = lineCount + 1
            If lineCount > 10 Then Exit Do
            
            ' Check if the next char after CRLF is not a comment
            If Mid(result, endOfHeader + 2, 1) <> "'" Then
                Exit Do
            End If
        Loop
        
        If endOfHeader = 0 Then Exit Do
        
        ' Check if "Option Explicit" is already present
        Dim checkText As String
        checkText = Mid(result, NextLine + 2, endOfHeader - NextLine - 2)
        
        ' If no Option Explicit, add it
        If InStr(1, checkText, "Option Explicit", vbTextCompare) = 0 Then
            ' Insert after header
            result = Left(result, endOfHeader + 1) & "Option Explicit" & vbCrLf & vbCrLf & _
                     Mid(result, endOfHeader + 2)
        End If
        
        ' Find next header
        headerPos = InStr(endOfHeader + 2, result, headerPattern)
        
        ' Refresh UI occasionally
        If Timer - mLastProcessTime > MAX_PROCESSING_TIME / 2 Then
            DoEvents
            mLastProcessTime = Timer
        End If
    Loop
    
    AddOptionExplicitMac = result
    
    Exit Function
    
ErrorHandler:
    If FunctionExists("LogMessage") Then
        Application.Run "LogMessage", "Error adding Option Explicit: " & Err.Number & " - " & Err.description, "ERROR"
    End If
    
    AddOptionExplicitMac = codeText ' Return original in case of error
End Function

' Add Option Explicit where missing - add genetic validation where absent
Private Function AddOptionExplicit(codeText As String) As String
    On Error GoTo ErrorHandler
    
    ' For Mac, use optimized version
    If mIsMac Then
        AddOptionExplicit = AddOptionExplicitMac(codeText)
        Exit Function
    End If
    
    Dim result As String
    Dim moduleStart As Long
    Dim moduleStartPattern As String
    Dim nextModuleStart As Long
    
    result = codeText
    moduleStartPattern = "' ========="
    
    ' Find each module start - locate each chromosomal boundary
    moduleStart = InStr(1, result, moduleStartPattern)
    
    Do While moduleStart > 0
        ' Reset timer for long operation
        If Timer - mLastProcessTime > MAX_PROCESSING_TIME / 2 Then
            DoEvents
            mLastProcessTime = Timer
        End If
        
        ' Find the end of the module header - locate end of chromosomal marker
        Dim headerEnd As Long
        headerEnd = InStr(moduleStart + 1, result, moduleStartPattern)
        
        If headerEnd = 0 Then
            ' No more module headers, look for next non-comment line - find end of genetic marker
            headerEnd = moduleStart
            Do
                headerEnd = InStr(headerEnd + 1, result, vbCrLf)
                If headerEnd = 0 Then Exit Do
                
                ' Check if the next line is not a comment - find first genetic code line
                If Mid(result, headerEnd + 2, 1) <> "'" Then
                    Exit Do
                End If
            Loop While headerEnd > 0
        End If
        
        If headerEnd > 0 Then
            ' Find where to insert Option Explicit - locate genetic validation insertion point
            Dim insertPos As Long
            insertPos = InStr(headerEnd, result, vbCrLf) + 2
            
            ' Check if Option Explicit is already there - check for existing genetic validation
            Dim nextLines As String
            nextLines = Mid(result, insertPos, 50)
            
            If InStr(1, nextLines, "Option Explicit", vbTextCompare) = 0 Then
                ' Insert Option Explicit - add genetic validation marker
                result = Left(result, insertPos - 1) & "Option Explicit" & vbCrLf & vbCrLf & _
                         Mid(result, insertPos)
            End If
        End If
        
        ' Find next module - locate next chromosome
        moduleStart = InStr(moduleStart + 1, result, moduleStartPattern)
    Loop
    
    AddOptionExplicit = result
    
    Exit Function
    
ErrorHandler:
    If FunctionExists("LogMessage") Then
        Application.Run "LogMessage", "Error adding Option Explicit: " & Err.Number & " - " & Err.description, "ERROR"
    End If
    
    If FunctionExists("ErrorHandler.HandleError") Then
        Application.Run "ErrorHandler.HandleError", "modGeneSplicer", "AddOptionExplicit", Err.Number, Err.description
    End If
    
    AddOptionExplicit = codeText ' Return original in case of error
End Function

' Fix common formatting issues - repair structural genetic damage
Private Function FixCommonFormattingIssues(codeText As String) As String
    On Error GoTo ErrorHandler
    
    Dim result As String
    result = codeText
    
    ' Reset timer for long operation
    mLastProcessTime = Timer
    
    ' 1. Fix mixed line endings - standardize genetic separators
    result = Replace(result, vbCr, "")
    result = Replace(result, vbLf, vbCrLf)
    
    ' Allow UI to refresh
    DoEvents
    mLastProcessTime = Timer
    
    ' 2. Remove duplicate blank lines - remove redundant genetic spacing
    Do While InStr(1, result, vbCrLf & vbCrLf & vbCrLf) > 0
        result = Replace(result, vbCrLf & vbCrLf & vbCrLf, vbCrLf & vbCrLf)
        
        ' Check if we need to refresh the UI
        If Timer - mLastProcessTime > MAX_PROCESSING_TIME / 2 Then
            DoEvents
            mLastProcessTime = Timer
        End If
    Loop
    
    ' On Mac, skip the procedure spacing for large files
    If mIsMac And Len(result) > 50000 Then
        FixCommonFormattingIssues = result
        Exit Function
    End If
    
    ' 3. Standardize procedure spacing - optimize cellular spacing
    Dim lines As Variant
    Dim fixedLines() As String
    Dim i As Long
    Dim j As Long
    Dim inProc As Boolean
    Dim procEndFound As Boolean
    
    lines = Split(result, vbCrLf)
    ReDim fixedLines(UBound(lines))
    
    inProc = False
    
    ' Process each line with timeout protection
    Dim lineLimit As Long
    lineLimit = UBound(lines)
    
    ' For Mac, limit processing to avoid freezing
    If mIsMac And lineLimit > 1000 Then
        lineLimit = 1000
    End If
    
    For i = 0 To lineLimit
        ' Check for timeout
        If i Mod 100 = 0 Then
            If Timer - mLastProcessTime > MAX_PROCESSING_TIME Then
                ' Copy the rest of the lines as-is
                For j = i To UBound(lines)
                    fixedLines(j) = lines(j)
                Next j
                
                If FunctionExists("LogMessage") Then
                    Application.Run "LogMessage", "Formatting timeout - processed " & i & " of " & UBound(lines) & " lines", "WARNING"
                End If
                
                Exit For
            End If
            
            ' Refresh UI periodically
            DoEvents
        End If
        
        fixedLines(i) = lines(i)
        
        ' Detect procedure start/end - detect cell boundaries
        If Not inProc Then
            If IsProcedureStart(lines(i)) Then
                inProc = True
                procEndFound = False
            End If
        Else
            If IsProcedureEnd(lines(i)) Then
                inProc = False
                procEndFound = True
                
                ' Ensure blank line after procedure - ensure proper intercellular spacing
                If i < UBound(lines) And Trim(lines(i + 1)) <> "" Then
                    fixedLines(i) = lines(i) & vbCrLf
                End If
            End If
        End If
    Next i
    
    ' Reconstruct text - reassemble genetic code
    result = Join(fixedLines, vbCrLf)
    
    FixCommonFormattingIssues = result
    
    Exit Function
    
ErrorHandler:
    If FunctionExists("LogMessage") Then
        Application.Run "LogMessage", "Formatting repair failure: " & Err.Number & " - " & Err.description, "ERROR"
    End If
    
    If FunctionExists("ErrorHandler.HandleError") Then
        Application.Run "ErrorHandler.HandleError", "modGeneSplicer", "FixCommonFormattingIssues", Err.Number, Err.description
    End If
    
    FixCommonFormattingIssues = codeText ' Return original in case of error
End Function

' Check if a line starts a procedure - detect cellular boundary start
Private Function IsProcedureStart(line As Variant) As Boolean
    ' Skip empty or comment lines - skip non-code lines
    If Trim(line) = "" Or Left(Trim(line), 1) = "'" Then
        IsProcedureStart = False
        Exit Function
    End If
    
    ' Check for different procedure types - identify cellular type markers
    Dim lowerLine As String
    lowerLine = LCase(Trim(line))
    
    IsProcedureStart = (Left(lowerLine, 4) = "sub " Or _
                       Left(lowerLine, 9) = "function " Or _
                       Left(lowerLine, 13) = "property get " Or _
                       Left(lowerLine, 13) = "property let " Or _
                       Left(lowerLine, 13) = "property set ")
End Function

' Check if a line ends a procedure - detect cellular boundary end
Private Function IsProcedureEnd(line As Variant) As Boolean
    ' Skip empty or comment lines - skip non-code lines
    If Trim(line) = "" Or Left(Trim(line), 1) = "'" Then
        IsProcedureEnd = False
        Exit Function
    End If
    
    ' Simple check for "End Sub", "End Function", etc. - identify cellular termination markers
    Dim lowerLine As String
    lowerLine = LCase(Trim(line))
    
    IsProcedureEnd = (lowerLine = "end sub" Or _
                     lowerLine = "end function" Or _
                     lowerLine = "end property")
End Function

' Fix platform-specific issues - repair host-specific genetic adaptations
Private Function FixPlatformSpecificIssues(codeText As String) As String
    On Error GoTo ErrorHandler
    
    Dim result As String
    result = codeText
    
    ' 1. Ensure platform check constants are consistent - ensure host detection markers
    If InStr(1, result, "gIsMac") > 0 And InStr(1, result, "#If Mac") = 0 Then
        ' Add compiler directive constants - add host-specific genetic markers
        Dim platformConstants As String
        platformConstants = "#If Mac Then" & vbCrLf & _
                           "    Public Const PLATFORM_MAC As Boolean = True" & vbCrLf & _
                           "    Public Const PLATFORM_WIN As Boolean = False" & vbCrLf & _
                           "    Public Const PLATFORM_NAME As String = ""Mac""" & vbCrLf & _
                           "#Else" & vbCrLf & _
                           "    Public Const PLATFORM_MAC As Boolean = False" & vbCrLf & _
                           "    Public Const PLATFORM_WIN As Boolean = True" & vbCrLf & _
                           "    Public Const PLATFORM_NAME As String = ""Windows""" & vbCrLf & _
                           "#End If" & vbCrLf & vbCrLf
        
        ' Find Platform module - locate platform-specific chromosome
        Dim platformModuleStart As Long
        platformModuleStart = InStr(1, result, "modPlatform")
        
        If platformModuleStart > 0 Then
            ' Find where to insert constants - locate insertion point
            Dim insertPos As Long
            insertPos = InStr(platformModuleStart, result, "Option Explicit")
            
            If insertPos > 0 Then
                insertPos = InStr(insertPos, result, vbCrLf) + 2
                
                ' Insert constants - add genetic markers
                result = Left(result, insertPos - 1) & platformConstants & Mid(result, insertPos)
            End If
        End If
    End If
    
    ' 2. Add Mac-specific optimizations if this is a Mac system
    If mIsMac Then
        ' If code doesn't have Mac-specific optimizations, add some basic ones
        If InStr(1, result, "DoEvents") = 0 And InStr(1, result, "mIsMac") = 0 Then
            ' Find appropriate location in Platform module if it exists
            Dim platformPos As Long
            platformPos = InStr(1, result, "modPlatform")
            
            If platformPos > 0 Then
                ' Find a good place to insert Mac optimization code
                Dim initializePos As Long
                initializePos = InStr(platformPos, result, "InitializePlatform")
                
                If initializePos > 0 Then
                    ' Find the end of the initialization function
                    Dim endInitPos As Long
                    endInitPos = InStr(initializePos, result, "End Sub")
                    
                    If endInitPos > 0 Then
                        ' Find the line before End Sub to insert Mac optimization
                        Dim insertLinePos As Long
                        insertLinePos = InStrRev(result, vbCrLf, endInitPos)
                        
                        If insertLinePos > 0 Then
                            ' Add Mac-specific performance optimizations
                            Dim macOptCode As String
                            macOptCode = vbCrLf & _
                                        "    #If Mac Then" & vbCrLf & _
                                        "    ' Add Mac-specific optimizations" & vbCrLf & _
                                        "    DoEvents ' Keep UI responsive on initialization" & vbCrLf & _
                                        "    #End If" & vbCrLf
                            
                            result = Left(result, insertLinePos) & macOptCode & Mid(result, insertLinePos + 1)
                        End If
                    End If
                End If
            End If
        End If
    End If
    
    FixPlatformSpecificIssues = result
    
    Exit Function
    
ErrorHandler:
    If FunctionExists("LogMessage") Then
        Application.Run "LogMessage", "Platform adaptation failure: " & Err.Number & " - " & Err.description, "ERROR"
    End If
    
    If FunctionExists("ErrorHandler.HandleError") Then
        Application.Run "ErrorHandler.HandleError", "modGeneSplicer", "FixPlatformSpecificIssues", Err.Number, Err.description
    End If
    
    FixPlatformSpecificIssues = codeText ' Return original in case of error
End Function

' Resolve duplicates in code - eliminate redundant genetic sequences
Public Sub ResolveDuplicates(duplicates As collection, resolutionMethod As String)
    On Error GoTo ErrorHandler
    
    ' Skip if no duplicates
    If duplicates Is Nothing Or duplicates.count = 0 Then
        Exit Sub
    End If
    
    ' Set processing flag and reset timer
    mIsProcessing = True
    mLastProcessTime = Timer
    
    Dim i As Long
    Dim dupInfo As Object
    
    For i = 1 To duplicates.count
        ' Add periodic UI refresh
        If i Mod 3 = 0 Then
            DoEvents
            
            ' Check for timeout
            If Timer - mLastProcessTime > MAX_PROCESSING_TIME Then
                If FunctionExists("LogMessage") Then
                    Application.Run "LogMessage", "Genetic deduplication timeout after processing " & i & " of " & duplicates.count & " duplicate sequences", "WARNING"
                End If
                Exit For
            End If
        End If
        
        Set dupInfo = duplicates(i)
        
        ' Apply resolution method - apply selected genetic deduplication strategy
        Select Case resolutionMethod
            Case "KeepFirst" ' Keep original genetic sequence
                ResolveByKeepingFirst dupInfo
                
            Case "KeepLast" ' Keep most recent genetic mutation
                ResolveByKeepingLast dupInfo
                
            Case "Rename" ' Preserve both with unique identifiers
                ResolveByRenaming dupInfo
        End Select
    Next i
    
    ' Reset processing flag
    mIsProcessing = False
    
    Exit Sub
    
ErrorHandler:
    ' Reset processing flag
    mIsProcessing = False
    
    If FunctionExists("LogMessage") Then
        Application.Run "LogMessage", "Genetic deduplication failure: " & Err.Number & " - " & Err.description, "ERROR"
    End If
    
    If FunctionExists("ErrorHandler.HandleError") Then
        Application.Run "ErrorHandler.HandleError", "modGeneSplicer", "ResolveDuplicates", Err.Number, Err.description
    End If
End Sub

' Keep only the first occurrence of a duplicate - preserve original genetic sequence
Private Sub ResolveByKeepingFirst(dupInfo As Object)
    On Error GoTo ErrorHandler
    
    Dim occurrences As collection
    Dim i As Long
    
    On Error Resume Next
    If TypeOf dupInfo Is Dictionary Then
        Set occurrences = dupInfo("Occurrences")
    Else
        Exit Sub ' Not a valid Dictionary
    End If
    On Error GoTo ErrorHandler
    
    ' Make sure occurrences is not Nothing
    If occurrences Is Nothing Then Exit Sub
    
    ' Keep only the first occurrence - eliminate clone tissues
    For i = occurrences.count To 2 Step -1
        ' Remove the duplicate (logic would be in document editing) - remove genetic clones
        If FunctionExists("LogMessage") Then
            Application.Run "LogMessage", "Eliminating cloned genetic sequence of " & dupInfo("Name") & " (specimen " & i & ")"
        End If
    Next i
    
    Exit Sub
    
ErrorHandler:
    If FunctionExists("LogMessage") Then
        Application.Run "LogMessage", "Error resolving duplicates: " & Err.Number & " - " & Err.description, "ERROR"
    End If
End Sub

' Keep only the last occurrence of a duplicate - preserve most recent genetic mutation
Private Sub ResolveByKeepingLast(dupInfo As Object)
    On Error GoTo ErrorHandler
    
    Dim occurrences As collection
    Dim i As Long
    
    On Error Resume Next
    If TypeOf dupInfo Is Dictionary Then
        Set occurrences = dupInfo("Occurrences")
    Else
        Exit Sub ' Not a valid Dictionary
    End If
    On Error GoTo ErrorHandler
    
    ' Make sure occurrences is not Nothing
    If occurrences Is Nothing Then Exit Sub
    
    ' Keep only the last occurrence - preserve most evolved specimen
    For i = occurrences.count - 1 To 1 Step -1
        ' Remove the duplicate (logic would be in document editing) - remove primitive forms
        If FunctionExists("LogMessage") Then
            Application.Run "LogMessage", "Eliminating primitive genetic sequence of " & dupInfo("Name") & " (specimen " & i & ")"
        End If
    Next i
    
    Exit Sub
    
ErrorHandler:
    If FunctionExists("LogMessage") Then
        Application.Run "LogMessage", "Error resolving duplicates: " & Err.Number & " - " & Err.description, "ERROR"
    End If
End Sub

' Rename duplicates to make them unique - differentiate genetic variations
Private Sub ResolveByRenaming(dupInfo As Object)
    On Error GoTo ErrorHandler
    
    Dim occurrences As collection
    Dim i As Long
    Dim proc As Object
    
    On Error Resume Next
    If TypeOf dupInfo Is Dictionary Then
        Set occurrences = dupInfo("Occurrences")
    Else
        Exit Sub ' Not a valid Dictionary
    End If
    On Error GoTo ErrorHandler
    
    ' Make sure occurrences is not Nothing
    If occurrences Is Nothing Then Exit Sub
    
    ' Rename all occurrences except the first - catalog genetic variations
    For i = 2 To occurrences.count
        Set proc = occurrences(i)
        
        ' Create new name - create unique genetic marker
        Dim newName As String
        
        On Error Resume Next
        If TypeOf proc Is Dictionary Then
            ' Use module name in new name - incorporate chromosomal origin in name
            If proc("Module") <> "" Then
                newName = dupInfo("Name") & "From" & proc("Module")
            Else
                newName = dupInfo("Name") & i
            End If
        Else
            newName = dupInfo("Name") & i
        End If
        On Error GoTo ErrorHandler
        
        ' Log the rename operation - document genetic differentiation
        If FunctionExists("LogMessage") Then
            Application.Run "LogMessage", "Cataloging genetic variant of " & dupInfo("Name") & " as " & newName & " (specimen " & i & ")"
        End If
    Next i
    
    Exit Sub
    
ErrorHandler:
    If FunctionExists("LogMessage") Then
        Application.Run "LogMessage", "Error renaming duplicates: " & Err.Number & " - " & Err.description, "ERROR"
    End If
End Sub

'=============================================================================
' END MODULE: modGeneSplicer
'=============================================================================

‘********************************************************* 
‘‘***************** ‘coVdEeNcOoMde ‘******************     
‘********************************************************* 

'=============================================================================
' BEGIN MODULE: modCodeAnalysis
'============================================================================='

' ****************************************************************
' * CODE ANALYSIS - Neural Tissue Examination Laboratory           *
' * Version: 2.0                                                  *
' * Dissects code specimens for optimal VENOM integration         *
' * Updated by: Aaron McCutchins on 2025-05-13                    *
' ****************************************************************
Option Explicit

' Module state
Private mIsInitialized As Boolean
Private mCachedAnalysis As Object  ' Dictionary or Collection
Private mCachedAnalysisCount As Long
Private mInProgress As Boolean
Private mPlatformIsMac As Boolean
Private mTimeoutSeconds As Long
Private mLastOperationTime As Date


' In modCodeAnalysis
Public Function CA_Initialize() As Boolean
    If mIsInitialized Then Exit Function
    
    ' First ensure FileSystem is initialized
    If Not modFileSystem.FS_Initialize() Then
        modFileSystem.FS_Initialize
    End If
    
    ' Now initialize this module
    mInProgress = True
    Set mCachedAnalysis = CA_CreateDictionaryObject()
    mCachedAnalysisCount = 0
    mTimeoutSeconds = 30
    mIsInitialized = True
    mInProgress = False
    
    ' Use new function name format
    modFileSystem.FS_LogMessage "Code Analysis laboratory sterilized and ready for dissection", "INFO"
    
    CA_Initialize = True
End Function

#If Mac Then
    ' Mac-specific dictionary implementation
    Private Function CA_CreateDictionaryObject() As Object
        On Error Resume Next
        Set CA_CreateDictionaryObject = CreateObject("Scripting.Dictionary")
        On Error GoTo 0
    End Function
#Else
    ' Windows dictionary implementation
    Private Function CA_CreateDictionaryObject() As Object
        On Error Resume Next
        Set CA_CreateDictionaryObject = CreateObject("Scripting.Dictionary")
        On Error GoTo 0
    End Function
#End If

' Create a fallback dictionary using collections
Private Function CA_CreateFallbackDictionary() As Object
    On Error Resume Next
    
    ' This uses the Dictionary class that should be defined in a reference
    ' If using this approach, we need to ensure Dictionary class is available
    Set CA_CreateFallbackDictionary = CreateObject("Scripting.Dictionary")
    
    If Err.Number <> 0 Then
        ' Last resort - use Application.ExecuteExcel4Macro to create a temporary worksheet
        ' to use as a simple key-value store (implementation would be elsewhere)
        Err.Clear
        LogMessage "WARNING: Could not create Dictionary on this platform. Using limited functionality.", "ERROR"
        Set CA_CreateFallbackDictionary = New collection
    End If
    
    On Error GoTo 0
End Function

' Analyze code structure - perform a comprehensive vivisection
Public Function CA_AnalyzeCodeStructure(codeText As String) As Object
    ' Ensure we're initialized
    If Not mIsInitialized Then CA_Initialize
    
    On Error GoTo ErrorHandler
    
    ' Start processing timer
    mInProgress = True
    mLastOperationTime = CA_GetTickCount()
    
    ' Check if we already analyzed this code - avoid re-cutting the corpse
    Dim codeHash As String
    codeHash = CA_GenerateSimpleHash(codeText)
    
    #If Mac Then
        ' For Mac, check if dictionary exists function works differently
        Dim keyExists As Boolean
        keyExists = CA_DictionaryKeyExists(mCachedAnalysis, codeHash)
        
        If keyExists Then
            ' Return cached analysis
            Set CA_AnalyzeCodeStructure = CA_DictionaryGetItem(mCachedAnalysis, codeHash)
            mInProgress = False
            Exit Function
        End If
    #Else
        If CA_DictionaryExists(mCachedAnalysis, codeHash) Then
            ' Return cached analysis
            Set CA_AnalyzeCodeStructure = mCachedAnalysis(codeHash)
            mInProgress = False
            Exit Function
        End If
    #End If
    
    ' Create results dictionary
    Dim results As Object
    Set results = CA_CreateDictionaryObject()
    
    ' Analyze code by lines
    Dim lines As Variant
    lines = Split(codeText, vbCrLf)
    
    ' Initial counters
    Dim lineCount As Long
    Dim commentCount As Long
    Dim blankLineCount As Long
    Dim procedureCount As Long
    Dim variableCount As Long
    Dim maxIndentLevel As Long
    Dim currentIndentLevel As Long
    
    lineCount = UBound(lines) - LBound(lines) + 1
    commentCount = 0
    blankLineCount = 0
    procedureCount = 0
    variableCount = 0
    maxIndentLevel = 0
    currentIndentLevel = 0
    
    ' Track procedures
    Dim procedures As Object
    Set procedures = CA_CreateDictionaryObject()
    
    ' Track variables
    Dim variables As Object
    Set variables = CA_CreateDictionaryObject()
    
    ' Track current procedure
    Dim inProcedure As Boolean
    Dim currentProcedure As String
    inProcedure = False
    currentProcedure = ""
    
    ' Analyze each line
    Dim i As Long
    For i = LBound(lines) To UBound(lines)
        ' Check for timeout
        If DateDiff("s", mLastOperationTime, Now()) > mTimeoutSeconds Then
            CA_DictionaryAdd results, "Error", "Analysis timed out after processing " & i & " of " & lineCount & " lines"
            CA_DictionaryAdd results, "Completion", (i / lineCount) * 100
            Set CA_AnalyzeCodeStructure = results
            mInProgress = False
            Exit Function
        End If
        
        Dim line As String
        line = Trim(lines(i))
        
        ' Skip blank lines
        If line = "" Then
            blankLineCount = blankLineCount + 1
            GoTo NextLine
        End If
        
        ' Check for comments
        If Left(line, 1) = "'" Then
            commentCount = commentCount + 1
            GoTo NextLine
        End If
        
        ' Check indentation level
        currentIndentLevel = CA_CalculateIndentLevel(Trim(lines(i)))
        If currentIndentLevel > maxIndentLevel Then
            maxIndentLevel = currentIndentLevel
        End If
        
        ' Check for procedure start
        If CA_IsStartOfProcedure(line) Then
            inProcedure = True
            currentProcedure = CA_ExtractProcedureName(line)
            procedureCount = procedureCount + 1
            
            ' Add procedure to the list
            CA_DictionaryAdd procedures, currentProcedure, i
        End If
        
        ' Check for procedure end
        If CA_IsEndOfProcedure(line) Then
            inProcedure = False
            currentProcedure = ""
        End If
        
        ' Check for variable declarations
        If CA_IsVariableDeclaration(line) Then
            Dim varNames As Variant
            varNames = CA_ExtractVariableNames(line)
            
            Dim j As Long
            For j = LBound(varNames) To UBound(varNames)
                If varNames(j) <> "" Then
                    variableCount = variableCount + 1
                    CA_DictionaryAdd variables, ((varNames(j))), CA_ExtractVariableNames(line)
                End If
            Next j
        End If
        
NextLine:
        DoEvents ' Keep application responsive
    Next i
    
    ' Calculate statistics
    Dim codeLineCount As Long
    codeLineCount = lineCount - blankLineCount - commentCount
    
    Dim commentRatio As Double
    If lineCount > 0 Then
        commentRatio = commentCount / lineCount
    Else
        commentRatio = 0
    End If
    
    ' Build results
    CA_DictionaryAdd results, "LineCount", lineCount
    CA_DictionaryAdd results, "CommentCount", commentCount
    CA_DictionaryAdd results, "BlankLineCount", blankLineCount
    CA_DictionaryAdd results, "CodeLineCount", codeLineCount
    CA_DictionaryAdd results, "ProcedureCount", procedureCount
    CA_DictionaryAdd results, "VariableCount", variableCount
    CA_DictionaryAdd results, "CommentRatio", commentRatio
    CA_DictionaryAdd results, "MaxIndentLevel", maxIndentLevel
    CA_DictionaryAdd results, "Procedures", procedures
    CA_DictionaryAdd results, "Variables", variables
    CA_DictionaryAdd results, "Hash", codeHash
    
    ' Cache the results
    #If Mac Then
        CA_DictionaryAdd mCachedAnalysis, codeHash, results
    #Else
        mCachedAnalysis(codeHash) = results
    #End If
    
    ' Keep cache size reasonable
    mCachedAnalysisCount = mCachedAnalysisCount + 1
    If mCachedAnalysisCount > 50 Then ' Maximum cache size
        ' To implement: trim cache (not critical for functionality)
    End If
    
    ' Return the results
    Set CA_AnalyzeCodeStructure = results
    mInProgress = False
    Exit Function
    
ErrorHandler:
    ' Return error information
    If results Is Nothing Then Set results = CA_CreateDictionaryObject()
    CA_DictionaryAdd results, "Error", "Analysis failed: " & Err.description
    Set CA_AnalyzeCodeStructure = results
    mInProgress = False
    Resume Next
End Function

' Generate a simple hash for code text
Private Function CA_GenerateSimpleHash(text As String) As String
    On Error Resume Next
    
    ' Simple hash algorithm
    Dim hash As Long
    hash = 0
    
    Dim i As Long
    For i = 1 To Len(text)
        hash = (hash * 31 + Asc(Mid(text, i, 1))) Mod 1000000
    Next i
    
    CA_GenerateSimpleHash = "H" & hash
    
    If Err.Number <> 0 Then
        Error.message , "Hash generation error: " & Err.description, "ERROR"
        Err.Clear
        CA_GenerateSimpleHash = "H" & Timer ' Fallback hash
    End If
    
    On Error GoTo 0
End Function

' Get system tick count for timing operations
Private Function CA_GetTickCount() As Double
    On Error Resume Next
    
    #If Mac Then
        ' Mac doesn't have a direct GetTickCount equivalent
        CA_GetTickCount = Timer ' Timer returns seconds since midnight
    #Else
        ' Windows has GetTickCount API
        CA_GetTickCount = Timer ' Using Timer for simplicity across platforms
    #End If
    
    If Err.Number <> 0 Then
        Error.message , "Error getting tick count: " & Err.description, "ERROR"
        Err.Clear
        CA_GetTickCount = 0
    End If
    
    On Error GoTo 0
End Function

' Calculate indentation level of a line
Private Function CA_CalculateIndentLevel(line As String) As Long
    On Error Resume Next
    
    Dim indentLevel As Long
    indentLevel = 0
    
    Dim i As Long
    For i = 1 To Len(line)
        Select Case Mid(line, i, 1)
            Case " "
                indentLevel = indentLevel + 1
            Case vbTab
                indentLevel = indentLevel + 4 ' Count tab as 4 spaces
            Case Else
                Exit For
        End Select
    Next i
    
    CA_CalculateIndentLevel = indentLevel \ 4 ' Divide by 4 to get logical indentation level
    
    If Err.Number <> 0 Then
        LogMessage "Error calculating indent level: " & Err.description, "ERROR"
        Err.Clear
        CA_CalculateIndentLevel = 0
    End If
    
    On Error GoTo 0
End Function

' Check if a line starts a procedure
Private Function CA_IsStartOfProcedure(line As String) As Boolean
    On Error Resume Next
    
    ' Look for Sub or Function declarations
    line = Trim(line)
    
    CA_IsStartOfProcedure = (Left(line, 4) = "Sub " Or _
                          Left(line, 9) = "Function " Or _
                          Left(line, 8) = "Property " Or _
                          Left(line, 11) = "Public Sub " Or _
                          Left(line, 16) = "Public Function " Or _
                          Left(line, 15) = "Public Property " Or _
                          Left(line, 12) = "Private Sub " Or _
                          Left(line, 17) = "Private Function " Or _
                          Left(line, 16) = "Private Property ")
    
    If Err.Number <> 0 Then
        LogMessage "Error checking procedure start: " & Err.description, "ERROR"
        Err.Clear
        CA_IsStartOfProcedure = False
    End If
    
    On Error GoTo 0
End Function

' Check if a line ends a procedure
Private Function CA_IsEndOfProcedure(line As String) As Boolean
    On Error Resume Next
    
    ' Look for End Sub or End Function statements
    line = Trim(line)
    
    CA_IsEndOfProcedure = (line = "End Sub" Or _
                        line = "End Function" Or _
                        line = "End Property")
    
    If Err.Number <> 0 Then
        LogMessage "Error checking procedure end: " & Err.description, "ERROR"
        Err.Clear
        CA_IsEndOfProcedure = False
    End If
    
    On Error GoTo 0
End Function

' Extract procedure name from a declaration
Private Function CA_ExtractProcedureName(line As String) As String
    On Error Resume Next
    
    Dim procName As String
    procName = ""
    
    ' Remove keywords
    line = Trim(line)
    line = Replace(line, "Public ", "")
    line = Replace(line, "Private ", "")
    line = Replace(line, "Friend ", "")
    line = Replace(line, "Static ", "")
    
    ' Extract based on declaration type
    If Left(line, 4) = "Sub " Then
        ' Get name from Sub declaration
        procName = Mid(line, 5)
        
        ' Remove parameters
        Dim parenPos As Long
        parenPos = InStr(procName, "(")
        If parenPos > 0 Then
            procName = Left(procName, parenPos - 1)
        End If
        
    ElseIf Left(line, 9) = "Function " Then
        ' Get name from Function declaration
        procName = Mid(line, 10)
        
        ' Remove parameters
        parenPos = InStr(procName, "(")
        If parenPos > 0 Then
            procName = Left(procName, parenPos - 1)
        End If
        
    ElseIf Left(line, 9) = "Property " Then
        ' Get name from Property declaration
        procName = Mid(line, 10)
        
        ' Skip property type (Get, Let, Set)
        Dim spacePos As Long
        spacePos = InStr(procName, " ")
        If spacePos > 0 Then
            procName = Mid(procName, spacePos + 1)
            
            ' Remove parameters
            parenPos = InStr(procName, "(")
            If parenPos > 0 Then
                procName = Left(procName, parenPos - 1)
            End If
        End If
    End If
    
    CA_ExtractProcedureName = Trim(procName)
    
    If Err.Number <> 0 Then
        LogMessage "Error extracting procedure name: " & Err.description, "ERROR"
        Err.Clear
        CA_ExtractProcedureName = "UnknownProcedure"
    End If
    
    On Error GoTo 0
End Function

' Check if a line is a variable declaration
Private Function CA_IsVariableDeclaration(line As String) As Boolean
    On Error Resume Next
    
    ' Look for variable declarations
    line = Trim(line)
    
    CA_IsVariableDeclaration = (Left(line, 4) = "Dim " Or _
                             Left(line, 4) = "ReDim " Or _
                             Left(line, 5) = "Const " Or _
                             Left(line, 7) = "Static " Or _
                             Left(line, 7) = "Public " Or _
                             Left(line, 8) = "Private " Or _
                             Left(line, 7) = "Friend ")
    
    If Err.Number <> 0 Then
        LogMessage "Error checking variable declaration: " & Err.description, "ERROR"
        Err.Clear
        CA_IsVariableDeclaration = False
    End If
    
    On Error GoTo 0
End Function

' Extract variable names from a declaration
Private Function CA_ExtractVariableNames(line As String) As Variant
    On Error Resume Next
    
    ' Remove declaration keyword
    line = Trim(line)
    line = Replace(line, "Dim ", "")
    line = Replace(line, "ReDim ", "")
    line = Replace(line, "Static ", "")
    line = Replace(line, "Public ", "")
    line = Replace(line, "Private ", "")
    line = Replace(line, "Friend ", "")
    line = Replace(line, "Const ", "")
    
    ' Split by commas for multiple declarations
    Dim parts As Variant
    parts = Split(line, ",")
    
    ' Extract just the variable names
    Dim names() As String
    ReDim names(LBound(parts) To UBound(parts))
    
    Dim i As Long
    For i = LBound(parts) To UBound(parts)
        Dim varPart As String
        varPart = Trim(parts(i))
        
        ' Get just the name part
        Dim asPos As Long, equalPos As Long, parenPos As Long
        asPos = InStr(varPart, " As ")
        equalPos = InStr(varPart, " = ")
        parenPos = InStr(varPart, "(")
        
        ' Find the end of the name
        Dim endPos As Long
        endPos = Len(varPart) + 1
        
        If asPos > 0 And (asPos < endPos) Then endPos = asPos
        If equalPos > 0 And (equalPos < endPos) Then endPos = equalPos
        If parenPos > 0 And (parenPos < endPos) Then endPos = parenPos
        
        ' Extract the name
        If endPos > 1 Then
            names(i) = Trim(Left(varPart, endPos - 1))
        Else
            names(i) = Trim(varPart)
        End If
    Next i
    
    CA_ExtractVariableNames = names
    
    If Err.Number <> 0 Then
        LogMessage "Error extracting variable names: " & Err.description, "ERROR"
        Err.Clear
        Dim fallback(0) As String
        fallback(0) = "UnknownVariable"
        CA_ExtractVariableNames = fallback
    End If
    
    On Error GoTo 0
End Function

' Extract variable type from a declaration
Private Function CA_ExtractVariableType(line As String, varName As String) As String
    On Error Resume Next
    
    ' Find the variable in the declaration
    Dim varPos As Long
    varPos = InStr(line, varName)
    
    If varPos = 0 Then
        CA_ExtractVariableType = "Variant" ' Default
        Exit Function
    End If
    
    ' Look for type declaration after the name
    Dim afterName As String
    afterName = Mid(line, varPos + Len(varName))
    
    ' Look for "As" keyword
    Dim asPos As Long
    asPos = InStr(afterName, "As ")
    
    If asPos = 0 Then
        CA_ExtractVariableType = "Variant" ' Default
        Exit Function
    End If
    
    ' Get the type
    Dim typePart As String
    typePart = Mid(afterName, asPos + 3)
    
    ' Find the end of the type name
    Dim spacePos As Long, commaPos As Long, equalPos As Long
    spacePos = InStr(typePart, " ")
    commaPos = InStr(typePart, ",")
    equalPos = InStr(typePart, "=")
    
    Dim endPos As Long
    endPos = Len(typePart) + 1
    
    If spacePos > 0 And (spacePos < endPos) Then endPos = spacePos
    If commaPos > 0 And (commaPos < endPos) Then endPos = commaPos
    If equalPos > 0 And (equalPos < endPos) Then endPos = equalPos
    
    ' Extract the type name
    CA_ExtractVariableType = Trim(Left(typePart, endPos - 1))
    
    If CA_ExtractVariableType = "" Then
        CA_ExtractVariableType = "Variant" ' Default
    End If
    
    If Err.Number <> 0 Then
        LogMessage "Error extracting variable type: " & Err.description, "ERROR"
        Err.Clear
        CA_ExtractVariableType = "Variant"
    End If
    
    On Error GoTo 0
End Function

' Dictionary helper functions for cross-platform compatibility
Private Function CA_DictionaryExists(dict As Object, key As String) As Boolean
    On Error Resume Next
    
    CA_DictionaryExists = False
    
    If typeName(dict) = "Dictionary" Then
        CA_DictionaryExists = dict.exists(key)
    ElseIf typeName(dict) = "Collection" Then
        ' For our collection implementation
        If dict.count >= 2 Then ' Collection of collections approach
            Dim i As Long
            For i = 1 To dict.item(1).count
                If dict.item(1).item(i) = key Then
                    CA_DictionaryExists = True
                    Exit Function
                End If
            Next i
        End If
    End If
    
    If Err.Number <> 0 Then
        LogMessage "Error checking dictionary exists: " & Err.description, "ERROR"
        Err.Clear
    End If
    
    On Error GoTo 0
End Function

' Mac-specific dictionary key exists check
Private Function CA_DictionaryKeyExists(dict As Object, key As String) As Boolean
    On Error Resume Next
    
    CA_DictionaryKeyExists = False
    
    If typeName(dict) = "Dictionary" Then
        CA_DictionaryKeyExists = dict.exists(key)
    ElseIf typeName(dict) = "Collection" Then
        ' For our collection implementation
        If dict.count >= 2 Then ' Collection of collections approach
            Dim i As Long
            For i = 1 To dict.item(1).count
                If dict.item(1).item(i) = key Then
                    CA_DictionaryKeyExists = True
                    Exit Function
                End If
            Next i
        End If
    End If
    
    If Err.Number <> 0 Then
        Error.message , "Error checking dictionary key exists: " & Err.description, "ERROR"
        Err.Clear
    End If
    
    On Error GoTo 0
End Function

' Get item from dictionary with Mac compatibility
Private Function CA_DictionaryGetItem(dict As Object, key As String) As Variant
    On Error Resume Next
    
    If typeName(dict) = "Dictionary" Then
        If dict.exists(key) Then
            If IsObject(dict(key)) Then
                Set CA_DictionaryGetItem = dict(key)
            Else
                CA_DictionaryGetItem = dict(key)
            End If
        End If
    ElseIf typeName(dict) = "Collection" Then
        ' For our collection implementation
        If dict.count >= 2 Then ' Collection of collections approach
            Dim i As Long
            For i = 1 To dict.item(1).count
                If dict.item(1).item(i) = key Then
                    If IsObject(dict.item(2).item(i)) Then
                        Set CA_DictionaryGetItem = dict.item(2).item(i)
                    Else
                        CA_DictionaryGetItem = dict.item(2).item(i)
                    End If
                    Exit Function
                End If
            Next i
        End If
    End If
    
    If Err.Number <> 0 Then
        LogMessage "Error getting dictionary item: " & Err.description, "ERROR"
        Err.Clear
    End If
    
    On Error GoTo 0
End Function

' Add or update item in dictionary with Mac compatibility
Private Sub CA_DictionaryAdd(dict As Object, key As String, value As Variant)
    On Error Resume Next
    
    If typeName(dict) = "Dictionary" Then
        If IsObject(value) Then
            Set dict(key) = value
        Else
            dict(key) = value
        End If
    ElseIf typeName(dict) = "Collection" Then
        ' For our collection implementation
        If dict.count >= 2 Then ' Collection of collections approach
            ' Check if key exists
            Dim keyExists As Boolean
            keyExists = False
            Dim keyIndex As Long
            keyIndex = 0
            
            Dim i As Long
            For i = 1 To dict.item(1).count
                If dict.item(1).item(i) = key Then
                    keyExists = True
                    keyIndex = i
                    Exit For
                End If
            Next i
            
            If keyExists Then
                ' Update existing value
                If IsObject(value) Then
                    Set dict.item(2).item(keyIndex) = value
                Else
                    dict.item(2).item(keyIndex) = value
                End If
            Else
                ' Add new key and value
                dict.item(1).Add key
                If IsObject(value) Then
                    dict.item(2).Add value
                Else
                    dict.item(2).Add value
                End If
            End If
        End If
    End If
    
    If Err.Number <> 0 Then
        Error.message , "Error adding to dictionary: " & Err.description, "ERROR"
        Err.Clear
    End If
    
    On Error GoTo 0
End Sub

' Get summary of analysis results
Public Function CA_GetAnalysisSummary(analysisResults As Object) As String
    On Error Resume Next
    
    Dim summary As String
    summary = "CODE ANALYSIS SUMMARY:" & vbCrLf & vbCrLf
    
    ' Check if there was an error
    If CA_DictionaryExists(analysisResults, "Error") Then
        summary = summary & "Error: " & CA_DictionaryGetItem(analysisResults, "Error") & vbCrLf
        CA_GetAnalysisSummary = summary
        Exit Function
    End If
    
    ' Get basic metrics
    summary = summary & "Total Lines: " & CA_DictionaryGetItem(analysisResults, "LineCount") & vbCrLf
    summary = summary & "Code Lines: " & CA_DictionaryGetItem(analysisResults, "CodeLineCount") & vbCrLf
    summary = summary & "Comment Lines: " & CA_DictionaryGetItem(analysisResults, "CommentCount") & vbCrLf
    summary = summary & "Blank Lines: " & CA_DictionaryGetItem(analysisResults, "BlankLineCount") & vbCrLf
    summary = summary & "Procedures: " & CA_DictionaryGetItem(analysisResults, "ProcedureCount") & vbCrLf
    summary = summary & "Variables: " & CA_DictionaryGetItem(analysisResults, "VariableCount") & vbCrLf
    summary = summary & "Comment Ratio: " & format(CA_DictionaryGetItem(analysisResults, "CommentRatio") * 100, "0.0") & "%" & vbCrLf
    summary = summary & "Maximum Indent Level: " & CA_DictionaryGetItem(analysisResults, "MaxIndentLevel") & vbCrLf
    summary = summary & vbCrLf
    
    ' Add procedure list
    Dim procedures As Object
    Set procedures = CA_DictionaryGetItem(analysisResults, "Procedures")
    
    If Not procedures Is Nothing Then
        If typeName(procedures) = "Dictionary" Then
            If procedures.count > 0 Then
                summary = summary & "PROCEDURES:" & vbCrLf
                
                Dim procKeys As Variant
                procKeys = procedures.keys
                
                Dim i As Long
                For i = 0 To UBound(procKeys)
                    summary = summary & "- " & procKeys(i) & vbCrLf
                Next i
            End If
        ElseIf typeName(procedures) = "Collection" Then
            If procedures.count >= 2 And procedures.item(1).count > 0 Then
                summary = summary & "PROCEDURES:" & vbCrLf
                
                For i = 1 To procedures.item(1).count
                    summary = summary & "- " & procedures.item(1).item(i) & vbCrLf
                Next i
            End If
        End If
    End If
    
    CA_GetAnalysisSummary = summary
    
    If Err.Number <> 0 Then
        LogMessage "Error generating analysis summary: " & Err.description, "ERROR"
        Err.Clear
        CA_GetAnalysisSummary = "Error generating analysis summary: " & Err.description
    End If
    
    On Error GoTo 0
End Function

' Reset module state
Public Sub CA_Reset()
    On Error Resume Next
    
    Set mCachedAnalysis = Nothing
    mCachedAnalysisCount = 0
    mIsInitialized = False
    mInProgress = False
    
    ' Reinitialize
    CA_Initialize
    
'    If Err.Number <> 0 Then
'        LogMessage "Error resetting Code Analysis module: " & Err.description, "ERROR"
'        Err.Clear
'    Else
'        LogMessage "Code Analysis module reset complete", "INFO"
'    End If
    
    On Error GoTo 0
End Sub

'=============================================================================
' END MODULE: modCodeAnalysis
'============================================================================='


